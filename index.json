[{"categories":null,"contents":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/notes/bash/basic/","summary":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","tags":null,"title":"Bash Variables"},{"categories":null,"contents":" Startup.cs No image display bug fix appsettings.json Uploading Image ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/notes/dotnet/gists/","summary":" Startup.cs No image display bug fix appsettings.json Uploading Image ","tags":null,"title":"Dotnet"},{"categories":["Dotnet","Blazor External Login","Identity Provider Google Facebook Microsoft Twitter"],"contents":" Blazor External Login Identity Provider Google, Facebook, Microsoft, Twitter we will explore how to configure external login identity providers in a Blazor application using the appsettings.json file. We will specifically focus on configuring Google, Facebook, Microsoft, and Twitter as external login providers.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nAuthentication: Authentication is the process of verifying the identity of a user. Blazor provides built-in support for authentication, allowing you to authenticate users using various identity providers.\nExternal Login Identity Providers: These are third-party services that allow users to authenticate and log in to your application using their existing credentials from platforms like Google, Facebook, Microsoft, or Twitter.\nIdentity Providers: Identity providers are third-party services that handle user authentication. Examples of identity providers include Google, Facebook, Microsoft, and Twitter. These providers allow users to log in to your application using their existing accounts.\nappsettings.json: The appsettings.json file is a configuration file used in ASP.NET Core applications to store application settings. It allows you to separate configuration from code, making it easier to manage and modify settings without redeploying the application.\nappsettings.json To configure external login identity providers in a Blazor application, you need to modify the appsettings.json file. The Authentication section of the appsettings.json file contains the configuration for each identity provider.\n\u0026#34;Authentication\u0026#34;: { \u0026#34;Google\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;ClientId\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;ClientSecret\u0026#34; }, \u0026#34;Facebook\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;ClientId\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;ClientSecret\u0026#34; }, \u0026#34;Microsoft\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;ClientId\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;ClientSecret\u0026#34; }, \u0026#34;Twitter\u0026#34;: { \u0026#34;ConsumerAPIKey\u0026#34;: \u0026#34;ConsumerAPIKey\u0026#34;, \u0026#34;ConsumerSecret\u0026#34;: \u0026#34;ConsumerSecret\u0026#34; } }, Each identity provider (Google, Facebook, Microsoft, and Twitter) is represented as a nested object within the Authentication section. Each provider has its own ClientId and ClientSecret or ConsumerAPIKey and ConsumerSecret values, which are obtained from the respective identity provider\u0026rsquo;s developer console.\nProgram.cs The AddAuthentication() method is used to configure the authentication services.\n// add external logins var config = builder.Configuration; builder.Services.AddAuthentication() .AddGoogle(options =\u0026gt; { IConfigurationSection googleAuthSection = config.GetSection(\u0026#34;Authentication:Google\u0026#34;); options.ClientId = googleAuthSection[\u0026#34;ClientId\u0026#34;]; options.ClientSecret = googleAuthSection[\u0026#34;ClientSecret\u0026#34;]; }) .AddFacebook(options =\u0026gt; { IConfigurationSection facebookAuthSection = config.GetSection(\u0026#34;Authentication:Facebook\u0026#34;); options.ClientId = facebookAuthSection[\u0026#34;ClientId\u0026#34;]; options.ClientSecret = facebookAuthSection[\u0026#34;ClientSecret\u0026#34;]; options.Scope.Add(\u0026#34;email\u0026#34;); options.Scope.Add(\u0026#34;public_profile\u0026#34;); }) .AddMicrosoftAccount(microsoftOptions =\u0026gt; { IConfigurationSection microsoftAuthSection = config.GetSection(\u0026#34;Authentication:Microsoft\u0026#34;); microsoftOptions.ClientId = microsoftAuthSection[\u0026#34;ClientId\u0026#34;]; microsoftOptions.ClientSecret = microsoftAuthSection[\u0026#34;ClientSecret\u0026#34;]; }) .AddTwitter(twitterOptions =\u0026gt; { IConfigurationSection twitterAuthSection = config.GetSection(\u0026#34;Authentication:Twitter\u0026#34;); twitterOptions.ConsumerKey = twitterAuthSection[\u0026#34;ConsumerAPIKey\u0026#34;]; twitterOptions.ConsumerSecret = twitterAuthSection[\u0026#34;ConsumerSecret\u0026#34;]; twitterOptions.RetrieveUserDetails = true; }); The AddGoogle() method adds Google as an external login provider. It retrieves the client ID and client secret from the configuration file.\nThe AddFacebook() method adds Facebook as an external login provider. It also retrieves the client ID and client secret from the configuration file. Additionally, it specifies the scopes for which the application requests access.\nThe AddMicrosoftAccount() method adds Microsoft as an external login provider. It retrieves the client ID and client secret from the configuration file.\nThe AddTwitter() method adds Twitter as an external login provider. It retrieves the consumer key and consumer secret from the configuration file. It also enables the retrieval of user details.\nExternalLogin.cshtml.cs The ExternalLogin.cshtml.cs file, which handles the logic for confirming and creating user accounts using external login providers.\npublic async Task\u0026lt;IActionResult\u0026gt; OnPostConfirmationAsync(string returnUrl = null) { returnUrl = returnUrl ?? Url.Content(\u0026#34;~/\u0026#34;); // Get the information about the user from the external login provider var info = await _signInManager.GetExternalLoginInfoAsync(); if (ModelState.IsValid) { var user = CreateUser(); // fill user info (name, givenname, surname ...) FillExternalProviderUserInfo(user, info); var result = await _userManager.CreateAsync(user); if (result.Succeeded) { result = await _userManager.AddLoginAsync(user, info); if (result.Succeeded) { _logger.LogInformation(\u0026#34;User created an account using {Name} provider.\u0026#34;, info.LoginProvider); // Add User role await _userManager.AddToRoleAsync(user, \u0026#34;User\u0026#34;); var userId = await _userManager.GetUserIdAsync(user); var code = await _userManager.GenerateEmailConfirmationTokenAsync(user); code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code)); var callbackUrl = Url.Page( \u0026#34;/Account/ConfirmEmail\u0026#34;, pageHandler: null, values: new { area = \u0026#34;Identity\u0026#34;, userId = userId, code = code }, protocol: Request.Scheme); await _emailSender.SendEmailAsync(Input.Email, \u0026#34;Confirm your email\u0026#34;, $\u0026#34;Please confirm your account by \u0026lt;a href=\u0026#39;{HtmlEncoder.Default.Encode(callbackUrl)}\u0026#39;\u0026gt;clicking here\u0026lt;/a\u0026gt;.\u0026#34;); await _signInManager.SignInAsync(user, isPersistent: false, info.LoginProvider); return LocalRedirect(returnUrl); } } } ProviderDisplayName = info.ProviderDisplayName; ReturnUrl = returnUrl; return Page(); } public static class SupportedExternalLoginProviderNames { public const string GOOGLE = \u0026#34;Google\u0026#34;; public const string FACEBOOK = \u0026#34;Facebook\u0026#34;; public const string MICROSOFT = \u0026#34;Microsoft\u0026#34;; public const string TWITTER = \u0026#34;Twitter\u0026#34;; } private void FillExternalProviderUserInfo(ApplicationUser user, ExternalLoginInfo info) { if (info is null || string.IsNullOrEmpty(info.LoginProvider)) return; switch (info.LoginProvider) { case SupportedExternalLoginProviderNames.GOOGLE: Claim gname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == ClaimTypes.Name); if (gname is not null) user.Name = gname.Value; Claim ggivenName = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == ClaimTypes.GivenName); if (ggivenName is not null) user.GivenName = ggivenName.Value; Claim gsurname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == ClaimTypes.Surname); if (gsurname is not null) user.Surname = gsurname.Value; break; case SupportedExternalLoginProviderNames.FACEBOOK: Claim fname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;urn:facebook:name\u0026#34;); if (fname is not null) user.Name = fname.Value; Claim fgivenName = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;urn:facebook:first_name\u0026#34;); if (fgivenName is not null) user.Name = fgivenName.Value; Claim fsurname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;urn:facebook:last_name\u0026#34;); if (fsurname is not null) user.Name = fsurname.Value; break; case SupportedExternalLoginProviderNames.MICROSOFT: Claim mname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;displayName\u0026#34;); if (mname is not null) user.Name = mname.Value; Claim mgivenName = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;first_name\u0026#34;); if (mgivenName is not null) user.GivenName = mgivenName.Value; Claim msurname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;last_name\u0026#34;); if (msurname is not null) user.Surname = msurname.Value; break; case SupportedExternalLoginProviderNames.TWITTER: Claim tname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;screen_name\u0026#34;); if (tname is not null) user.Name = tname.Value; break; default: break; } } Configuring external login identity providers in a Blazor application is essential to provide users with the option to authenticate using their existing credentials from popular platforms like Google, Facebook, Microsoft, or Twitter. By using the appsettings.json file, you can easily configure these providers by specifying the required client IDs and client secrets.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppExternalLogin\n","date":"September 21, 2023","hero":"/dotnet/2023-09-21-blazor-external-login-identity-provider/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-09-21-blazor-external-login-identity-provider/","summary":"Blazor External Login Identity Provider Google, Facebook, Microsoft, Twitter we will explore how to configure external login identity providers in a Blazor application using the appsettings.json file. We will specifically focus on configuring Google, Facebook, Microsoft, and Twitter as external login providers.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nAuthentication: Authentication is the process of verifying the identity of a user.","tags":["Dotnet","Blazor External Login","Identity Provider Google Facebook Microsoft Twitter"],"title":"Blazor External Login Identity Provider Google, Facebook, Microsoft, Twitter"},{"categories":["Dotnet","Blazor Radzen Loading on Page"],"contents":" Blazor Radzen Loading on Page Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nRadzen: Radzen is a set of UI components for Blazor that provides ready-to-use components for building responsive and user-friendly web applications.\nLoading Indicator: A loading indicator is a visual element that indicates the progress of an ongoing operation, such as data loading or processing.\nProgressBarCircular: ProgressBarCircular is a Radzen component that displays a circular progress bar. It can be customized to show the current step number and percentage.\nLoadingIndicatorOptions.cs LoadingIndicatorOptions class is a C# code that defines the options for a loading indicator component in a Blazor application. This code provides a way to customize the behavior and appearance of the loading indicator.\nnamespace BlazorAppRadzenLoading.Components; public class LoadingIndicatorOptions { public LoadingIndicatorOptions( bool startAfterRender = true, bool showStepNumbers = false, bool showPercentage = true, int currentStep = 0, int totalSteps = 1) { StartAfterRender = startAfterRender; ShowStepNumbers = showStepNumbers; ShowPercentage = showPercentage; CurrentStep = currentStep; TotalSteps = totalSteps; } public Action? UpdateAction { get; set; } private bool startAfterRender; public bool StartAfterRender { get =\u0026gt; startAfterRender; set { startAfterRender = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private bool showStepNumbers; public bool ShowStepNumbers { get =\u0026gt; showStepNumbers; set { showStepNumbers = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private bool showPercentage; public bool ShowPercentage { get =\u0026gt; showPercentage; set { showPercentage = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private int currentStep; public int CurrentStep { get =\u0026gt; currentStep; set { currentStep = value; CurrentPercent = (int)(((float)currentStep / (float)totalSteps) * 100); if (UpdateAction is not null) UpdateAction.Invoke(); } } private int currentPercent; public int CurrentPercent { get =\u0026gt; currentPercent; set { currentPercent = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private int totalSteps = 1; public int TotalSteps { get =\u0026gt; totalSteps; set { totalSteps = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } } LoadingIndicatorOptions class: This class represents the options for the loading indicator. It contains properties and methods to control various aspects of the loading indicator, such as when to start rendering, whether to show step numbers or percentage, the current step, and the total number of steps.\nConstructor: The LoadingIndicatorOptions class has a constructor that initializes the properties of the class. It takes several optional parameters that allow you to customize the initial state of the loading indicator.\nProperties:\nStartAfterRender: A boolean property that determines whether the loading indicator should start rendering after the component has finished rendering.\nShowStepNumbers: A boolean property that determines whether to show step numbers in the loading indicator.\nShowPercentage: A boolean property that determines whether to show the percentage of completion in the loading indicator.\nCurrentStep: An integer property that represents the current step of the loading process.\nTotalSteps: An integer property that represents the total number of steps in the loading process.\nUpdateAction: An optional action delegate that is invoked whenever a property is updated. This allows you to perform additional actions when the loading indicator options change.\nProperty Setters: The properties of the LoadingIndicatorOptions class have custom setters that update the corresponding property value and invoke the UpdateAction delegate if it is not null. This ensures that any changes to the options trigger a refresh of the loading indicator.\nLoadingIndicatorRenderFragment.razor It consists of a RadzenStack component that contains a RadzenProgressBarCircular and a RadzenText component. The RadzenProgressBarCircular is used to display the loading progress, while the RadzenText component shows a loading message.\n\u0026lt;RadzenStack Orientation=\u0026#34;Orientation.Vertical\u0026#34; AlignItems=\u0026#34;AlignItems.Center\u0026#34; JustifyContent=\u0026#34;JustifyContent.Center\u0026#34; Wrap=\u0026#34;FlexWrap.Wrap\u0026#34; Class=\u0026#34;rz-m-12\u0026#34; Gap=\u0026#34;2rem\u0026#34;\u0026gt; \u0026lt;RadzenProgressBarCircular ShowValue=\u0026#34;true\u0026#34; Mode=\u0026#34;ProgressBarMode.Indeterminate\u0026#34; Size=\u0026#34;ProgressBarCircularSize.Large\u0026#34;\u0026gt; \u0026lt;Template\u0026gt; @if (Option.ShowStepNumbers) { @($\u0026#34;{Option.CurrentStep} / {Option.TotalSteps}\u0026#34;) } @if (Option.ShowPercentage) { @($\u0026#34;{Option.CurrentPercent}%\u0026#34;) } \u0026lt;/Template\u0026gt; \u0026lt;/RadzenProgressBarCircular\u0026gt; \u0026lt;RadzenText TextStyle=\u0026#34;TextStyle.H6\u0026#34;\u0026gt;Loading, please wait...\u0026lt;/RadzenText\u0026gt; \u0026lt;/RadzenStack\u0026gt; @code { [Parameter] public LoadingIndicatorOptions Option { get; set; } protected override void OnInitialized() { Option.UpdateAction = StateHasChanged; } } LoadingIndicator.razor @inject DialogService DialogService @code { [Parameter, EditorRequired] public EventCallback DoLoadDataCallback { get; set; } [Parameter, EditorRequired] public LoadingIndicatorOptions Option { get; set; } private CancellationTokenSource? cts; protected async override Task OnAfterRenderAsync(bool firstRender) { if (firstRender) if (Option.StartAfterRender) await this.Run(); } public async Task Run() { await this.ShowLoadingDialog(); await DoLoadDataCallback.InvokeAsync(); Option.CurrentStep = Option.TotalSteps; await this.HideDialog(); } private async Task ShowLoadingDialog() { cts = new CancellationTokenSource(); _ = InvokeAsync(async () =\u0026gt; await LoadingDialog()); await Task.Run(() =\u0026gt; CheckForHide(), cts.Token); } private async Task HideDialog() { if (cts is not null) cts.Cancel(); await InvokeAsync(StateHasChanged); } private async void CheckForHide() { if (cts is null) return; while (!cts.IsCancellationRequested) await Task.Delay(500); await InvokeAsync(() =\u0026gt; DialogService.Close()); } private async Task LoadingDialog() { await DialogService.OpenAsync\u0026lt;LoadingIndicatorRenderFragment\u0026gt;(\u0026#34;\u0026#34;, new Dictionary\u0026lt;string, object\u0026gt; { { \u0026#34;Option\u0026#34;, Option } }, new DialogOptions() { ShowTitle = false, Style = \u0026#34;min-height:auto;min-width:auto;width:auto\u0026#34;, CloseDialogOnEsc = false }); } } Dependency Injection: The @inject directive is used to inject the DialogService into the component. This service is provided by Radzen and allows us to interact with the dialog components.\nComponent Parameters: The component defines two parameters: DoLoadDataCallback and Option. These parameters are used to pass the necessary data and options to the component.\nLifecycle Method: The OnAfterRenderAsync method is overridden to execute code after the component has been rendered. In this method, we check if it\u0026rsquo;s the first render and if the StartAfterRender option is enabled. If so, we call the Run method.\nRun Method: The Run method is responsible for displaying the loading dialog, invoking the DoLoadDataCallback method to load the data, updating the current step, and hiding the dialog.\nShowLoadingDialog Method: This method creates a new CancellationTokenSource and invokes the LoadingDialog method asynchronously. It also starts a background task to check for cancellation and hide the dialog.\nHideDialog Method: This method cancels the CancellationTokenSource and updates the component's state to trigger a re-render.\nCheckForHide Method: This method continuously checks if the cancellation token has been requested and hides the dialog when it\u0026rsquo;s canceled.\nLoadingDialog Method: This method opens the loading indicator dialog using the DialogService. It passes the Option parameter and customizes the dialog options.\nPagewithLoading.razor Blazor page with a loading indicator component and some UI elements. It fetches data from the GitHub API and updates the page content accordingly.\n@page \u0026#34;/pagewithloading\u0026#34; @using System.Text.Json.Serialization; @using BlazorAppRadzenLoading.Models; @inject DialogService DialogService \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;!-- LOADING COMPONENT --\u0026gt; \u0026lt;BlazorAppRadzenLoading.Components.LoadingIndicator DoLoadDataCallback=\u0026#34;LoadDataAsync\u0026#34; Option=\u0026#34;options\u0026#34; /\u0026gt; \u0026lt;RadzenContent Container=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;assessment\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H1\u0026#34; style=\u0026#34;display: inline-block\u0026#34; Text=\u0026#34;Dashboard\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H2\u0026#34; Text=\u0026#34;Stats\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;badge\u0026#34; style=\u0026#34;color: #68d5c8; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Organization\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.Name\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #68d5c8; font-size: 16px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;functions\u0026#34; style=\u0026#34;color: #f9777f; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Total Repos\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.TotalPublicRepos.ToString()\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #f9777f; font-size: 24px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;thumb_up\u0026#34; style=\u0026#34;color: #ff6d41; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Total Followers\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.TotalFollowers.ToString()\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #ff6d41; font-size: 24px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;thumbs_up_down\u0026#34; style=\u0026#34;color: #479cc8; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Total Followings\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.TotalFollowings.ToString()\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #479cc8; font-size: 24px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H2\u0026#34; Text=\u0026#34;Repo Stats (aspnetcore)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-lg-6 col-xl-4\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;RadzenChart ColorScheme=\u0026#34;ColorScheme.Pastel\u0026#34;\u0026gt; \u0026lt;RadzenColumnSeries Title=\u0026#34;Issues by Label\u0026#34; CategoryProperty=\u0026#34;@(nameof(IssueGroupbyLabel.LabelName))\u0026#34; TItem=\u0026#34;IssueGroupbyLabel\u0026#34; Data=\u0026#34;@issueGroupsbyLabel\u0026#34; ValueProperty=\u0026#34;@(nameof(IssueGroupbyLabel.Count))\u0026#34; /\u0026gt; \u0026lt;/RadzenChart\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-lg-6 col-xl-4\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;RadzenChart ColorScheme=\u0026#34;ColorScheme.Pastel\u0026#34;\u0026gt; @if (issueGroupsbyLabelandCreatedAt is not null) { @foreach (var key in issueGroupsbyLabelandCreatedAt.Keys) { IEnumerable\u0026lt;IssueGroupbyLabel\u0026gt; list = issueGroupsbyLabelandCreatedAt[key].AsEnumerable(); \u0026lt;RadzenLineSeries Title=\u0026#34;@key\u0026#34; CategoryProperty=\u0026#34;@(nameof(IssueGroupbyLabel.CreatedAtString))\u0026#34; TItem=\u0026#34;IssueGroupbyLabel\u0026#34; Data=\u0026#34;@list\u0026#34; ValueProperty=\u0026#34;@(nameof(IssueGroupbyLabel.Count))\u0026#34; /\u0026gt; } } \u0026lt;/RadzenChart\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-lg-6 col-xl-4\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;RadzenChart ColorScheme=\u0026#34;ColorScheme.Pastel\u0026#34;\u0026gt; \u0026lt;RadzenBarSeries Title=\u0026#34;Issues by Date\u0026#34; CategoryProperty=\u0026#34;@(nameof(IssueGroup.CreatedAtString))\u0026#34; TItem=\u0026#34;IssueGroup\u0026#34; Data=\u0026#34;@issueGroupsCreatedAt\u0026#34; ValueProperty=\u0026#34;@(nameof(IssueGroup.Count))\u0026#34; /\u0026gt; \u0026lt;/RadzenChart\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H2\u0026#34; Text=\u0026#34;Repositories\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-6\u0026#34;\u0026gt; \u0026lt;RadzenCard\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H3\u0026#34; Text=\u0026#34;Last Updated Repos\u0026#34; /\u0026gt; \u0026lt;RadzenDataGrid Data=\u0026#34;@reposLastUpdated\u0026#34; TItem=\u0026#34;Repo\u0026#34; AllowFiltering=\u0026#34;false\u0026#34; AllowColumnResize=\u0026#34;true\u0026#34; AllowAlternatingRows=\u0026#34;false\u0026#34; AllowSorting=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Columns\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Repo\u0026#34; Property=\u0026#34;@nameof(Repo.Name)\u0026#34; Title=\u0026#34;@nameof(Repo.Name)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Repo\u0026#34; Property=\u0026#34;@nameof(Repo.UpdatedAt)\u0026#34; Title=\u0026#34;@nameof(Repo.UpdatedAt)\u0026#34; /\u0026gt; \u0026lt;/Columns\u0026gt; \u0026lt;/RadzenDataGrid\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-6\u0026#34;\u0026gt; \u0026lt;RadzenCard\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H3\u0026#34; Text=\u0026#34;Last Issues (aspnetcore)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGrid Data=\u0026#34;@issuesLastUpdated\u0026#34; TItem=\u0026#34;Issue\u0026#34; AllowFiltering=\u0026#34;false\u0026#34; AllowColumnResize=\u0026#34;true\u0026#34; AllowAlternatingRows=\u0026#34;false\u0026#34; AllowSorting=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Columns\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Issue\u0026#34; Property=\u0026#34;@nameof(Issue.Title)\u0026#34; Title=\u0026#34;@nameof(Issue.Title)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Issue\u0026#34; Property=\u0026#34;@nameof(Issue.State)\u0026#34; Title=\u0026#34;@nameof(Issue.State)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Issue\u0026#34; Property=\u0026#34;@nameof(Issue.UpdatedAt)\u0026#34; Title=\u0026#34;@nameof(Issue.UpdatedAt)\u0026#34; /\u0026gt; \u0026lt;/Columns\u0026gt; \u0026lt;/RadzenDataGrid\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenContent\u0026gt; @code { BlazorAppRadzenLoading.Components.LoadingIndicatorOptions options = new(true, false, true, 0, 6); Organization? organization; IEnumerable\u0026lt;Repo\u0026gt;? reposLastUpdated; IEnumerable\u0026lt;IssueGroupbyLabel\u0026gt;? issueGroupsbyLabel; Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt;? issueGroupsbyLabelandCreatedAt; IEnumerable\u0026lt;Issue\u0026gt;? issuesLastUpdated; IEnumerable\u0026lt;IssueGroup\u0026gt;? issueGroupsCreatedAt; private async Task LoadDataAsync() { //Thread.Sleep(5000); // testing organization = await GetOrganization(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 1; // property updates loading component //Thread.Sleep(5000); // testing issueGroupsbyLabel = await GetIssueGroupsbyLabel(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 2; // property updates loading component //Thread.Sleep(5000); // testing issueGroupsbyLabelandCreatedAt = await GetIssueGroupsbyLabelandCreatedAt(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 3; // property updates loading component //Thread.Sleep(5000); // testing issueGroupsCreatedAt = await GetIssueGroupsCreatedAt(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 4; // property updates loading component //Thread.Sleep(5000); // testing reposLastUpdated = await GetReposLastUpdated(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 5; // property updates loading component //Thread.Sleep(5000); // testing issuesLastUpdated = await GetIssuesLastUpdated(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 6; // property updates loading component } private async Task\u0026lt;Organization\u0026gt; GetOrganization() { using var request = new HttpRequestMessage(HttpMethod.Get, \u0026#34;https://api.github.com/orgs/dotnet\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;Organization\u0026gt;(); if (result is not null) { return result; } } return new(); } private async Task\u0026lt;IEnumerable\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt; GetIssueGroupsbyLabel() { List\u0026lt;IssueGroupbyLabel\u0026gt; res = new List\u0026lt;IssueGroupbyLabel\u0026gt;(); using var request = new HttpRequestMessage(HttpMethod.Get, $\u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=100\u0026amp;sort=created\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); using var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null \u0026amp;\u0026amp; result.Count() \u0026gt; 0) { foreach (var item in result) { foreach (var label in item.Labels) { var cont = res.FirstOrDefault(x =\u0026gt; x.LabelName == label.Name); if (cont is null) { cont = new IssueGroupbyLabel { LabelName = label.Name, Count = 1 }; res.Add(cont); } else { cont.Count++; } } } res = res.OrderByDescending(x =\u0026gt; x.Count).Take(10).ToList(); } } return res; } private async Task\u0026lt;Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt;\u0026gt; GetIssueGroupsbyLabelandCreatedAt() { Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt; dict = new Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt;(); using var request = new HttpRequestMessage(HttpMethod.Get, $\u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=100\u0026amp;sort=created\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); using var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null \u0026amp;\u0026amp; result.Count() \u0026gt; 0) { foreach (var item in result) { foreach (var label in item.Labels) { if (!dict.ContainsKey(label.Name)) dict.Add(label.Name, new List\u0026lt;IssueGroupbyLabel\u0026gt;()); var contain = dict[label.Name].FirstOrDefault(x =\u0026gt; x.LabelName == label.Name \u0026amp;\u0026amp; x.CreatedAt.Date == item.CreatedAt.Date); if (contain is not null) { contain.Count++; } else { dict[label.Name].Add(new IssueGroupbyLabel { LabelName = label.Name, CreatedAt = item.CreatedAt.Date, Count = 1 }); } } } dict = dict.OrderByDescending(x =\u0026gt; x.Value.Count).Take(5).ToDictionary(x =\u0026gt; x.Key, x =\u0026gt; x.Value); } } return dict; } private async Task\u0026lt;IEnumerable\u0026lt;IssueGroup\u0026gt;\u0026gt; GetIssueGroupsCreatedAt() { using var request = new HttpRequestMessage(HttpMethod.Get, $\u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=100\u0026amp;sort=created\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); using var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null \u0026amp;\u0026amp; result.Count() \u0026gt; 0) { return result.GroupBy(x =\u0026gt; new DateTime(x.CreatedAt.Year, x.CreatedAt.Month, x.CreatedAt.Day), x =\u0026gt; x, (key, g) =\u0026gt; new IssueGroup { CreatedAt = key, Count = g.Count() }) .Take(10); } } return new List\u0026lt;IssueGroup\u0026gt;(); } private async Task\u0026lt;IEnumerable\u0026lt;Repo\u0026gt;\u0026gt; GetReposLastUpdated() { using var request = new HttpRequestMessage(HttpMethod.Get, \u0026#34;https://api.github.com/orgs/dotnet/repos?per_page=10\u0026amp;sort=updated\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Repo\u0026gt;\u0026gt;(); if (result is not null) { return result; } } return new List\u0026lt;Repo\u0026gt;(); } private async Task\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt; GetIssuesLastUpdated() { using var request = new HttpRequestMessage(HttpMethod.Get, \u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=10\u0026amp;sort=updated\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null) { return result; } } return new List\u0026lt;Issue\u0026gt;(); } } Loading indicator component in the Blazor page. It specifies a callback method LoadDataAsync to be executed when the loading indicator is triggered. It also passes an options object to customize the loading indicator\u0026rsquo;s behavior.\nPage with Loading Indicator is a Blazor page that demonstrates the use of a loading indicator component to show the progress of data fetching. It fetches organization data from the GitHub API and updates the page content accordingly. This code can be customized and extended to fetch and display other data as well.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenLoading\n","date":"September 10, 2023","hero":"/dotnet/2023-09-10-blazor-radzen-loading-on-page/blazor_radzen_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-09-10-blazor-radzen-loading-on-page/","summary":"Blazor Radzen Loading on Page Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nRadzen: Radzen is a set of UI components for Blazor that provides ready-to-use components for building responsive and user-friendly web applications.\nLoading Indicator: A loading indicator is a visual element that indicates the progress of an ongoing operation, such as data loading or processing.","tags":["Dotnet","Blazor Radzen Loading on Page"],"title":"Blazor Radzen Loading on Page"},{"categories":["Dotnet","Blazor Send Email with MailKit"],"contents":" Blazor Send Email with MailKit How to send emails using MailKit in a Blazor application. MailKit is a cross-platform .NET library that provides a simple and efficient way to send and receive emails. We will create a class called EmailConfiguration to store the email server configuration settings.\nMailKit: MailKit is an open-source .NET library that provides a high-level API for sending and receiving emails using various protocols such as SMTP, POP3, and IMAP.\nSMTP: Simple Mail Transfer Protocol (SMTP) is a standard protocol used for sending emails over the internet. It is responsible for transferring the email from the sender\u0026rsquo;s mail server to the recipient\u0026rsquo;s mail server.\nBlazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code that runs on the client-side in the browser.\nethereal.email: https://ethereal.email/ is a service that allows developers to test email functionality in web applications by providing temporary email addresses and capturing the sent emails for inspection on their website. It is a useful tool for ensuring the proper functioning of email features without the need for real email accounts.\nEmailConfiguration.cs A class called EmailConfiguration that represents the email server configuration settings. It has the following properties:\nnamespace BlazorAppSendEmailwithMailKit.Data; public class EmailConfiguration { public string Host { get; set; } = string.Empty; public int Port { get; set; } public string Username { get; set; } = string.Empty; public string Password { get; set; } = string.Empty; public string From { get; set; } = string.Empty; public string Name { get; set; } = string.Empty; public bool EnableSSL { get; set; } } Host: The hostname or IP address of the email server.\nPort: The port number to connect to the email server.\nUsername: The username to authenticate with the email server.\nPassword: The password to authenticate with the email server.\nFrom: The email address from which the email will be sent.\nName: The name associated with the email address.\nEnableSSL: A boolean value indicating whether to use SSL/TLS encryption for the connection.\nEmailMessage.cs EmailMessage class is defined within the BlazorAppSendEmailwithMailKit.Data namespace. It contains three properties: Email, Subject, and Message.\nusing System.ComponentModel.DataAnnotations; namespace BlazorAppSendEmailwithMailKit.Data; public class EmailMessage { [EmailAddress] public string Email { get; set; } = string.Empty; [Required] public string Subject { get; set; } = string.Empty; [Required] public string Message { get; set; } = string.Empty; } IEmailSender.cs We define an interface called IEmailSender with a single method SendEmailAsync. This method takes three parameters: email (the recipient's email address), subject (the subject of the email), and htmlMessage (the HTML content of the email).\nnamespace BlazorAppSendEmailwithMailKit.Data; public interface IEmailSender { Task SendEmailAsync(string email, string subject, string htmlMessage); } This interface will serve as the contract for sending emails.\nEmailSenderMailKit.cs The EmailSenderMailKit class implements the IEmailSender interface, which requires the implementation of the SendEmailAsync method. This method takes the recipient's email address, subject, and HTML message as parameters.\nusing MailKit.Net.Smtp; using Microsoft.Extensions.Options; using MimeKit; using MimeKit.Text; namespace BlazorAppSendEmailwithMailKit.Data; public class EmailSenderMailKit : IEmailSender { private readonly EmailConfiguration _emailConfiguration; public EmailSenderMailKit(IOptions\u0026lt;EmailConfiguration\u0026gt; emailConfiguration) { this._emailConfiguration = emailConfiguration.Value; } public Task SendEmailAsync(string email, string subject, string htmlMessage) { return Execute(email, subject, htmlMessage); } private async Task Execute(string to, string subject, string htmlMessage) { string host = _emailConfiguration.Host; int port = _emailConfiguration.Port; string username = _emailConfiguration.Username; string password = _emailConfiguration.Password; string from = _emailConfiguration.From; string name = _emailConfiguration.Name; bool enableSsl = _emailConfiguration.EnableSSL; var email = new MimeMessage(); var sender = MailboxAddress.Parse(from); if (!string.IsNullOrEmpty(name)) sender.Name = name; email.Sender = sender; email.From.Add(sender); email.To.Add(MailboxAddress.Parse(to)); email.Subject = subject; email.Body = new TextPart(TextFormat.Html) { Text = htmlMessage }; using (var smtp = new SmtpClient()) { smtp.Timeout = 10000; // 10secs try { await smtp.ConnectAsync(host, port, enableSsl); if (!string.IsNullOrEmpty(username)) smtp.Authenticate(username, password); await smtp.SendAsync(email); await smtp.DisconnectAsync(true); } catch (Exception ex) { throw; } } } } The EmailSenderMailKit class also has a constructor that accepts an instance of IOptions\u0026lt;EmailConfiguration\u0026gt;. This allows us to retrieve the email server configuration settings from the appsettings.json file or any other configuration source.\nInside the Execute method, we retrieve the email server configuration settings from the _emailConfiguration object. We then create a new MimeMessage object and set the sender, recipient, subject, and body of the email.\nNext, we create an instance of SmtpClient and set its timeout to 10 seconds. We then connect to the email server using the ConnectAsync method, authenticate if a username and password are provided, send the email using the SendAsync method, and finally disconnect from the server using the DisconnectAsync method.\nappsettings.json appsettings.json file is a configuration file used in ASP.NET Core applications to store application settings. It follows a JSON format and can be used to store various settings, including email configuration.\n{ \u0026#34;Email\u0026#34;: { \u0026#34;Host\u0026#34;: \u0026#34;HOST_ADDRESS\u0026#34;, \u0026#34;Port\u0026#34;: 587, \u0026#34;Username\u0026#34;: \u0026#34;USERNAME\u0026#34;, \u0026#34;Password\u0026#34;: \u0026#34;PASSWORD\u0026#34;, \u0026#34;From\u0026#34;: \u0026#34;FROM_EMAIL\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;FROM_NAME\u0026#34;, \u0026#34;EnableSSL\u0026#34;: true }, \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } Email: This section contains the email configuration settings such as the host address, port number, username, password, from email address, from name, and whether to enable SSL.\nProgram.cs In the program.cs file sets up the email sending functionality using MailKit in a Blazor application. Let\u0026rsquo;s break down the code and understand its structure:\n// Add services to the container. builder.Services.AddTransient\u0026lt;IEmailSender, EmailSenderMailKit\u0026gt;(); builder.Services.Configure\u0026lt;EmailConfiguration\u0026gt;(options =\u0026gt; { builder.Configuration.GetSection(\u0026#34;Email\u0026#34;).Bind(options); }); The builder.Services.AddTransient\u0026lt;IEmailSender, EmailSenderMailKit\u0026gt;() line registers the EmailSenderMailKit class as the implementation for the IEmailSender interface. This allows us to inject the IEmailSender interface wherever we need to send emails.\nThe builder.Services.Configure\u0026lt;EmailConfiguration\u0026gt;(options =\u0026gt; { ... }) line configures the EmailConfiguration class by binding the configuration settings from the appsettings.json file. This allows us to retrieve the email configuration settings easily.\nSendEmail.razor Blazor component named SendEmail.razor. It allows users to enter an email address, subject, and message, and then sends the email using the IEmailSender service.\n@page \u0026#34;/sendemail\u0026#34; @using BlazorAppSendEmailwithMailKit.Data @inject IEmailSender EmailSender \u0026lt;PageTitle\u0026gt;Send Email\u0026lt;/PageTitle\u0026gt; @if (emailMessage is null) { \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; } else { \u0026lt;EditForm Model=@emailMessage OnValidSubmit=@ValidFormSubmitted\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;p\u0026gt;Send Email\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=emailMessage.Email class=\u0026#34;form-control\u0026#34; id=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; emailMessage.Email\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;subject\u0026#34;\u0026gt;Subject\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=emailMessage.Subject class=\u0026#34;form-control\u0026#34; id=\u0026#34;subject\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; emailMessage.Subject\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;message\u0026#34;\u0026gt;Message\u0026lt;/label\u0026gt; \u0026lt;InputTextArea @bind-Value=emailMessage.Message class=\u0026#34;form-control\u0026#34; id=\u0026#34;message\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; emailMessage.Message\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; value=\u0026#34;Send\u0026#34; /\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;result\u0026#34;\u0026gt;Result:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=@result readonly class=\u0026#34;form-control\u0026#34; id=\u0026#34;result\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } @code { private string result = string.Empty; private EmailMessage? emailMessage; protected override void OnInitialized() { emailMessage = new(); } private async Task ValidFormSubmitted() { if (emailMessage is null) return; try { result = \u0026#34;sending...\u0026#34;; await EmailSender.SendEmailAsync(emailMessage.Email, emailMessage.Subject, emailMessage.Message); result = \u0026#34;success\u0026#34;; } catch (Exception ex) { result = ex.Message; } } } The code is structured as follows:\nPage Directive: The @page directive specifies the URL route for the component.\nUsing Directive: The @using directive imports the necessary namespaces for the component.\nDependency Injection: The @inject directive injects the IEmailSender service into the component.\nPageTitle: The PageTitle component sets the page title.\nConditional Rendering: The code uses conditional rendering to display a loading message while the email message is being loaded, and the email form once the message is loaded.\nEditForm: The EditForm component wraps the email form and handles form submission and validation.\nDataAnnotationsValidator: The DataAnnotationsValidator component performs validation based on data annotations applied to the EmailMessage model.\nValidationSummary: The ValidationSummary component displays a summary of validation errors.\nForm Fields: The code defines form fields for email, subject, and message using Blazor's InputText and InputTextArea components. It also includes validation messages for each field.\nSubmit Button: The code includes a submit button that triggers the ValidFormSubmitted method when clicked.\nResult Display: The code displays the result of the email sending operation.\nCode Block: The @code block contains the C# code for the component. It initializes the result variable, handles form submission, and sends the email using the EmailSender service.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppSendEmailwithMailKit\n","date":"September 3, 2023","hero":"/dotnet/2023-09-03-blazor-send-email-with-mailkit/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-09-03-blazor-send-email-with-mailkit/","summary":"Blazor Send Email with MailKit How to send emails using MailKit in a Blazor application. MailKit is a cross-platform .NET library that provides a simple and efficient way to send and receive emails. We will create a class called EmailConfiguration to store the email server configuration settings.\nMailKit: MailKit is an open-source .NET library that provides a high-level API for sending and receiving emails using various protocols such as SMTP, POP3, and IMAP.","tags":["Dotnet","Blazor Send Email with MailKit"],"title":"Blazor Send Email with MailKit"},{"categories":["Dotnet","Blazor Redis as Backplane"],"contents":" Blazor Redis as Backplane (with Master and Slave) Blazor: Blazor is a web framework developed by Microsoft that allows developers to build interactive web applications using C# instead of JavaScript. It enables the creation of single-page applications (SPAs) that run entirely in the browser.\nRedis: Redis is an open-source, in-memory data structure store that can be used as a database, cache, and message broker. It provides high-performance data storage and retrieval, making it suitable for use in applications that require fast and scalable data access.\nRedis as Backplane: In the context of a web application, a backplane is a communication channel that allows multiple instances of the application to synchronize and share data. Redis can be used as a backplane to enable real-time communication and data sharing between different instances of a Blazor application.\nServiceStack.Redis: ServiceStack.Redis is a high-performance, feature-rich Redis client library for .NET. It provides a simple and intuitive API for interacting with Redis servers and supports advanced features such as connection pooling, pipelining, and pub/sub.\nStackExchange.Redis: StackExchange.Redis is another popular Redis client library for .NET. It is widely used and offers a high-performance, low-level API for interacting with Redis servers. It supports advanced features such as distributed locks, Lua scripting, and Redis Cluster.\nPrerequisites Redis Server Files and Master-Slave Configurations: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppwithRedis/RedisServerFiles\nDownload and Run RUN_SERVERS.bat\nif not exist \u0026#34;Redis-x64-3.0.504_master\u0026#34; ( mkdir \u0026#34;Redis-x64-3.0.504_master\u0026#34; tar -xf Redis-x64-3.0.504.zip -C \u0026#34;Redis-x64-3.0.504_master\u0026#34; ) if not exist \u0026#34;Redis-x64-3.0.504_slave\u0026#34; ( mkdir \u0026#34;Redis-x64-3.0.504_slave\u0026#34; tar -xf Redis-x64-3.0.504.zip -C \u0026#34;Redis-x64-3.0.504_slave\u0026#34; ) start \u0026#34;Start RedisMaster\u0026#34; Redis-x64-3.0.504_master\\redis-server.exe redis.windows.master.conf start \u0026#34;Start RedisSlave\u0026#34; Redis-x64-3.0.504_slave\\redis-server.exe redis.windows.slave.conf Now, Redis Master-Slave Servers are ready. MASTER 127.0.0.1:6379 slave 127.0.0.1:6380 ConfigurationManager.cs The ConfigurationManager class is defined as a static class, meaning it cannot be instantiated. It contains a single static property called AppSetting, which represents the application\u0026rsquo;s configuration settings.\nThe AppSetting property is of type IConfiguration, which is an interface that provides access to configuration settings. This property is read-only, meaning it can only be accessed but not modified.\nThe class also has a static constructor, denoted by the static ConfigurationManager() syntax. This constructor is automatically called when the class is accessed for the first time and is used to initialize the AppSetting property.\nnamespace BlazorAppwithRedis; public static class ConfigurationManager { public static IConfiguration AppSetting { get; } static ConfigurationManager() { AppSetting = new ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(\u0026#34;appsettings.json\u0026#34;).Build(); } } ConnectionHelper.cs The ConnectionHelper class is declared as a public class. Three private static fields are defined to store the Redis clients and manager: _clientsManager, _redisClientMaster, and _redisClientSlave.\nA static constructor is defined to initialize the Redis connection. It is executed only once when the class is first accessed. Inside the static constructor, the Redis clients manager is initialized with the Redis server URLs obtained from the configuration. The Redis client instances for master and slave are obtained from the clients manager. The lazy connection is initialized using a lambda expression that creates a connection string from the Redis server URLs and connects to the Redis server using ConnectionMultiplexer.\nThe lazyConnection field is declared as a Lazy\u0026lt;ConnectionMultiplexer\u0026gt; to ensure lazy initialization of the Redis connection. A public static property Connection is defined to provide access to the Redis connection. The Connection property returns the value of the lazyConnection field. A public static method GetServers() is defined to get the Redis servers from the connection.\nusing ServiceStack.Redis; using StackExchange.Redis; namespace BlazorAppwithRedis; public class ConnectionHelper { private static readonly IRedisClientsManager _clientsManager; private static readonly IRedisClient _redisClientMaster; private static readonly IRedisClient _redisClientSlave; static ConnectionHelper() { _clientsManager = new PooledRedisClientManager(ConfigurationManager.AppSetting[\u0026#34;RedisURLMaster\u0026#34;], ConfigurationManager.AppSetting[\u0026#34;RedisURLSlave\u0026#34;]); _redisClientMaster = _clientsManager.GetClient(); _redisClientSlave = _clientsManager.GetReadOnlyClient(); ConnectionHelper.lazyConnection = new Lazy\u0026lt;ConnectionMultiplexer\u0026gt;(() =\u0026gt; { string urls = $\u0026#34;{ConfigurationManager.AppSetting[\u0026#34;RedisURLMaster\u0026#34;]},{ConfigurationManager.AppSetting[\u0026#34;RedisURLSlave\u0026#34;]},allowAdmin=true\u0026#34;; return ConnectionMultiplexer.Connect(urls); }); } private static Lazy\u0026lt;ConnectionMultiplexer\u0026gt; lazyConnection; public static ConnectionMultiplexer Connection { get { return lazyConnection.Value; } } public static IEnumerable\u0026lt;IServer\u0026gt; GetServers() { return Connection.GetServers(); } } ICacheService.cs ICacheService in the BlazorAppwithRedis.Cache namespace. This interface defines a set of methods that can be used to interact with a cache service.\nGetConnectionState(): This method returns the connection state of the cache service. It returns a tuple containing the connection state (ConnectionStates) and a message (string) indicating the current state of the connection.\nGetTTL(string key): This method returns the time-to-live (TTL) of a cached item specified by the key. The TTL represents the remaining time until the item expires and is automatically removed from the cache. It returns a TimeSpan object representing the remaining time.\nGetDataMaster(string key): This method retrieves data from the cache using the key. It returns the cached data of type T if it exists, or null if the data is not found.\nGetDataSlave(string key): This method retrieves data from a slave cache using the key. It is similar to GetDataMaster, but it retrieves data from a read-only replica of the cache.\nSetDataMaster(string key, T value, DateTimeOffset expirationTime): This method sets data in the cache using the key, value, and expirationTime. It stores the data in the master cache and specifies the expiration time for the data.\nRemoveDataMaster(string key): This method removes data from the cache using the key. It deletes the data from the master cache.\nnamespace BlazorAppwithRedis.Cache; public interface ICacheService { (ConnectionStates ConnectionState, string Message) GetConnectionState(); TimeSpan? GetTTL(string key); T? GetDataMaster\u0026lt;T\u0026gt;(string key); T? GetDataSlave\u0026lt;T\u0026gt;(string key); bool? SetDataMaster\u0026lt;T\u0026gt;(string key, T value, DateTimeOffset expirationTime); object? RemoveDataMaster(string key); } CacheService.cs It implements the ICacheService interface, which defines the contract for interacting with the cache.\nprivate IDatabase? _db: A private field that holds the reference to the Redis database. private ConnectionStates _connectionState: An enumeration that represents the current connection state of the cache service. private string _currentConnectionStatusMessage: A string that stores the current connection status message.\nThe class also has a constructor that initializes the cache service by establishing a connection to Redis. If the connection is successful, the connection state is set to Connected, and the current connection status message is set to \u0026ldquo;Connected.\u0026rdquo; If an exception occurs during the connection process, the connection state is set to NoConnection, and the current connection status message is set to the error message.\nusing StackExchange.Redis; using System.Text.Json; namespace BlazorAppwithRedis.Cache; public enum ConnectionStates { Unknown = 0, Connected = 1, NoConnection = 2, } public class CacheService : ICacheService { private IDatabase? _db; private ConnectionStates _connectionState = ConnectionStates.Unknown; private string _currentConnectionStatusMessage; public CacheService() { try { _db = ConnectionHelper.Connection.GetDatabase(0); _connectionState = ConnectionStates.Connected; _currentConnectionStatusMessage = \u0026#34;Connected.\u0026#34;; } catch (Exception ex) { _connectionState = ConnectionStates.NoConnection; string errorMessage = ex.Message; var innerEx = ex.InnerException; while (innerEx != null) { errorMessage += Environment.NewLine + innerEx.Message; innerEx = innerEx.InnerException; } _currentConnectionStatusMessage = errorMessage; } } public (ConnectionStates ConnectionState, string Message) GetConnectionState() =\u0026gt; (_connectionState, _currentConnectionStatusMessage); public TimeSpan? GetTTL(string key) { if (_connectionState != ConnectionStates.Connected) return null; var value = _db.KeyTimeToLive(key, CommandFlags.PreferMaster); if (value != null) { return value; } return default; } public T? GetDataMaster\u0026lt;T\u0026gt;(string key) { if (_connectionState != ConnectionStates.Connected) return default; var value = _db.StringGet(key, CommandFlags.PreferMaster); if (!string.IsNullOrEmpty(value)) { return JsonSerializer.Deserialize\u0026lt;T\u0026gt;(value!); } return default; } public T? GetDataSlave\u0026lt;T\u0026gt;(string key) { if (_connectionState != ConnectionStates.Connected) return default; var value = _db.StringGet(key, CommandFlags.PreferReplica); if (!string.IsNullOrEmpty(value)) { return JsonSerializer.Deserialize\u0026lt;T\u0026gt;(value!); } return default; } public bool? SetDataMaster\u0026lt;T\u0026gt;(string key, T value, DateTimeOffset expirationTime) { if (_connectionState != ConnectionStates.Connected) return default; TimeSpan expiryTime = expirationTime.DateTime.Subtract(DateTime.Now); var isSet = _db.StringSet(key, JsonSerializer.Serialize(value), expiryTime, flags: CommandFlags.PreferMaster); return isSet; } public object? RemoveDataMaster(string key) { if (_connectionState != ConnectionStates.Connected) return null; bool _isKeyExist = _db.KeyExists(key); if (_isKeyExist == true) { return _db.KeyDelete(key, CommandFlags.PreferMaster); } return false; } } GetConnectionState(): Returns the current connection state and status message of the cache service.\nGetTTL(string key): Retrieves the time-to-live (TTL) of a cache key, which represents the remaining time until the key expires.\nGetDataMaster(string key): Retrieves data from the cache using the specified key, preferring the master node in a Redis cluster.\nGetDataSlave(string key): Retrieves data from the cache using the specified key, preferring a replica node in a Redis cluster.\nSetDataMaster(string key, T value, DateTimeOffset expirationTime): Stores data in the cache using the specified key, with an optional expiration time.\nRemoveDataMaster(string key): Removes data from the cache using the specified key, preferring the master node in a Redis cluster.\nappsettings.json { \u0026#34;RedisURLMaster\u0026#34;: \u0026#34;127.0.0.1:6379\u0026#34;, \u0026#34;RedisURLSlave\u0026#34;: \u0026#34;127.0.0.1:6380\u0026#34;, \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } The above code snippet shows two key settings related to Redis: RedisURLMaster and RedisURLSlave. These settings define the URLs of the Redis instances that will be used as the master and slave nodes in a Redis cluster.\nBlogPostService.cs BlogPostService class is structured as follows:\nIt imports the necessary namespaces for the cache, data, and models. It defines the class and its dependencies, including the ApplicationDbContext and ICacheService. It initializes the class with the required dependencies through the constructor. It provides methods for retrieving, creating, updating, and deleting blog posts. It includes a private method for setting the blog post data in the cache.\nusing BlazorAppwithRedis.Cache; using BlazorAppwithRedis.Data; using BlazorAppwithRedis.Models; using Microsoft.EntityFrameworkCore; namespace BlazorAppwithRedis.Services; public class BlogPostService { private readonly ApplicationDbContext _context; private readonly ICacheService _cacheService; private static object _lock = new object(); public BlogPostService(ApplicationDbContext context, ICacheService cacheService) { _context = context; _cacheService = cacheService; } public async Task\u0026lt;(BlogPost? Data, string From)\u0026gt; GetbyIdAsync(int id) { BlogPost? filteredData; var data = _cacheService.GetDataSlave\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt;(\u0026#34;blogpost\u0026#34;); if (data is not null) { filteredData = data.Where(x =\u0026gt; x.Id == id).FirstOrDefault(); return (Data: filteredData, From: \u0026#34;cache\u0026#34;); } data = await SetBlogPostData(); filteredData = data.Where(x =\u0026gt; x.Id == id).FirstOrDefault(); return (Data: filteredData, From: \u0026#34;database\u0026#34;); } public async Task\u0026lt;(IEnumerable\u0026lt;BlogPost\u0026gt; Data, string From)\u0026gt; GetAllAsync() { var data = _cacheService.GetDataSlave\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt;(\u0026#34;blogpost\u0026#34;); if (data is not null) return (Data: data, From: \u0026#34;cache\u0026#34;); data = await SetBlogPostData(); return (Data: data, From: \u0026#34;database\u0026#34;); } public async Task\u0026lt;bool\u0026gt; AddBlogPostAsync(BlogPost blogPost) { try { var result = await _context.BlogPosts.AddAsync(blogPost); await _context.SaveChangesAsync(); _cacheService.RemoveDataMaster(\u0026#34;blogpost\u0026#34;); await SetBlogPostData(); } catch (Exception ex) { return false; } return true; } public async Task\u0026lt;bool\u0026gt; UpdateBlogPostAsync(int id, BlogPost blogPost) { try { var oldBlogPost = await _context.BlogPosts.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); if (oldBlogPost == null) return false; oldBlogPost.Title = blogPost.Title; oldBlogPost.Content = blogPost.Content; await _context.SaveChangesAsync(); _cacheService.RemoveDataMaster(\u0026#34;blogpost\u0026#34;); await SetBlogPostData(); } catch (Exception ex) { return false; } return true; } public async Task\u0026lt;bool\u0026gt; DeletebyIdAsync(int id) { try { var blogPost = await _context.BlogPosts.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); if (blogPost is null) return false; _context.BlogPosts.Remove(blogPost); await _context.SaveChangesAsync(); _cacheService.RemoveDataMaster(\u0026#34;blogpost\u0026#34;); await SetBlogPostData(); } catch (Exception ex) { return false; } return true; } private async Task\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt; SetBlogPostData() { var expirationTime = DateTimeOffset.Now.AddMinutes(5.0); var data = await _context.BlogPosts.ToListAsync(); lock (_lock) { _cacheService.SetDataMaster\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt;(\u0026#34;blogpost\u0026#34;, data, expirationTime); } return data; } } Source Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppwithRedis\n","date":"August 30, 2023","hero":"/dotnet/2023-08-30-blazor-redis-as-backplane/blazor_dotnet_redis.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-30-blazor-redis-as-backplane/","summary":"Blazor Redis as Backplane (with Master and Slave) Blazor: Blazor is a web framework developed by Microsoft that allows developers to build interactive web applications using C# instead of JavaScript. It enables the creation of single-page applications (SPAs) that run entirely in the browser.\nRedis: Redis is an open-source, in-memory data structure store that can be used as a database, cache, and message broker. It provides high-performance data storage and retrieval, making it suitable for use in applications that require fast and scalable data access.","tags":["Dotnet","Blazor Redis as Backplane"],"title":"Blazor Redis as Backplane"},{"categories":["Dotnet","Blazor Resize and Upload Images"],"contents":" Blazor Resize and Upload Images Upload and save images in a Blazor application using C#. We will cover the process of uploading an image, resizing it if necessary, generating a random file name, and saving it to the server\u0026rsquo;s wwwroot directory.\nInputFile: The InputFile component in Blazor allows users to select files from their local system. It triggers an event when the file selection changes.\nFile Size Limit: We can set a maximum file size limit to restrict the size of the uploaded image. In our example, we have set the limit to 800KB.\nImage Resizing: We can resize the uploaded image to a specific width and height if needed. In our code, we have commented out the image resizing logic, but you can uncomment it and modify it according to your requirements.\nRandom File Name: To avoid naming conflicts, we generate a random file name for the uploaded image. We use the Guid.NewGuid().ToString(\u0026quot;N\u0026quot;) method to generate a unique identifier and combine it with the file extension.\nSaving to wwwroot: We save the uploaded image to the wwwroot directory of the Blazor application. This allows us to access the image using a relative path in the application.\nCreate.razor Blazor component that handles the creation of a blog post. It includes an EditForm component that binds to a BlogPostViewModel object.\nHTML Markup: The HTML markup defines the form elements for creating a blog post. It includes an InputFile component for selecting the image, a preview section to display the selected image, and a submit button.\nCode-behind: The code-behind section contains the C# logic for handling the image upload and saving process. It includes event handlers for the OnChange event of the InputFile component and the submit button\u0026rsquo;s OnValidSubmit event.\n@page \u0026#34;/BlogPost/Create\u0026#34; \u0026lt;PageTitle\u0026gt;Create\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Create\u0026lt;/h1\u0026gt; \u0026lt;h4\u0026gt;BlogPost\u0026lt;/h4\u0026gt; \u0026lt;hr /\u0026gt; @if (blogPost == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;EditForm Model=\u0026#34;@blogPost\u0026#34; OnValidSubmit=\u0026#34;@HandleValidSubmit\u0026#34; Context=\u0026#34;createBlogPost\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;Preview\u0026lt;/label\u0026gt; @if (blogPost is not null \u0026amp;\u0026amp; !string.IsNullOrEmpty(blogPost.PostImage)) { \u0026lt;div class=\u0026#34;form-control\u0026#34;\u0026gt; @*\u0026lt;img src=\u0026#34;data:@selectedImage.ContentType;base64,@selectedImage.Base64data\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt;*@ \u0026lt;img src=\u0026#34;/images/@blogPost.PostImage\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.PostImage)\u0026lt;/label\u0026gt; \u0026lt;InputFile OnChange=\u0026#34;OnChange\u0026#34; id=\u0026#34;upload\u0026#34; class=\u0026#34;form-control\u0026#34; accept=\u0026#34;image/png, image/jpeg\u0026#34; /\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPost.PostImage\u0026#34; readonly class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;p class=\u0026#34;text-muted mb-0\u0026#34;\u0026gt;Allowed JPG, GIF or PNG. Max size of 800K (1024x1024 pixels)\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Title)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPost.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPost.Title)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Content)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPost.Content\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPost.Content)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Create\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026#34;/BlogPost\u0026#34;\u0026gt;Back to List\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; } @code { private BlogPostViewModel? blogPost; protected override void OnInitialized() { blogPost = new(); } async Task OnChange(InputFileChangeEventArgs e) { if (blogPost is null) return; var files = e.GetMultipleFiles(); if (files.Count \u0026gt; 0) { var file = files[0]; if (file.Size \u0026gt; (1024 * 800)) // MAX FILE SIZE: \u0026lt; 800KB return; // resize image //var resizedFile = await file.RequestImageFileAsync(file.ContentType, 1024, 1024); // resize the image file var resizedFile = file; //generate random imagename string imagename = Guid.NewGuid().ToString(\u0026#34;N\u0026#34;) + Path.GetExtension(file.Name); // save image to directory string imagePath = Path.Combine(System.Environment.CurrentDirectory, \u0026#34;wwwroot\u0026#34;, \u0026#34;images\u0026#34;); string imageFullName = Path.Combine(imagePath, imagename); await using FileStream fs = new(imageFullName, FileMode.Create); await resizedFile.OpenReadStream().CopyToAsync(fs); //await File.WriteAllBytesAsync(imageFullName, selectedImage.Data); blogPost.PostImage = imagename; StateHasChanged(); } } private async void HandleValidSubmit() { if (blogPost is null) return; var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.AddBlogPostAsync(model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } } We explored how to upload and save images in a Blazor application using C#. We covered the key concepts of image uploading, resizing, generating random file names, and saving images to the wwwroot directory. By following the code examples provided, you can implement image uploading functionality in your own Blazor projects.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppResizeUploadImages\n","date":"August 25, 2023","hero":"/dotnet/2023-08-25-blazor-resize-and-upload-images/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-25-blazor-resize-and-upload-images/","summary":"Blazor Resize and Upload Images Upload and save images in a Blazor application using C#. We will cover the process of uploading an image, resizing it if necessary, generating a random file name, and saving it to the server\u0026rsquo;s wwwroot directory.\nInputFile: The InputFile component in Blazor allows users to select files from their local system. It triggers an event when the file selection changes.\nFile Size Limit: We can set a maximum file size limit to restrict the size of the uploaded image.","tags":["Dotnet","Blazor Resize and Upload Images"],"title":"Blazor Resize and Upload Images"},{"categories":["Dotnet","Blazor Scheduling with Quartz.NET"],"contents":" Blazor Scheduling with Quartz.NET Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nQuartz.NET: Quartz.NET is a popular open-source job scheduling library for .NET applications. It provides a flexible and powerful way to schedule and execute jobs at specified intervals.\nScheduling: Scheduling refers to the process of defining when and how often a job or task should be executed. In this code, we use Quartz.NET to schedule jobs to be executed at specific times or intervals.\nJobs: In the context of this application, a job refers to a specific task or action that needs to be executed at a scheduled time or interval. Jobs can be created, paused, resumed, and deleted.\nTriggers: Triggers are used to define when and how often a job should be executed. They specify the schedule, start time, end time, and other parameters for a job.\nJob Class: A job class in Quartz.NET represents a unit of work that needs to be executed by the scheduler. It implements the IJob interface and defines the logic to be executed when the job is triggered.\nAddRandomBlogPostJob.cs The AddRandomBlogPostJob class is defined in the BlazorAppQuartzNETScheduler.Jobs namespace. It implements the IJob interface provided by Quartz.NET. The class is marked with the [DisallowConcurrentExecution] attribute, which ensures that the job will not be executed concurrently.\nusing BlazorAppQuartzNETScheduler.Data; using BlazorAppQuartzNETScheduler.Models; using BlazorAppQuartzNETScheduler.Services; using Quartz; namespace BlazorAppQuartzNETScheduler.Jobs; [DisallowConcurrentExecution] public class AddRandomBlogPostJob : IJob { private readonly ILogger\u0026lt;AddRandomBlogPostJob\u0026gt; _logger; private readonly BlogPostService _blogPostService; public AddRandomBlogPostJob(ILogger\u0026lt;AddRandomBlogPostJob\u0026gt; logger, BlogPostService blogPostService) { _logger = logger; _blogPostService = blogPostService; } public async Task Execute(IJobExecutionContext context) { BlogPost model = SeedData.GetRandomPost(); await _blogPostService.AddBlogPostAsync(model); } } The class has two dependencies injected through its constructor: ILogger\u0026lt;AddRandomBlogPostJob\u0026gt; and BlogPostService. The ILogger is used for logging purposes, while the BlogPostService is a service responsible for adding blog posts to the application.\nThe Execute method is the main entry point for the job execution. It is called by the Quartz.NET scheduler when the job is triggered. Inside the Execute method, a random blog post model is obtained using the SeedData.GetRandomPost() method. Then, the AddBlogPostAsync method of the BlogPostService is called to add the blog post to the application.\nProgram.cs Setting up the Quartz database:\nstring quartzConnectionString = builder.Configuration.GetConnectionString(\u0026#34;QuartzConnectionString\u0026#34;); SqliteConnectionStringBuilder quartzSqliteConnectionStringBuilder = new SqliteConnectionStringBuilder( quartzConnectionString); CheckandCreateQuartzDatabase(quartzSqliteConnectionStringBuilder).GetAwaiter().GetResult(); We retrieve the connection string for the Quartz database from the application\u0026rsquo;s configuration. We then create a SqliteConnectionStringBuilder object using the connection string and pass it to the CheckandCreateQuartzDatabase method to check and create the Quartz database if necessary.\nAdding Quartz services:\nbuilder.Services.AddDbContext\u0026lt;QuartzDbContext\u0026gt;(options =\u0026gt; { options.UseSqlite(quartzConnectionString); }); builder.Services.AddQuartz(q =\u0026gt; { q.UsePersistentStore(per =\u0026gt; { per.UseSQLite(quartzSqliteConnectionStringBuilder.ConnectionString); per.UseJsonSerializer(); }); q.UseMicrosoftDependencyInjectionJobFactory(); }); builder.Services.AddQuartzHostedService(opt =\u0026gt; { opt.WaitForJobsToComplete = true; }); We add the necessary Quartz services to the application's service collection. We configure the Quartz database context using the SQLite connection string, enable persistent storage for Quartz jobs using SQLite, and specify the job factory to use Microsoft Dependency Injection. We also configure the Quartz hosted service to wait for jobs to complete before shutting down.\nChecking and creating jobs:\npublic static async Task CheckandCreateJobs(this IServiceCollection services) { using (IServiceScope tmp = services.BuildServiceProvider().CreateScope()) { await using var _context = tmp.ServiceProvider.GetRequiredService\u0026lt;ApplicationDbContext\u0026gt;(); var seedData = tmp.ServiceProvider.GetRequiredService\u0026lt;SeedData\u0026gt;(); await seedData.CheckandCreateJobsData(); } } This code defines an extension method CheckandCreateJobs for the IServiceCollection interface. It creates a new scope using the application\u0026rsquo;s service provider and retrieves the necessary services (ApplicationDbContext and SeedData). It then calls the CheckandCreateJobsData method to check and create the necessary jobs.\nQuartz.NET Models Quartz.NET provides various models and classes to represent different entities involved in scheduling, such as triggers, jobs, and schedulers. These models help in configuring and managing the scheduling process.\nnamespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzBlobTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public byte[]? BlobData { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzCalendar { public string SchedName { get; set; } = null!; public string CalendarName { get; set; } = null!; public byte[] Calendar { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzCronTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string CronExpression { get; set; } = null!; public string? TimeZoneId { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzFiredTrigger { public string SchedName { get; set; } = null!; public string EntryId { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string InstanceName { get; set; } = null!; public long FiredTime { get; set; } public long SchedTime { get; set; } public long Priority { get; set; } public string State { get; set; } = null!; public string? JobName { get; set; } public string? JobGroup { get; set; } public byte[]? IsNonconcurrent { get; set; } public byte[]? RequestsRecovery { get; set; } } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzJobDetail { public QrtzJobDetail() { QrtzTriggers = new HashSet\u0026lt;QrtzTrigger\u0026gt;(); } public string SchedName { get; set; } = null!; public string JobName { get; set; } = null!; public string JobGroup { get; set; } = null!; public string? Description { get; set; } public string JobClassName { get; set; } = null!; public byte[] IsDurable { get; set; } = null!; public byte[] IsNonconcurrent { get; set; } = null!; public byte[] IsUpdateData { get; set; } = null!; public byte[] RequestsRecovery { get; set; } = null!; public byte[]? JobData { get; set; } public virtual ICollection\u0026lt;QrtzTrigger\u0026gt; QrtzTriggers { get; set; } } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzLock { public string SchedName { get; set; } = null!; public string LockName { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzPausedTriggerGrp { public string SchedName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzSchedulerState { public string SchedName { get; set; } = null!; public string InstanceName { get; set; } = null!; public long LastCheckinTime { get; set; } public long CheckinInterval { get; set; } } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzSimpleTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public long RepeatCount { get; set; } public long RepeatInterval { get; set; } public long TimesTriggered { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzSimpropTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string? StrProp1 { get; set; } public string? StrProp2 { get; set; } public string? StrProp3 { get; set; } public long? IntProp1 { get; set; } public long? IntProp2 { get; set; } public long? LongProp1 { get; set; } public long? LongProp2 { get; set; } public byte[]? DecProp1 { get; set; } public byte[]? DecProp2 { get; set; } public byte[]? BoolProp1 { get; set; } public byte[]? BoolProp2 { get; set; } public string? TimeZoneId { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string JobName { get; set; } = null!; public string JobGroup { get; set; } = null!; public string? Description { get; set; } public long? NextFireTime { get; set; } public long? PrevFireTime { get; set; } public long? Priority { get; set; } public string TriggerState { get; set; } = null!; public string TriggerType { get; set; } = null!; public long StartTime { get; set; } public long? EndTime { get; set; } public string? CalendarName { get; set; } public long? MisfireInstr { get; set; } public byte[]? JobData { get; set; } public virtual QrtzJobDetail QrtzJobDetail { get; set; } = null!; public virtual QrtzBlobTrigger? QrtzBlobTrigger { get; set; } public virtual QrtzCronTrigger? QrtzCronTrigger { get; set; } public virtual QrtzSimpleTrigger? QrtzSimpleTrigger { get; set; } public virtual QrtzSimpropTrigger? QrtzSimpropTrigger { get; set; } } QuartzDbContext.cs The QuartzDbContext class is defined in the BlazorAppQuartzNETScheduler.Data namespace. It extends the DbContext class and overrides the OnModelCreating method to configure the database schema.\nThe class includes properties for each of the Quartz.NET entities, such as QrtzBlobTrigger, QrtzCalendar, QrtzCronTrigger, etc. These properties represent database tables and are used to query and manipulate data related to Quartz.NET scheduling.\nusing BlazorAppQuartzNETScheduler.Models.Quartz; using Microsoft.EntityFrameworkCore; namespace BlazorAppQuartzNETScheduler.Data; public partial class QuartzDbContext : DbContext { public QuartzDbContext(DbContextOptions\u0026lt;QuartzDbContext\u0026gt; options) : base(options) { } public virtual DbSet\u0026lt;QrtzBlobTrigger\u0026gt; QrtzBlobTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzCalendar\u0026gt; QrtzCalendars { get; set; } = null!; public virtual DbSet\u0026lt;QrtzCronTrigger\u0026gt; QrtzCronTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzFiredTrigger\u0026gt; QrtzFiredTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzJobDetail\u0026gt; QrtzJobDetails { get; set; } = null!; public virtual DbSet\u0026lt;QrtzLock\u0026gt; QrtzLocks { get; set; } = null!; public virtual DbSet\u0026lt;QrtzPausedTriggerGrp\u0026gt; QrtzPausedTriggerGrps { get; set; } = null!; public virtual DbSet\u0026lt;QrtzSchedulerState\u0026gt; QrtzSchedulerStates { get; set; } = null!; public virtual DbSet\u0026lt;QrtzSimpleTrigger\u0026gt; QrtzSimpleTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzSimpropTrigger\u0026gt; QrtzSimpropTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzTrigger\u0026gt; QrtzTriggers { get; set; } = null!; } the QuartzDbContext class is defined with a constructor that accepts DbContextOptions\u0026lt;QuartzDbContext\u0026gt; as a parameter. This allows the class to be configured with the necessary options for connecting to the database.\nThe class includes properties for each of the Quartz.NET entities, such as QrtzBlobTriggers, QrtzCalendars, etc. These properties are used to query and manipulate data related to Quartz.NET scheduling.\nThe OnModelCreating method is overridden to configure the database schema using the ModelBuilder object. In this example, the configuration for the QrtzBlobTrigger entity is provided, including the table name, column mappings, and foreign key relationship.\nJobs.razor the Jobs page component demonstrates how to display a list of jobs and their trigger states, as well as how to pause or resume all jobs. With this application, users can easily schedule and manage their jobs with ease and efficiency.\n@page \u0026#34;/Jobs\u0026#34; @using BlazorAppQuartzNETScheduler.Models.Quartz @using BlazorAppQuartzNETScheduler.Data @using Microsoft.EntityFrameworkCore; @using Quartz; @inject QuartzDbContext QuartzDbContext @inject ISchedulerFactory SchedulerFactory @inject NavigationManager NavigationManager \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Index\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;() =\u0026gt; ResumeAllJobs()\u0026#34;\u0026gt;Resume All Jobs\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @onclick=\u0026#34;() =\u0026gt; PauseAllJobs()\u0026#34;\u0026gt;Pause All Jobs\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; @if (jobs == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;@nameof(QrtzJobDetail.JobName)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(QrtzJobDetail.JobGroup)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;TriggerState\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var job in jobs) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@job.JobName\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@job.JobGroup\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @foreach (var trigger in job.QrtzTriggers) { \u0026lt;p\u0026gt; TriggerState: @($\u0026#34;{trigger.TriggerState}\u0026#34;) \u0026lt;/p\u0026gt; } \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } @code { private IEnumerable\u0026lt;QrtzJobDetail\u0026gt;? jobs; private IScheduler? scheduler; protected override async Task OnInitializedAsync() { if (jobs is null) await LoadData(); scheduler = await SchedulerFactory.GetScheduler(); } private async Task LoadData() { jobs = await QuartzDbContext.QrtzJobDetails.Include(x =\u0026gt; x.QrtzTriggers).ToListAsync(); } async void ResumeAllJobs() { await scheduler.ResumeAll(); NavigationManager.NavigateTo(\u0026#34;/Jobs\u0026#34;, true); } async void PauseAllJobs() { await scheduler.PauseAll(); NavigationManager.NavigateTo(\u0026#34;/Jobs\u0026#34;, true); } } Source Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppQuartzNETScheduler\n","date":"August 18, 2023","hero":"/dotnet/2023-08-18-blazor-scheduling-with-quartz.net/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-18-blazor-scheduling-with-quartz.net/","summary":"Blazor Scheduling with Quartz.NET Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nQuartz.NET: Quartz.NET is a popular open-source job scheduling library for .NET applications. It provides a flexible and powerful way to schedule and execute jobs at specified intervals.\nScheduling: Scheduling refers to the process of defining when and how often a job or task should be executed.","tags":["Dotnet","Blazor Scheduling with Quartz.NET"],"title":"Blazor Scheduling with Quartz.NET"},{"categories":["Dotnet","Blazor Serilog Logging to Console File and Database"],"contents":" Blazor Serilog Logging to Console, File and Database Logging: Logging is the process of recording events, messages, or exceptions that occur during the execution of an application. It helps developers understand the behavior of the application, diagnose issues, and track its performance. Logging is an essential aspect of software development and plays a crucial role in maintaining and troubleshooting applications.\nSerilog: Serilog is a popular logging library for .NET applications. It provides a flexible and extensible logging framework that allows developers to capture and store log events for debugging, monitoring, and analysis purposes. Serilog supports various logging sinks, including console logging, file logging, and database logging.\nConsole Logging: Console logging is a type of logging where log messages are displayed in the console window. It is useful during development and debugging.\nFile Logging: File logging is a type of logging where log messages are written to a file. It helps in storing log data for future analysis and troubleshooting.\nSQLite Database Logging: SQLite database logging is a type of logging where log messages are stored in an SQLite database. It provides a structured way to store and query log data.\nLog.cs The provided code defines a Log model class within the BlazorAppSerilogLogging.Models namespace. The Log class has the following properties:\nnamespace BlazorAppSerilogLogging.Models; public class Log { public int id { get; set; } public DateTime Timestamp { get; set; } public string Level { get; set; } = string.Empty; public string Exception { get; set; } = string.Empty; public string RenderedMessage { get; set; } = string.Empty; public string Properties { get; set; } = string.Empty; } id: An integer property that represents the unique identifier of the log entry.\nTimestamp: A DateTime property that stores the timestamp when the log entry was created.\nLevel: A string property that indicates the log level of the entry (e.g., Information, Warning, Error).\nException: A string property that holds the exception details, if any, associated with the log entry.\nRenderedMessage: A string property that contains the formatted log message.\nProperties: A string property that stores additional properties or metadata related to the log entry.\nApplicationLoggerDbContext.cs The ApplicationLoggerDbContext class is a C# code that represents the database context for logging in a Blazor application using Serilog. It is responsible for managing the connection to the database and providing access to the Logs table.\nusing BlazorAppSerilogLogging.Models; using Microsoft.EntityFrameworkCore; namespace BlazorAppSerilogLogging.Data; public class ApplicationLoggerDbContext : DbContext { public ApplicationLoggerDbContext(DbContextOptions\u0026lt;ApplicationLoggerDbContext\u0026gt; options) : base(options) { } public DbSet\u0026lt;Log\u0026gt; Logs =\u0026gt; Set\u0026lt;Log\u0026gt;(); protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); } } The ApplicationLoggerDbContext class is defined within the BlazorAppSerilogLogging.Data namespace. It extends the DbContext class provided by Entity Framework Core.\nThe class has a constructor that takes an instance of DbContextOptions\u0026lt;ApplicationLoggerDbContext\u0026gt; as a parameter. This allows the class to configure the database connection options.\nThe class also defines a property called Logs of type DbSet\u0026lt;Log\u0026gt;. This property represents the Logs table in the database and allows you to query and manipulate log data.\nThe OnModelCreating method is overridden but left empty in this code example. This method is used to configure the database model and define relationships between entities.\nLoggerService.cs The LoggerService class is defined within the BlazorAppSerilogLogging.Data namespace. It implements several methods for logging operations and interacts with the ApplicationLoggerDbContext class.\nusing BlazorAppSerilogLogging.Models; using Microsoft.EntityFrameworkCore; namespace BlazorAppSerilogLogging.Data; public class LoggerService { private readonly ILogger\u0026lt;LoggerService\u0026gt; _logger; private readonly ApplicationLoggerDbContext _loggerDbContext; public LoggerService(ILogger\u0026lt;LoggerService\u0026gt; logger, ApplicationLoggerDbContext loggerDbContext) { _logger = logger; _loggerDbContext = loggerDbContext; } public async Task\u0026lt;IEnumerable\u0026lt;Log\u0026gt;\u0026gt; GetLogsAsync() { _logger.LogInformation($\u0026#34;Called GetLogsAsync\u0026#34;); return await _loggerDbContext.Logs.OrderByDescending(x =\u0026gt; x.Timestamp).ToListAsync(); } public async Task\u0026lt;Log?\u0026gt; GetLogAsync(int id) { _logger.LogInformation($\u0026#34;Called GetLogAsync\u0026#34;, id); return await _loggerDbContext.Logs.FirstOrDefaultAsync(x =\u0026gt; x.id == id); } public async Task\u0026lt;bool?\u0026gt; DeleteLogsAsync() { _logger.LogInformation($\u0026#34;Called DeleteLogsAsync\u0026#34;); var all = await _loggerDbContext.Logs.ToListAsync(); _loggerDbContext.Logs.RemoveRange(all); ; await _loggerDbContext.SaveChangesAsync(); _logger.LogInformation($\u0026#34;Deleted All Logs.\u0026#34;); return true; } } The class has the following members:\n_logger: An instance of the ILogger\u0026lt;LoggerService\u0026gt; interface, which is used for logging messages.\n_loggerDbContext: An instance of the ApplicationLoggerDbContext class, which represents the database context for logging.\nThe constructor of the LoggerService class takes in an ILogger\u0026lt;LoggerService\u0026gt; instance and an ApplicationLoggerDbContext instance as parameters. These dependencies are injected into the class using dependency injection.\nIndex.razor Index.razor is a Blazor component that displays logs retrieved from a logging service. It allows users to view and delete logs. The logs are fetched asynchronously and displayed in a table format.\n@page \u0026#34;/Logs\u0026#34; @using AutoMapper @using BlazorAppSerilogLogging.Data; @using BlazorAppSerilogLogging.Models; @using BlazorAppSerilogLogging.Services; @using BlazorAppSerilogLogging.ViewModels; @inject IMapper Mapper @inject NavigationManager NavigationManager @inject LoggerService LoggerService \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Index\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @onclick=\u0026#34;() =\u0026gt; DeleteAllLogs()\u0026#34;\u0026gt;Delete All Logs\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; @if (logs == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.id)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Timestamp)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Level)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Exception)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.RenderedMessage)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Properties)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var log in logs) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@log.id\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.Timestamp\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span class=\u0026#34;text-@Helpers.LogEventLevelHelper.GetBootstrapUIClass(log.Level)\u0026#34;\u0026gt; @log.Level \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.Exception\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.RenderedMessage\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.Properties\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } @code { private IEnumerable\u0026lt;LogViewModel\u0026gt;? logs; protected override async Task OnInitializedAsync() { if (logs == null) { var result = await LoggerService.GetLogsAsync(); logs = Mapper.Map\u0026lt;IEnumerable\u0026lt;Log\u0026gt;, IEnumerable\u0026lt;LogViewModel\u0026gt;\u0026gt;(result); } } private async void DeleteAllLogs() { await LoggerService.DeleteLogsAsync(); } } This code block is executed when the component is initialized. It calls the GetLogsAsync method of the LoggerService to fetch the logs asynchronously. The retrieved logs are then mapped to LogViewModel objects using AutoMapper. The logs variable is assigned the mapped logs.\nProgram.cs builder.Host.UseSerilog((ctx, lc) =\u0026gt; lc .MinimumLevel.Information() //.WriteTo.Console(new JsonFormatter(), restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.Console(restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.Seq(\u0026#34;http://localhost:5001\u0026#34;, restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.File(serilogFileLoggerFilePath, restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Verbose, rollingInterval: RollingInterval.Hour, encoding: System.Text.Encoding.UTF8) .WriteTo.SQLite(sqliteDbFilePath, tableName: \u0026#34;Logs\u0026#34;, restrictedToMinimumLevel: builder.Environment.IsDevelopment() ? Serilog.Events.LogEventLevel.Information : Serilog.Events.LogEventLevel.Warning, storeTimestampInUtc: false, batchSize: builder.Environment.IsDevelopment() ? (uint)1 : (uint)100, retentionPeriod: new TimeSpan(0, 1, 0, 0, 0), maxDatabaseSize: 10) ); Retrieves the connection string for the SQLite logger from the configuration file and modifies it to include the current directory path.\nConfigures Serilog with various log sinks, including console logging, Seq logging, file logging, and SQLite database logging. It sets the minimum log level based on the application environment.\nRegisters the ApplicationLoggerDbContext and ApplicationDbContext services in the dependency injection container. It configures the ApplicationLoggerDbContext to use the SQLite logger connection string and the ApplicationDbContext to use an in-memory database.\nWe discussed the key concepts of logging, console logging, file logging, and SQLite database logging. We also examined the code structure and provided code examples to illustrate the configuration process. By understanding this code, developers can effectively set up logging in their Blazor applications using Serilog.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppSerilogLogging\n","date":"August 15, 2023","hero":"/dotnet/2023-08-15-blazor-serilog-logging/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-15-blazor-serilog-logging/","summary":"Blazor Serilog Logging to Console, File and Database Logging: Logging is the process of recording events, messages, or exceptions that occur during the execution of an application. It helps developers understand the behavior of the application, diagnose issues, and track its performance. Logging is an essential aspect of software development and plays a crucial role in maintaining and troubleshooting applications.\nSerilog: Serilog is a popular logging library for .NET applications.","tags":["Dotnet","Blazor Serilog Logging to Console File and Database"],"title":"Blazor Serilog Logging to Console, File and Database"},{"categories":["Dotnet","Implementing Google reCAPTCHA v2"],"contents":" Blazor Implementing Google reCAPTCHA v2 How to implement Google reCAPTCHA v2 in a Blazor application using C#. Google reCAPTCHA is a free service provided by Google that helps protect websites from spam and abuse. It uses advanced risk analysis techniques to distinguish between humans and bots.\nSite Key: A unique key provided by Google when you register your website to use reCAPTCHA. It is used to identify your website when making API requests.\nSecret Key: A unique key provided by Google when you register your website to use reCAPTCHA. It is used to authenticate your server-side API requests.\nreCAPTCHA Response: The response generated by the reCAPTCHA widget when a user completes the reCAPTCHA challenge. This response is sent to the server for verification.\nVerification Response: The response received from the Google reCAPTCHA API after verifying the reCAPTCHA response. It contains information about the success of the verification and any error codes, if applicable.\nGooglereCAPTCHAv3Service.cs GooglereCAPTCHAv2Service class is responsible for verifying the reCAPTCHA response using the Google reCAPTCHA API. Let\u0026rsquo;s break down the code structure:\nnamespace BlazorAppreCAPTCHAv2.Data; public class GooglereCAPTCHAv2Service { public async Task\u0026lt;(bool Success, string[]? ErrorCodes)\u0026gt; Post(string reCAPTCHAResponse) { var url = \u0026#34;https://www.google.com/recaptcha/api/siteverify\u0026#34;; var content = new FormUrlEncodedContent(new Dictionary\u0026lt;string, string\u0026gt; { {\u0026#34;secret\u0026#34;, GooglereCAPTCHAv2Settings.SecretKey}, {\u0026#34;response\u0026#34;, reCAPTCHAResponse} }); GooglereCAPTCHAv2Response? verificationResponse; using (HttpClient httpClient = new HttpClient()) { try { var response = await httpClient.PostAsync(url, content); response.EnsureSuccessStatusCode(); verificationResponse = await response.Content.ReadFromJsonAsync\u0026lt;GooglereCAPTCHAv2Response\u0026gt;(); } catch (Exception) { throw; } } if (verificationResponse is null || !verificationResponse.Success) return (false, verificationResponse?.ErrorCodes.Select(err =\u0026gt; err.Replace(\u0026#39;-\u0026#39;, \u0026#39; \u0026#39;)).ToArray()); return (Success: true, ErrorCodes: null); } } The Post method takes the reCAPTCHA response as input and returns a tuple containing a boolean value indicating the success of the verification and an array of error codes, if any.\nThe url variable stores the URL of the Google reCAPTCHA API endpoint.\nThe content variable is created using the FormUrlEncodedContent class, which represents key-value pairs encoded in the application/x-www-form-urlencoded format. It contains the secret key (your server-side secret key) and the response key (the reCAPTCHA response).\nThe verificationResponse variable is used to store the response received from the Google reCAPTCHA API after verifying the reCAPTCHA response.\nThe HttpClient class is used to send an HTTP POST request to the Google reCAPTCHA API endpoint. The PostAsync method is called with the URL and content as parameters.\nThe response.EnsureSuccessStatusCode() method ensures that the HTTP response is successful (status code 200).\nThe response.Content.ReadFromJsonAsync\u0026lt;GooglereCAPTCHAv2Response\u0026gt;() method reads the response content and deserializes it into an instance of the GooglereCAPTCHAv2Response class.\nIf the verification response is null or the verification was not successful, the method returns a tuple with the success value set to false and the error codes extracted from the verification response.\nIf the verification was successful, the method returns a tuple with the success value set to true and the error codes set to null.\nGooglereCAPTCHAv2Settings.cs To implement Google reCAPTCHA v2 in Blazor, we need to create a class called GooglereCAPTCHAv2Settings in the BlazorAppreCAPTCHAv2.Data namespace. This class will contain the site key and secret key provided by Google reCAPTCHA.\nnamespace BlazorAppreCAPTCHAv2.Data; public class GooglereCAPTCHAv2Settings { public const string SiteKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv2_SITEKEY\u0026#34;; public const string SecretKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv2_SECRETKEY\u0026#34;; } GooglereCAPTCHAv2Response.cs GooglereCAPTCHAv2Response.cs file represents a C# class that models the response received from the Google reCAPTCHA API. Let\u0026rsquo;s break down the code structure:\nusing System.Text.Json.Serialization; namespace BlazorAppreCAPTCHAv2.Data; public class GooglereCAPTCHAv2Response { public bool Success { get; set; } // timestamp of the challenge load (ISO format yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ssZZ) [JsonPropertyName(\u0026#34;challenge_ts\u0026#34;)] public DateTimeOffset ChallengeTimestamp { get; set; } // the hostname of the site where the reCAPTCHA was solved public string Hostname { get; set; } [JsonPropertyName(\u0026#34;error-codes\u0026#34;)] public string[] ErrorCodes { get; set; } = new string[0]; } The GooglereCAPTCHAv2Response class has the following properties:\nSuccess: A boolean property indicating whether the reCAPTCHA challenge was successfully completed by the user.\nChallengeTimestamp: A DateTimeOffset property representing the timestamp of the challenge load in ISO format.\nHostname: A string property representing the hostname of the site where the reCAPTCHA was solved.\nErrorCodes: An array of strings representing any error codes returned by the reCAPTCHA API. This property is initialized with an empty array by default.\nscript.js a JavaScript module that provides functions for initializing and rendering the reCAPTCHA widget, as well as getting the user\u0026rsquo;s response.\nvar My; (function (My) { var reCAPTCHA; (function (reCAPTCHA) { let scriptLoaded = null; function waitScriptLoaded(resolve) { if (typeof (grecaptcha) !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; typeof (grecaptcha.render) !== \u0026#39;undefined\u0026#39;) resolve(); else setTimeout(() =\u0026gt; waitScriptLoaded(resolve), 100); } function init() { const scripts = Array.from(document.getElementsByTagName(\u0026#39;script\u0026#39;)); if (!scripts.some(s =\u0026gt; (s.src || \u0026#39;\u0026#39;).startsWith(\u0026#39;https://www.google.com/recaptcha/api.js\u0026#39;))) { const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://www.google.com/recaptcha/api.js?render=explicit\u0026#39;; script.async = true; script.defer = true; document.head.appendChild(script); } if (scriptLoaded === null) scriptLoaded = new Promise(waitScriptLoaded); return scriptLoaded; } reCAPTCHA.init = init; function render(dotNetObj, selector, siteKey) { return grecaptcha.render(selector, { \u0026#39;sitekey\u0026#39;: siteKey, \u0026#39;callback\u0026#39;: (response) =\u0026gt; { dotNetObj.invokeMethodAsync(\u0026#39;CallbackOnSuccess\u0026#39;, response); }, \u0026#39;expired-callback\u0026#39;: () =\u0026gt; { dotNetObj.invokeMethodAsync(\u0026#39;CallbackOnExpired\u0026#39;); } }); } reCAPTCHA.render = render; function getResponse(widgetId) { return grecaptcha.getResponse(widgetId); } reCAPTCHA.getResponse = getResponse; })(reCAPTCHA = My.reCAPTCHA || (My.reCAPTCHA = {})); })(My || (My = {})); waitScriptLoaded: This function checks if the reCAPTCHA script has been loaded. If not, it waits for it to be loaded before resolving the promise.\ninit: This function initializes the reCAPTCHA script by adding it to the HTML document if it hasn\u0026rsquo;t been added already. It returns a promise that resolves when the script has been loaded.\nrender: This function renders the reCAPTCHA widget using the provided dotNetObj, selector, and siteKey. It also handles the callback functions for success and expiration.\ngetResponse: This function gets the user\u0026rsquo;s response from the reCAPTCHA widget using the provided widgetId.\nReCAPTCHAv2Component.razor It is responsible for rendering the reCAPTCHA widget and handling the user\u0026rsquo;s response. Let\u0026rsquo;s break down the code structure:\n@using System.ComponentModel @inject IJSRuntime JS \u0026lt;span\u0026gt;@loadMessage\u0026lt;/span\u0026gt; \u0026lt;div id=\u0026#34;@UniqueId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; @code { [Parameter] public string SiteKey { get; set; } [Parameter] public EventCallback\u0026lt;string\u0026gt; OnSuccess { get; set; } [Parameter] public EventCallback OnExpired { get; set; } private bool isLoadedScript = false; private string loadMessage = \u0026#34;Loading...\u0026#34;; private string UniqueId = Guid.NewGuid().ToString(); private int WidgetId; protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { try { var timeoutTimeSpan = new TimeSpan(0, 0, 5); // 5 secs var ress = await JS.InvokeAsync\u0026lt;object\u0026gt;(\u0026#34;My.reCAPTCHA.init\u0026#34;, timeout: timeoutTimeSpan); this.WidgetId = await JS.InvokeAsync\u0026lt;int\u0026gt;(\u0026#34;My.reCAPTCHA.render\u0026#34;, timeout: timeoutTimeSpan, DotNetObjectReference.Create(this), UniqueId, SiteKey); isLoadedScript = true; loadMessage = \u0026#34;\u0026#34;; } catch (Exception ex) { loadMessage = \u0026#34;Error on Load Captcha.\u0026#34;; isLoadedScript = false; } StateHasChanged(); } } [JSInvokable, EditorBrowsable(EditorBrowsableState.Never)] public void CallbackOnSuccess(string response) { if (OnSuccess.HasDelegate) { OnSuccess.InvokeAsync(response); } } [JSInvokable, EditorBrowsable(EditorBrowsableState.Never)] public void CallbackOnExpired() { if (OnExpired.HasDelegate) { OnExpired.InvokeAsync(null); } } public ValueTask\u0026lt;string\u0026gt; GetResponseAsync() { return JS.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;My.reCAPTCHA.getResponse\u0026#34;, WidgetId); } } @using System.ComponentModel and @inject IJSRuntime JS: These directives import the necessary namespaces and inject the JavaScript runtime service into the component.\n@code block: This block contains the C# code for the component.\nSiteKey property: This property is used to pass the site key value to the component. The site key is required to initialize the reCAPTCHA widget.\nOnSuccess and OnExpired event callbacks: These event callbacks are used to handle the success and expiration events of the reCAPTCHA widget.\nUniqueId field: This field stores a unique identifier generated using the Guid.NewGuid().ToString() method. It is used to identify the reCAPTCHA widget on the web page.\nOnAfterRenderAsync method: This method is called after the component has been rendered on the web page. It initializes the reCAPTCHA widget by invoking JavaScript functions and sets the isLoadedScript and loadMessage variables based on the success or failure of the initialization.\nCallbackOnSuccess and CallbackOnExpired methods: These methods are invoked by the reCAPTCHA widget\u0026rsquo;s JavaScript API when the user successfully completes the challenge or when the challenge expires. They invoke the respective event callbacks (OnSuccess and OnExpired) if they are subscribed to.\nGetResponseAsync method: This method is used to retrieve the user\u0026rsquo;s response from the reCAPTCHA widget. It invokes a JavaScript function to get the response and returns it as a ValueTask\u0026lt;string\u0026gt;.\nReCAPTCHAv2.razor @page \u0026#34;/ReCAPTCHAv2\u0026#34; @using BlazorAppreCAPTCHAv2.Data; @using BlazorAppreCAPTCHAv2.ViewModels; @using BlazorAppreCAPTCHAv2.Components; @inject IJSRuntime JSRuntime @inject GooglereCAPTCHAv2Service GooglereCAPTCHAv2Service \u0026lt;PageTitle\u0026gt;reCAPTCHAv2\u0026lt;/PageTitle\u0026gt; \u0026lt;EditForm Model=\u0026#34;@blogPostViewModel\u0026#34; OnValidSubmit=\u0026#34;HandleValidSubmit\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Title)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Title)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Content)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Content\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Content)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-3\u0026#34;\u0026gt; \u0026lt;ReCAPTCHAv2Component @ref=\u0026#34;reCAPTCHAv2Component\u0026#34; SiteKey=\u0026#34;@GooglereCAPTCHAv2Settings.SiteKey\u0026#34; OnSuccess=\u0026#34;OnSuccess\u0026#34; OnExpired=\u0026#34;OnExpired\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Send\u0026#34; disabled=\u0026#34;@DisablePostButton\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label text-primary\u0026#34;\u0026gt;\u0026lt;strong\u0026gt; Result: @resultMessage \u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; @code { BlogPostViewModel? blogPostViewModel; private ReCAPTCHAv2Component? reCAPTCHAv2Component; private bool ValidReCAPTCHA = false; private bool DisablePostButton =\u0026gt; !ValidReCAPTCHA; private void OnSuccess() =\u0026gt; ValidReCAPTCHA = true; private void OnExpired() =\u0026gt; ValidReCAPTCHA = false; private string resultMessage = \u0026#34;\u0026#34;; protected override void OnInitialized() { blogPostViewModel = new(); } private async Task HandleValidSubmit() { // verify ReCAPTCHAv2 bool verifiedResult = await CheckReCAPTCHA(); if (!verifiedResult) return; // verified actions resultMessage = \u0026#34;Success...\u0026#34;; StateHasChanged(); } private async Task\u0026lt;bool\u0026gt; CheckReCAPTCHA() { bool serverVerified = false; if (ValidReCAPTCHA) { var response = await reCAPTCHAv2Component.GetResponseAsync(); try { StateHasChanged(); var result = await GooglereCAPTCHAv2Service.Post(response); if (result.Success) { serverVerified = true; } else { await JSRuntime.InvokeAsync\u0026lt;object\u0026gt;(\u0026#34;alert\u0026#34;, string.Join(\u0026#34;, \u0026#34;, result.ErrorCodes)); serverVerified = false; StateHasChanged(); } } catch (HttpRequestException e) { await JSRuntime.InvokeAsync\u0026lt;object\u0026gt;(\u0026#34;alert\u0026#34;, e.Message); serverVerified = false; StateHasChanged(); } } return serverVerified; } } The OnSuccess method is called when the user successfully completes the reCAPTCHA challenge. It sets the ValidReCAPTCHA flag to true.\nThe OnExpired method is called when the reCAPTCHA challenge expires. It sets the ValidReCAPTCHA flag to false.\nThe HandleValidSubmit method is called when the form is submitted and passes the validation. It first verifies the reCAPTCHA response by calling the CheckReCAPTCHA method. If the verification fails, the method returns. Otherwise, it performs the desired actions and updates the resultMessage variable.\nThe CheckReCAPTCHA method checks if the reCAPTCHA response is valid. If it is, it retrieves the response token from the reCAPTCHA component and sends it to the Google reCAPTCHA service for verification. If the verification is successful, the serverVerified flag is set to true. Otherwise, an alert is displayed with the error codes returned by the service.\nWe have learned how to implement Google reCAPTCHA v2 in a Blazor application. By following the code examples and understanding the key concepts, you can enhance the security of your forms and protect your website from spam and abuse. Remember to obtain a site key from Google reCAPTCHA and replace the placeholder in the code with your actual site key. Happy coding!\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppreCAPTCHAv2\n","date":"August 13, 2023","hero":"/dotnet/2023-08-13-blazor-implementing-google-recaptcha-v2/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-13-blazor-implementing-google-recaptcha-v2/","summary":"Blazor Implementing Google reCAPTCHA v2 How to implement Google reCAPTCHA v2 in a Blazor application using C#. Google reCAPTCHA is a free service provided by Google that helps protect websites from spam and abuse. It uses advanced risk analysis techniques to distinguish between humans and bots.\nSite Key: A unique key provided by Google when you register your website to use reCAPTCHA. It is used to identify your website when making API requests.","tags":["Dotnet","Implementing Google reCAPTCHA v2"],"title":"Blazor Implementing Google reCAPTCHA v2"},{"categories":["Dotnet","Implementing Google reCAPTCHA v3"],"contents":" Blazor Implementing Google reCAPTCHA v3 Google reCAPTCHA v3 in a Blazor application. Google reCAPTCHA is a service that helps protect websites from spam and abuse by verifying that the user is a human and not a bot. reCAPTCHA v3 is the latest version of this service and provides a seamless user experience without requiring any user interaction.\nSite Key: A unique identifier for your website, obtained from the reCAPTCHA admin console. This key is used to identify your website when making API requests to Google\u0026rsquo;s reCAPTCHA service.\nSecret Key: A secret key associated with your site key, also obtained from the reCAPTCHA admin console. This key is used to authenticate your API requests to Google\u0026rsquo;s reCAPTCHA service.\nToken: A token generated by the reCAPTCHA JavaScript API, which is sent to the server for verification. This token contains information about the user\u0026rsquo;s interaction with your website and is used to determine the likelihood of the user being a bot.\nScore: reCAPTCHA v3 returns a score between 0.0 and 1.0, indicating the likelihood that the user is a bot. A score closer to 1.0 indicates a higher likelihood of being a human.\nGooglereCAPTCHAv3Service.cs GooglereCAPTCHAv3Service class demonstrates how to verify a reCAPTCHA token using the Google reCAPTCHA v3 API. Let\u0026rsquo;s break down the code structure:\nNamespace: The code is placed inside the BlazorAppreCAPTCHAv3.Data namespace.\nClass: The GooglereCAPTCHAv3Service class contains a single method Verify that takes a reCAPTCHA token as input and returns a GooglereCAPTCHAv3Response object.\nHttpClient: The code uses the HttpClient class to send an HTTP POST request to the reCAPTCHA API endpoint.\nFormUrlEncodedContent: The reCAPTCHA API requires the secret and response parameters to be sent as form data. The code creates a FormUrlEncodedContent object and adds these parameters to it.\nPostAsync: The code sends the HTTP POST request to the reCAPTCHA API endpoint with the form data.\nReadAsStringAsync: The code reads the response from the API as a string.\nJsonSerializer: The code deserializes the JSON response string into a GooglereCAPTCHAv3Response object using the JsonSerializer class.\nException Handling: The code catches any exceptions that occur during the API request and rethrows them.\nReturn Statement: The code returns the GooglereCAPTCHAv3Response object.\nusing System.Text.Json; namespace BlazorAppreCAPTCHAv3.Data; public class GooglereCAPTCHAv3Service { public virtual async Task\u0026lt;GooglereCAPTCHAv3Response?\u0026gt; Verify(string token) { GooglereCAPTCHAv3Response? reCaptchaResponse; using (var httpClient = new HttpClient()) { var content = new FormUrlEncodedContent(new[] { new KeyValuePair\u0026lt;string, string\u0026gt;(\u0026#34;secret\u0026#34;, GooglereCAPTCHAv3Settings.SecretKey), new KeyValuePair\u0026lt;string, string\u0026gt;(\u0026#34;response\u0026#34;, token) }); try { var response = await httpClient.PostAsync($\u0026#34;https://www.google.com/recaptcha/api/siteverify\u0026#34;, content); var jsonString = await response.Content.ReadAsStringAsync(); reCaptchaResponse = JsonSerializer.Deserialize\u0026lt;GooglereCAPTCHAv3Response\u0026gt;(jsonString); } catch (Exception) { throw; } return reCaptchaResponse; } } } GooglereCAPTCHAv3Settings.cs To implement Google reCAPTCHA v3 in a Blazor application, we need to create a class that holds the reCAPTCHA settings. In this example, we have a class called GooglereCAPTCHAv3Settings in the BlazorAppreCAPTCHAv3.Data namespace.\nIn the GooglereCAPTCHAv3Settings class, we have two constant fields: SiteKey and SecretKey. These fields hold the site key and secret key provided by Google reCAPTCHA. You need to replace the placeholders with your actual site key and secret key.\nnamespace BlazorAppreCAPTCHAv3.Data; public class GooglereCAPTCHAv3Settings { public const string SiteKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv3_SITEKEY\u0026#34;; public const string SecretKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv3_SECRETKEY\u0026#34;; } GooglereCAPTCHAv3Response.cs A model class GooglereCAPTCHAv3Response that represents the response received from the reCAPTCHA API. It has properties like success, score, action, challenge_ts, and hostname. These properties will be populated with the relevant data returned by the reCAPTCHA service.\nnamespace BlazorAppreCAPTCHAv3.Data; public class GooglereCAPTCHAv3Response { public bool success { get; set; } public double score { get; set; } public string action { get; set; } public DateTime challenge_ts { get; set; } public string hostname { get; set; } } _Layout.cshtml \u0026lt;script src=@($\u0026#34;https://www.google.com/recaptcha/api.js?render={BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; runCaptcha = function (actionName) { return new Promise((resolve, reject) =\u0026gt; { grecaptcha.ready(function () { grecaptcha.execute(\u0026#39;@($\u0026#34;{BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026#39;, { action: \u0026#39;submit\u0026#39; }).then(function (token) { resolve(token); }); }); }); }; \u0026lt;/script\u0026gt; Let\u0026rsquo;s break down the code and understand its functionality:\n\u0026lt;script src=@($\u0026#34;https://www.google.com/recaptcha/api.js?render={BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026gt;\u0026lt;/script\u0026gt; This line of code includes the reCAPTCHA API script from Google\u0026rsquo;s servers. It dynamically generates the URL based on the SiteKey value provided in the GooglereCAPTCHAv3Settings class.\n\u0026lt;script\u0026gt; runCaptcha = function (actionName) { return new Promise((resolve, reject) =\u0026gt; { grecaptcha.ready(function () { grecaptcha.execute(\u0026#39;@($\u0026#34;{BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026#39;, { action: \u0026#39;submit\u0026#39; }).then(function (token) { resolve(token); }); }); }); }; \u0026lt;/script\u0026gt; This script defines a function called runCaptcha that can be used to execute the reCAPTCHA verification process. It takes an actionName parameter, which represents the specific action you want to protect. Inside the function, it uses the grecaptcha object provided by the reCAPTCHA API to execute the verification process. Once the verification is successful, it resolves the promise with the generated token.\nReCAPTCHAv3.razor @page \u0026#34;/ReCAPTCHAv3\u0026#34; @using BlazorAppreCAPTCHAv3.Data; @using BlazorAppreCAPTCHAv3.ViewModels; @inject IJSRuntime JSRuntime @inject GooglereCAPTCHAv3Service GooglereCAPTCHAv3Service \u0026lt;PageTitle\u0026gt;reCAPTCHAv3\u0026lt;/PageTitle\u0026gt; \u0026lt;EditForm Model=\u0026#34;@blogPostViewModel\u0026#34; OnValidSubmit=\u0026#34;HandleValidSubmit\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Title)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Title)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Content)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Content\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Content)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;submitBtn\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; @if (googlereCAPTCHAv3Response != null) { \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;Result\u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;Status\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; value=\u0026#34;@googlereCAPTCHAv3Response.success.ToString()\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;Score\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; value=\u0026#34;@googlereCAPTCHAv3Response.score\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;reCAPTCHA token\u0026lt;/label\u0026gt; \u0026lt;textarea rows=\u0026#34;4\u0026#34; cols=\u0026#34;50\u0026#34; readonly class=\u0026#34;form-control\u0026#34;\u0026gt; @token \u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; @code { BlogPostViewModel blogPostViewModel = new BlogPostViewModel(); string token = \u0026#34;\u0026#34;; GooglereCAPTCHAv3Response? googlereCAPTCHAv3Response; private async Task HandleValidSubmit() { googlereCAPTCHAv3Response = await GooglereCAPTCHAv3Service.Verify(token); StateHasChanged(); } protected override async void OnAfterRender(bool firstRender) { if (firstRender) { token = await JSRuntime.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;runCaptcha\u0026#34;); StateHasChanged(); } } } In the ReCAPTCHAv3.razor page:\nHandleValidSubmit(): This method is called when the form is submitted and the validation is successful. It calls the Verify() method of the GooglereCAPTCHAv3Service to verify the reCAPTCHA token and assigns the response to the googlereCAPTCHAv3Response object. The StateHasChanged() method is called to update the UI.\nOnAfterRender(): This method is called after the component has been rendered. It checks if it is the first render and then calls the runCaptcha JavaScript function using the JSRuntime service to generate the reCAPTCHA token. The StateHasChanged() method is called to update the UI.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppreCAPTCHAv3\n","date":"August 11, 2023","hero":"/dotnet/2023-08-11-blazor-implementing-google-recaptcha-v3/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-11-blazor-implementing-google-recaptcha-v3/","summary":"Blazor Implementing Google reCAPTCHA v3 Google reCAPTCHA v3 in a Blazor application. Google reCAPTCHA is a service that helps protect websites from spam and abuse by verifying that the user is a human and not a bot. reCAPTCHA v3 is the latest version of this service and provides a seamless user experience without requiring any user interaction.\nSite Key: A unique identifier for your website, obtained from the reCAPTCHA admin console.","tags":["Dotnet","Implementing Google reCAPTCHA v3"],"title":"Blazor Implementing Google reCAPTCHA v3"},{"categories":["Dotnet","Blazor Radzen Globalization and Localization"],"contents":" Blazor Radzen Globalization and Localization The concept of globalization and localization in Blazor, a popular framework for building web applications. We will specifically focus on how to implement globalization and localization using Radzen, a set of UI components for Blazor. We will explore the code provided and understand its functionality.\nGlobalization: Globalization refers to the process of designing and developing applications that can be adapted to various cultures and languages. It involves making your application culturally aware and providing support for different languages, date formats, number formats, and more.\nLocalization: Localization is the process of adapting an application to a specific culture or locale. It involves translating the user interface, date formats, number formats, and other elements of the application to match the preferences of a particular culture or language.\nCulture: A culture represents a specific set of conventions, such as language, date format, and number format, associated with a particular region or group of people.\nCulturePicker.razor The CulturePicker component is a partial class that extends the ComponentBase class provided by Blazor. It contains several injected services and properties for language, currency, and dropdown data. The OnInitialized method is overridden to set the initial values for language and currency based on the current culture settings. The ChangeCulture method is called when the user selects a new language or currency, and it updates the culture settings and redirects the user to the appropriate page.\n@inject Microsoft.Extensions.Localization.IStringLocalizer\u0026lt;CulturePicker\u0026gt; L @*\u0026lt;RadzenDropDown @bind-Value=\u0026#34;@culture\u0026#34; TValue=\u0026#34;string\u0026#34; Data=\u0026#34;@(cultureDrowDownData)\u0026#34; TextProperty=\u0026#34;Text\u0026#34; ValueProperty=\u0026#34;Value\u0026#34; Change=\u0026#34;@ChangeCulture\u0026#34; /\u0026gt; *@ \u0026lt;RadzenText Text=\u0026#34;Language\u0026#34; class=\u0026#34;rz-my-1 rz-mx-2\u0026#34; /\u0026gt; \u0026lt;RadzenDropDown @bind-Value=\u0026#34;@language\u0026#34; TValue=\u0026#34;string\u0026#34; Data=\u0026#34;@(languageDrowDownData)\u0026#34; TextProperty=\u0026#34;Text\u0026#34; ValueProperty=\u0026#34;Value\u0026#34; Change=\u0026#34;@ChangeCulture\u0026#34; /\u0026gt; \u0026lt;RadzenText Text=\u0026#34;Currency\u0026#34; class=\u0026#34;rz-my-1 rz-ml-4 rz-mr-2\u0026#34; /\u0026gt; \u0026lt;RadzenDropDown @bind-Value=\u0026#34;@currency\u0026#34; TValue=\u0026#34;string\u0026#34; Data=\u0026#34;@(currencyDrowDownData)\u0026#34; TextProperty=\u0026#34;Text\u0026#34; ValueProperty=\u0026#34;Value\u0026#34; Change=\u0026#34;@ChangeCulture\u0026#34; class=\u0026#34;rz-mr-2\u0026#34; /\u0026gt; The code begins with an @inject directive, which is used to inject an instance of the IStringLocalizer interface into the CulturePicker component. The IStringLocalizer interface provides a way to retrieve localized strings for the current culture.\nNext, we have a commented out code block that represents a RadzenDropDown component. This component is used to display a dropdown list of cultures, allowing the user to select their preferred language. The @bind-Value directive is used to bind the selected value to the culture variable. The TValue parameter specifies the type of the selected value, which in this case is a string. The Data parameter provides the data source for the dropdown list, and the TextProperty and ValueProperty parameters specify the properties of the data source that should be used for displaying the text and storing the selected value, respectively. The Change parameter specifies the event handler that should be called when the selected value changes.\nAfter the commented out code block, we have two RadzenText components. These components are used to display labels for the dropdown lists. The Text parameter specifies the text to be displayed, and the class parameter is used to apply CSS classes for styling.\nFinally, we have two more RadzenDropDown components. These components are similar to the commented out code block, but they are used to display dropdown lists for selecting the preferred language and currency. The @bind-Value directive is used to bind the selected values to the language and currency variables, respectively. The class parameter is used to apply CSS classes for styling.\nCulturePicker.razor.cs Initializing language and currency:\nprotected override void OnInitialized() { language = CultureInfo.CurrentCulture.TwoLetterISOLanguageName; currency = CultureInfo.CurrentCulture.Name.ReplaceFirst(quot;{CultureInfo.CurrentCulture.TwoLetterISOLanguageName}-\u0026#34;, \u0026#34;\u0026#34;); } Changing the culture:\nprotected void ChangeCulture() { var redirect = new Uri(NavigationManager.Uri).GetComponents(UriComponents.PathAndQuery | UriComponents.Fragment, UriFormat.UriEscaped); string culture = quot;{language}-{currency}\u0026#34;; var query = quot;?culture={Uri.EscapeDataString(culture)}\u0026amp;redirectUri={redirect}\u0026#34;; NavigationManager.NavigateTo(\u0026#34;Culture/SetCulture\u0026#34; + query, forceLoad: true); } CultureController.cs The CultureController.cs file is a C# code file that contains a controller class responsible for handling culture-related operations in a Blazor application. It provides a method called SetCulture that allows the user to set the culture of the application and redirect to a specified URI.\nThe CultureController.cs file is a partial class that extends the Controller class provided by the Microsoft.AspNetCore.Mvc namespace. It is decorated with the [Route] attribute, which specifies the route prefix for the controller\u0026rsquo;s actions.\nThe controller contains a single action method called SetCulture, which takes two parameters: culture and redirectUri. The culture parameter represents the desired culture to be set, and the redirectUri parameter represents the URI to which the user should be redirected after setting the culture.\nusing Microsoft.AspNetCore.Localization; using Microsoft.AspNetCore.Mvc; namespace BlazorAppRadzenGlobalizationLocalization.Controllers { [Route(\u0026#34;Culture/[action]\u0026#34;)] public partial class CultureController : Controller { public IActionResult SetCulture(string culture, string redirectUri) { if (culture != null) { Response.Cookies.Append( CookieRequestCultureProvider.DefaultCookieName, CookieRequestCultureProvider.MakeCookieValue(new RequestCulture(culture))); } return LocalRedirect(redirectUri); } } } In this code, we import the necessary namespaces Microsoft.AspNetCore.Localization and Microsoft.AspNetCore.Mvc to access the required classes and methods.\nThe CultureController class is defined as a partial class and inherits from the Controller class provided by the Microsoft.AspNetCore.Mvc namespace.\nThe [Route] attribute is used to specify the route prefix for the controller\u0026rsquo;s actions. In this case, the route prefix is set to \u0026ldquo;Culture/[action]\u0026rdquo;. This means that the SetCulture action can be accessed using the URL \u0026quot;/Culture/SetCulture\u0026quot;.\nThe SetCulture action method takes two parameters: culture and redirectUri. The culture parameter represents the desired culture to be set, and the redirectUri parameter represents the URI to which the user should be redirected after setting the culture.\nInside the SetCulture method, there is a conditional statement that checks if the culture parameter is not null. If it is not null, it means that a valid culture value has been provided.\nThe Response.Cookies.Append method is then called to add a cookie to the response. This cookie is used to store the selected culture value. The CookieRequestCultureProvider.DefaultCookieName property is used to specify the name of the cookie, and the CookieRequestCultureProvider.MakeCookieValue method is used to convert the culture value into a string representation that can be stored in the cookie.\nFinally, the LocalRedirect method is called to redirect the user to the specified redirectUri after setting the culture.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenGlobalizationLocalization\n","date":"August 9, 2023","hero":"/dotnet/2023-08-09-blazor-radzen-globalization-and-localization/blazor_radzen_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-09-blazor-radzen-globalization-and-localization/","summary":"Blazor Radzen Globalization and Localization The concept of globalization and localization in Blazor, a popular framework for building web applications. We will specifically focus on how to implement globalization and localization using Radzen, a set of UI components for Blazor. We will explore the code provided and understand its functionality.\nGlobalization: Globalization refers to the process of designing and developing applications that can be adapted to various cultures and languages.","tags":["Dotnet","Blazor Radzen Globalization and Localization"],"title":"Blazor Radzen Globalization and Localization"},{"categories":["Dotnet","Blazor Using NPM Packages"],"contents":" Blazor Using NPM Packages Create a new folder named npm_packages in your Blazor project.\nOpen the npm_packages folder directory via command prompt and run the following command to initialize NPM in the application:\nnpm init -y This will create a new package.json file in the npm_packages directory.\nInstall the webpack and webpack-cli packages as development dependencies by running the following command: npm install webpack webpack-cli --save-dev Modify the scripts section of the package.json file to add the following build script: \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack ./src/index.js --output-path ../wwwroot/js --output-filename index.bundle.js\u0026#34; }, This build script will use webpack to bundle the JavaScript files in the src folder into a single file called index.bundle.js in the wwwroot/js folder.\nInstall the NPM package that you want to use in your Blazor application. For example, to install the chart.js package, run the following command: npm i chart.js Build your Blazor application by running the following command: npm run build This will run the webpack build script that you defined in the package.json file.\nModify the csproj file to add a pre-build step that will run the npm build script. This will ensure that the NPM packages are installed and bundled before your Blazor application is built. To do this, add the following code to the PreBuild target in the csproj file: \u0026lt;Target Name=\u0026#34;PreBuild\u0026#34; BeforeTargets=\u0026#34;PreBuildEvent\u0026#34;\u0026gt; \u0026lt;Exec Command=\u0026#34;npm install\u0026#34; WorkingDirectory=\u0026#34;npm_packages\u0026#34; /\u0026gt; \u0026lt;Exec Command=\u0026#34;npm run build\u0026#34; WorkingDirectory=\u0026#34;npm_packages\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt; Edit the _Layout.cshtml file and add the following code to the head section: \u0026lt;script src=\u0026#34;~/js/index.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; This will load the index.bundle.js file that was created by the webpack build script.\nRun your Blazor application and the NPM package that you installed should be available to use in your Blazor code. Source Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppNPMPackages\n","date":"August 7, 2023","hero":"/dotnet/2023-08-07-blazor-using-npm-packages/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-07-blazor-using-npm-packages/","summary":"Blazor Using NPM Packages Create a new folder named npm_packages in your Blazor project.\nOpen the npm_packages folder directory via command prompt and run the following command to initialize NPM in the application:\nnpm init -y This will create a new package.json file in the npm_packages directory.\nInstall the webpack and webpack-cli packages as development dependencies by running the following command: npm install webpack webpack-cli --save-dev Modify the scripts section of the package.","tags":["Dotnet","Blazor Using NPM Packages"],"title":"Blazor Using NPM Packages"},{"categories":["Dotnet","Blazor Generic Components"],"contents":" Blazor Generic Components We will explore a Blazor generic component that can be used for performing CRUD (Create, Read, Update, Delete) operations on a list of items. This component is designed to provide a reusable and efficient solution for displaying and managing data in a Blazor application.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET, providing a seamless development experience.\nGeneric Components: Generic components in Blazor allow us to create reusable UI components that can work with different types of data. By using generics, we can create components that are flexible and adaptable to various scenarios.\nTModel: The TModel type parameter represents the model class that the component will work with. It must inherit from the BaseModel class.\nTViewModel: The TViewModel type parameter represents the view model class that the component will use to display the data. It must inherit from the BaseViewModel class and have a parameterless constructor.\nIService: The IService\u0026lt;TModel\u0026gt; interface represents a service that provides CRUD (Create, Read, Update, Delete) operations for the TModel class. It is injected into the component to retrieve the data.\nIMapper: The IMapper interface is used for object-to-object mapping. It is injected into the component to map the TModel objects to TViewModel objects.\nNavigationManager: The NavigationManager class provides methods for navigating within a Blazor application. It is injected into the component to handle navigation to different pages.\nLet\u0026rsquo;s break down the code structure:\nNamespace and Using Statements: The code starts with the declaration of the namespace and the necessary using statements.\nType Parameters: The component uses two type parameters, TModel and TViewModel, which represent the model and view model types, respectively. These parameters allow the component to work with different types of data.\nConditional Rendering: The code uses conditional rendering to display a loading message if the listViewModel is null. Otherwise, it renders a table to display the list of items.\nTable Structure: The table structure is defined using HTML markup. The table headers are dynamically generated based on the properties of the TViewModel type. The nameof function is used to get the name of the Id property from the BaseViewModel class, and the GetProperties method is used to iterate over the properties of the TViewModel type.\nData Binding: The table rows are generated using a foreach loop that iterates over the listViewModel collection. The GetProperty and GetValue methods are used to retrieve the values of the properties dynamically. The ToString method is called to convert the values to strings.\nCRUD Links: Each table row includes links for performing CRUD operations on the corresponding item. The NavigateLinkItemDetails, NavigateLinkItemEdit, and NavigateLinkItemDelete properties are used to generate the URLs for the respective operations. The Replace method is used to replace the placeholder {{{id}}} with the actual item ID.\nList Posts (List.razor, List.razor.cs) Let\u0026rsquo;s take a closer look at the code provided in the List\u0026lt;TModel, TViewModel\u0026gt; component:\npublic partial class List\u0026lt;TModel, TViewModel\u0026gt; : ComponentBase where TModel : BaseModel where TViewModel : BaseViewModel, new() { [Parameter, EditorRequired] public string? NavigateLinkItemDetails { get; set; } [Parameter, EditorRequired] public string? NavigateLinkItemEdit { get; set; } [Parameter, EditorRequired] public string? NavigateLinkItemDelete { get; set; } [Inject] private IService\u0026lt;TModel\u0026gt;? _service { get; set; } [Inject] private IMapper? Mapper { get; set; } [Inject] private NavigationManager? NavigationManager { get; set; } private IEnumerable\u0026lt;TViewModel\u0026gt;? listViewModel; protected override async Task OnInitializedAsync() { if (_service == null || Mapper == null) return; var model = await _service.GetAllAsync(); if (model == null) return; listViewModel = Mapper.Map\u0026lt;IEnumerable\u0026lt;TModel\u0026gt;, IEnumerable\u0026lt;TViewModel\u0026gt;\u0026gt;(model); } } In this code, we define the List\u0026lt;TModel, TViewModel\u0026gt; component as a partial class that inherits from ComponentBase. The component has the following members:\nParameters: The component has three parameters: NavigateLinkItemDetails, NavigateLinkItemEdit, and NavigateLinkItemDelete. These parameters are used to specify the navigation links for item details, item edit, and item delete actions.\nInjected Services: The component injects three services: IService\u0026lt;TModel\u0026gt;, IMapper, and NavigationManager. These services are used to retrieve data, map objects, and handle navigation, respectively.\nlistViewModel: This private property holds the list of view models that will be displayed in the component.\nOnInitializedAsync: This method is an overridden method from the ComponentBase class. It is called when the component is initialized. In this method, we check if the injected services are available. If they are, we retrieve the data using the _service and map it to the view models using the Mapper. The resulting view models are assigned to the listViewModel property.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.List TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; NavigateLinkItemDetails=\u0026#34;/BlogPost/Details/{{{id}}}\u0026#34; NavigateLinkItemEdit=\u0026#34;/BlogPost/Edit/{{{id}}}\u0026#34; NavigateLinkItemDelete=\u0026#34;/BlogPost/Delete/{{{id}}}\u0026#34; /\u0026gt; Create Post (Create.razor, Create.razor.cs) @namespace BlazorAppGenericComponents.Components @typeparam TModel @typeparam TViewModel @if (viewModel == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;EditForm Context=\u0026#34;editFormComponent\u0026#34; OnValidSubmit=\u0026#34;@HandleValidSubmit\u0026#34; Model=\u0026#34;@viewModel\u0026#34;\u0026gt; @foreach (var property in typeof(TViewModel).GetProperties()) { @if (property.Name != \u0026#34;Id\u0026#34;) { \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@property.Name\u0026lt;/label\u0026gt; \u0026lt;input @onchange=\u0026#39;((e) =\u0026gt; HandleValueChanged(e, property.Name))\u0026#39; type=\u0026#34;text\u0026#34; value=\u0026#34;@property.GetValue(viewModel)?.ToString()\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } } \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Create\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; } In this code snippet, the component checks if the viewModel is null. If it is null, it displays a loading message. Otherwise, it renders an EditForm component with the viewModel as the model.\nInside the EditForm component, a loop iterates over the properties of the TViewModel type. For each property, a form group is created with a label and an input field. The label displays the name of the property, and the input field is bound to the corresponding property value in the viewModel.\nThe HandleValueChanged method is called whenever the value of an input field changes. It updates the corresponding property value in the viewModel.\nFinally, a submit button is displayed to create the entity.\nThe component has two generic type parameters: TModel and TViewModel. TModel represents the model class for the database entity, while TViewModel represents the view model class for the form.\nThe component has the following properties and dependencies:\nNavigateLinkAfterSubmit: A string parameter that specifies the URL to navigate to after the form is submitted. _service: An instance of the IService\u0026lt;TModel\u0026gt; interface, which is responsible for interacting with the database. Mapper: An instance of the IMapper interface, which is used to map the view model to the model. NavigationManager: An instance of the NavigationManager class, which is used to navigate to the specified URL. The component also has a private field called \u0026ldquo;viewModel\u0026rdquo; of type TViewModel, which represents the current state of the form.\nOnInitialized: This method is called when the component is initialized. It creates a new instance of the view model and assigns it to the \u0026ldquo;viewModel\u0026rdquo; field.\nHandleValidSubmit: This method is called when the form is submitted and passes validation. It maps the view model to the model using the IMapper interface. Then, it calls the AddAsync method of the _service instance to add the model to the database. If the operation is successful, it navigates to the specified URL using the NavigationManager.\nHandleValueChanged: This method is called when the value of an input field in the form changes. It updates the corresponding property of the view model with the new value.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Create TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; NavigateLinkAfterSubmit=\u0026#34;/BlogPost\u0026#34; /\u0026gt; Details Post (Details.razor, Details.razor.cs) \u0026lt;dl class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BaseViewModel.Id) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @typeof(TViewModel).GetProperty(nameof(BaseViewModel.Id))?.GetValue(viewModel)?.ToString() \u0026lt;/dd\u0026gt; @foreach (var property in typeof(TViewModel).GetProperties()) { if (property.Name != nameof(BaseViewModel.Id)) { \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @property.Name \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @property.GetValue(viewModel)?.ToString() \u0026lt;/dd\u0026gt; } } \u0026lt;/dl\u0026gt; The component has the following properties and dependencies:\nId: An optional parameter that represents the ID of the model for which the details are to be displayed.\n_service: An injected dependency of type IService\u0026lt;TModel\u0026gt;, which is responsible for retrieving the model data.\nMapper: An injected dependency of type IMapper, which is used to map the model to the view model.\nNavigationManager: An injected dependency of type NavigationManager, which is used for navigation within the application.\nviewModel: A private property of type TViewModel, which holds the view model instance.\nThe OnInitializedAsync method is overridden to fetch the model data and map it to the view model. If the Id is null or any of the dependencies are null, the method returns early. Otherwise, it calls the _service.GetbyId method to retrieve the model with the specified ID. If the model is found, it uses the Mapper to map the model to the view model and assigns it to the viewModel property.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Details TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; Id=\u0026#34;@id\u0026#34; /\u0026gt; Edit Post (Edit.razor, Edit.razor.cs) Let\u0026rsquo;s break down the code structure:\nNamespace and Using Statements: The code starts with the declaration of the namespace and the necessary using statements.\nType Parameters: The component is defined with two type parameters, TModel and TViewModel. These parameters allow the component to work with different models and view models.\nConditional Rendering: The code uses a conditional rendering statement to check if the viewModel is null. If it is null, it displays a loading message. Otherwise, it renders the form for editing the model.\nEditForm Component: The EditForm component is a built-in Blazor component that provides form validation and submission functionality. It is used to wrap the form elements.\nProperty Loop: Inside the EditForm component, a loop is used to iterate over the properties of the TViewModel type. The loop excludes the Id property, as it is usually an identifier and not editable.\nForm Group: For each property, a form group is created with a label and an input field. The onchange event is wired to a method called HandleValueChanged, which handles the value change of the input field.\nSubmit Button: Finally, a submit button is added to the form for saving the changes.\nBlazor generic component named Edit\u0026lt;TModel, TViewModel\u0026gt;. Let\u0026rsquo;s break down its structure:\nNamespace and Dependencies: The component is defined within the BlazorAppGenericComponents.Components namespace. It has dependencies on AutoMapper, BlazorAppGenericComponents.Models, BlazorAppGenericComponents.Services, BlazorAppGenericComponents.ViewModels, and Microsoft.AspNetCore.Components.\nComponent Declaration: The component is declared as a partial class that inherits from ComponentBase. It has two generic type parameters, TModel and TViewModel, which represent the model and view model types, respectively.\nComponent Parameters: The component has two parameters defined using the [Parameter] attribute. The Id parameter is of type int? and represents the identifier of the model to be edited. The NavigateLinkAfterSubmit parameter is of type string? and represents the URL to navigate to after a successful submit.\nDependency Injection: The component injects dependencies for IService\u0026lt;TModel\u0026gt;, IMapper, and NavigationManager using the [Inject] attribute.\nViewModel Initialization: The OnInitializedAsync method is overridden to initialize the view model based on the provided Id parameter. It retrieves the model from the service using the GetbyId method and maps it to the view model using AutoMapper.\nForm Submission: The HandleValidSubmit method is called when the form is submitted. It maps the view model back to the model using AutoMapper and calls the UpdateAsync method of the service to update the model. If the update is successful, it navigates to the specified URL using the NavigationManager.\nValue Change Handling: The HandleValueChanged method is called when the value of an input field changes. It updates the corresponding property of the view model based on the changed value.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Edit TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; Id=\u0026#34;@id\u0026#34; NavigateLinkAfterSubmit=\u0026#34;/BlogPost\u0026#34; /\u0026gt; Delete Post (Delete.razor, Delete.razor.cs) The code starts with the @namespace directive, which specifies the namespace of the component. It is followed by the @using directive, which imports the necessary namespaces for the component.\nNext, the component declares two type parameters, TModel and TViewModel, using the @typeparam directive. These type parameters represent the model and view model types that will be used with the component.\nThe code then checks if the viewModel variable is null. If it is null, it displays a loading message. Otherwise, it generates the details view for the view model.\nInside the dl element, the code displays the value of the Id property of the view model using the @nameof directive and the GetValue method. It then iterates over the properties of the view model using a foreach loop.\nFor each property, it checks if the property name is not equal to \u0026ldquo;Id\u0026rdquo;. If it is not equal, it displays the property name and its value using the @property.Name and @property.GetValue directives.\nFinally, the code displays a \u0026ldquo;Delete\u0026rdquo; button and attaches an onclick event handler to it.\nThe component has the following properties:\nId: An optional parameter that represents the ID of the record to be deleted.\nNavigateLinkAfterDelete: An optional parameter that specifies the URL to navigate to after the record is deleted.\nThe component also injects the following dependencies:\nIMapper: An object mapper that maps the model to the view model.\nNavigationManager: A service that provides navigation functionality.\nThe component has an OnInitializedAsync method that is called when the component is initialized. It retrieves the record with the specified ID from the service and maps it to the view model using the mapper.\nThe component also has a DeleteButtonClick method that is called when the delete button is clicked. It calls the service\u0026rsquo;s DeletebyIdAsync method to delete the record with the specified ID. If the deletion is successful, it navigates to the specified URL using the NavigationManager.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Delete TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; Id=\u0026#34;@id\u0026#34; NavigateLinkAfterDelete=\u0026#34;/BlogPost\u0026#34; /\u0026gt; Source Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppGenericComponents\n","date":"August 5, 2023","hero":"/dotnet/2023-08-05-blazor-generic-components/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-05-blazor-generic-components/","summary":"Blazor Generic Components We will explore a Blazor generic component that can be used for performing CRUD (Create, Read, Update, Delete) operations on a list of items. This component is designed to provide a reusable and efficient solution for displaying and managing data in a Blazor application.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .","tags":["Dotnet","Blazor Generic Components"],"title":"Blazor Generic Components"},{"categories":["Dotnet","Blazor Expose a Feed as RSS"],"contents":" Blazor Expose a Feed as RSS In this example, we will explore how to expose a feed as RSS using C# and the Blazor framework. We will create a controller that generates an RSS feed based on mock data.\nRSS (Really Simple Syndication): RSS is a web feed format used to publish frequently updated content, such as blog posts, news headlines, or podcasts. It allows users to subscribe to a website\u0026rsquo;s content and receive updates in a standardized format.\nSyndicationFeed: The SyndicationFeed class represents an RSS or Atom feed. It contains properties like title, description, author, categories, and a collection of SyndicationItem objects.\nSyndicationItem: The SyndicationItem class represents an individual item in an RSS or Atom feed. It contains properties like title, content, author, categories, and a link to the full article.\nRss20FeedFormatter: The Rss20FeedFormatter class is used to format a SyndicationFeed object as an RSS 2.0 feed.\nRSSController.cs RSSController inherits from ControllerBase. It exposes a single GET endpoint (/api/RSS) that returns an RSS feed.\nThe controller has a constructor that takes a MockData object as a parameter. This object is used to retrieve mock blog post data.\n[Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class RSSController : ControllerBase { private readonly MockData _mockData; public RSSController(MockData mockData) { _mockData = mockData; } [HttpGet] public IActionResult Get() { var output = new MemoryStream(); string xml; var Feeds = _mockData.GetAllBlogPosts(); List\u0026lt;SyndicationItem\u0026gt; items = new List\u0026lt;SyndicationItem\u0026gt;(); var feed = new SyndicationFeed(\u0026#34;RSS Feed Title\u0026#34;, \u0026#34;Feed Description\u0026#34;, new Uri(\u0026#34;https://localhost:5001/posts\u0026#34;)); // Set feed properties feed.ImageUrl = new Uri(\u0026#34;https://picsum.photos/600/400\u0026#34;); feed.Authors.Add(new SyndicationPerson(\u0026#34;asd@asd.com\u0026#34;, \u0026#34;asdname\u0026#34;, \u0026#34;https://picsum.photos/600/600\u0026#34;)); feed.BaseUri = new Uri(\u0026#34;https://localhost:5001\u0026#34;); feed.Categories.Add(new SyndicationCategory(\u0026#34;Feed Category 1 Base\u0026#34;)); feed.LastUpdatedTime = DateTime.Now; feed.Language = \u0026#34;Lang1\u0026#34;; feed.Copyright = new TextSyndicationContent(\u0026#34;Copy1\u0026#34;); // Create SyndicationItems for each blog post foreach (var post in Feeds) { var solutionfeed = new SyndicationItem(post.Title, post.Content, new Uri(quot;https://localhost:5001/postsingle/{post.Id}\u0026#34;), post.Id.ToString(), DateTime.Now); solutionfeed.Authors.Add(new SyndicationPerson(\u0026#34;post@user.com\u0026#34;, \u0026#34;postuser\u0026#34;, \u0026#34;https://picsum.photos/600/600\u0026#34;)); solutionfeed.BaseUri = new Uri(\u0026#34;https://localhost:5001/posts\u0026#34;); solutionfeed.Categories.Add(new SyndicationCategory(\u0026#34;Feed Category 1 feed\u0026#34;)); solutionfeed.Contributors.Add(new SyndicationPerson(\u0026#34;postCont@user.com\u0026#34;, \u0026#34;postcontuser\u0026#34;, \u0026#34;https://picsum.photos/600/600\u0026#34;)); solutionfeed.Copyright = new TextSyndicationContent(\u0026#34;feed copy\u0026#34;); solutionfeed.ElementExtensions.Add(new XElement(\u0026#34;enclosure\u0026#34;, new XAttribute(\u0026#34;type\u0026#34;, \u0026#34;\u0026#34;), new XAttribute(\u0026#34;url\u0026#34;, \u0026#34;https://picsum.photos/600/400\u0026#34;), new XAttribute(\u0026#34;width\u0026#34;, 200), new XAttribute(\u0026#34;height\u0026#34;, 200)).CreateReader()); solutionfeed.PublishDate = DateTime.Now; solutionfeed.Summary = new TextSyndicationContent(post.Content.Substring(0, 5)); items.Add(solutionfeed); } // Set the items collection of the feed feed.Items = items; // Create an Rss20FeedFormatter and write the feed to a MemoryStream var formatter = new Rss20FeedFormatter(feed); var xws = new XmlWriterSettings { Encoding = Encoding.UTF8 }; using (var xmlWriter = XmlWriter.Create(output, xws)) { formatter.WriteTo(xmlWriter); xmlWriter.Flush(); } // Read the generated XML from the MemoryStream using (var sr = new StreamReader(output)) { output.Position = 0; xml = sr.ReadToEnd(); sr.Close(); } // Return the XML as a ContentResult with the appropriate content type ContentResult result = Content(xml, \u0026#34;application/xml\u0026#34;, Encoding.UTF8); return result; } } The Get method is responsible for generating the RSS feed. Here\u0026rsquo;s a breakdown of the code:\nCreate a MemoryStream and a string variable to store the generated XML. Retrieve the mock blog post data using the MockData object. Create an empty list of SyndicationItem objects and a SyndicationFeed object. Set the properties of the feed, such as title, description, image URL, authors, categories, and last updated time. Iterate over each blog post and create a SyndicationItem for it. Set the properties of the item, such as title, content, link, author, categories, contributors, enclosure, publish date, and summary. Add the item to the list of items. Set the Items property of the feed to the list of items. Create an Rss20FeedFormatter and write the feed to the MemoryStream using an XmlWriter. Read the generated XML from the MemoryStream into the xml variable. Create a ContentResult with the XML as the content and the appropriate content type. Return the ContentResult. Source Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRSSFeed\n","date":"August 2, 2023","hero":"/dotnet/2023-08-02-blazor-rssfeed/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-02-blazor-rssfeed/","summary":"Blazor Expose a Feed as RSS In this example, we will explore how to expose a feed as RSS using C# and the Blazor framework. We will create a controller that generates an RSS feed based on mock data.\nRSS (Really Simple Syndication): RSS is a web feed format used to publish frequently updated content, such as blog posts, news headlines, or podcasts. It allows users to subscribe to a website\u0026rsquo;s content and receive updates in a standardized format.","tags":["Dotnet","Blazor Expose a Feed as RSS"],"title":"Blazor Expose a Feed as RSS"},{"categories":["Dotnet","EF Migrations with Multiple Providers"],"contents":" Blazor Blazor Entity Framework Migrations with Multiple Providers This code demonstrates how to implement multiple database providers in a Blazor application using C#. It allows you to switch between different database providers, such as InMemory, SQLite, and SQL Server, based on the configuration settings.\nDatabase Provider: Refers to the type of database being used, such as InMemory, SQLite, or SQL Server.\nConnection String: A string that contains the necessary information to connect to a specific database.\nEntity Framework: A popular object-relational mapping (ORM) framework that simplifies database access in .NET applications.\nMigrations: A way to manage database schema changes over time, allowing you to update the database structure without losing data.\nDependency Injection: A design pattern that allows objects to be created and managed by a separate container, making it easier to manage dependencies between different components of an application.\nProgram.cs The code consists of two main sections: the Main method and the ServiceCollectionExtensions class.\nIn the Main method:\nIt creates a WebApplication builder. It retrieves the active database provider from the configuration settings. If a provider is specified, it configures the services and connection string for that provider. If the provider is InMemory, it checks and creates the database. It adds necessary services to the container. It builds the application and runs it. In the ServiceCollectionExtensions class:\nIt defines an extension method ConfigureServices for the IServiceCollection interface. It configures the ApplicationDbContext based on the specified provider and connection string. It adds services for SeedData and BlogPostService. It configures AutoMapper for mapping between different models. It creates a mapper instance and adds it as a singleton service. Here are some code examples to illustrate the usage of the code:\nConfiguring the services for SQLite provider:\nservices.ConfigureServices(\u0026#34;Sqlite\u0026#34;, \u0026#34;Data Source=mydatabase.db\u0026#34;); Checking and creating the database:\nservices.CheckAndCreateDatabase(); Using the SeedData service to create initial data:\nvar seedData = serviceProvider.GetRequiredService\u0026lt;SeedData\u0026gt;(); await seedData.CreateInitialData(); appsettings.json The configuration settings for the Blazor application, including the database provider and connection strings.\n{ \u0026#34;DatabaseProvider\u0026#34;: \u0026#34;InMemory\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;Sqlite\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;SqlServer\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Localdb\u0026#34;: \u0026#34;\u0026#34; }, DatabaseProvider: This property specifies the default database provider to be used by the Blazor application. In this example, the value is set to \u0026ldquo;InMemory\u0026rdquo;, which means an in-memory database will be used. You can replace this value with the desired database provider, such as \u0026ldquo;Sqlite\u0026rdquo; or \u0026ldquo;SqlServer\u0026rdquo;.\nConnectionStrings: This property contains a collection of connection strings for different database providers. In this example, three connection strings are provided: \u0026ldquo;Sqlite\u0026rdquo;, \u0026ldquo;SqlServer\u0026rdquo;, and \u0026ldquo;Localdb\u0026rdquo;. Each connection string specifies the necessary details to connect to the respective database provider.\nbuildschema.bat Creating a migration: dotnet ef migrations add Initial01 -c ApplicationDbContext --startup-project ./BlazorAppEFMultipleDBProviders --project ./AppMigrations/AppMigrations.Sqlite -- --DatabaseProvider Sqlite This command adds a new migration named \u0026ldquo;Initial01\u0026rdquo; to the specified context (ApplicationDbContext). It generates the migration files in the ./Migrations/Initial01 directory. The \u0026ndash;startup-project and \u0026ndash;project flags specify the startup project and the project containing the migration files, respectively. The \u0026ndash;DatabaseProvider Sqlite flag indicates that we are using the SQLite database provider.\nGenerating a SQL script for a migration: dotnet ef migrations script -c ApplicationDbContext -o ./AppMigrations/AppMigrations.Sqlite/Migrations/Initial01.sql --startup-project ./BlazorAppEFMultipleDBProviders --project ./AppMigrations/AppMigrations.Sqlite -- --DatabaseProvider Sqlite This command generates a SQL script for the migration named \u0026ldquo;Initial01\u0026rdquo;. The script is saved in the ./AppMigrations/AppMigrations.Sqlite/Migrations/Initial01.sql file. The flags have the same meaning as in the previous command.\nRunning the application with seeding: dotnet run --project ./BlazorAppEFMultipleDBProviders/BlazorAppEFMultipleDBProviders.csproj /seed This command runs the application, specifically the BlazorAppEFMultipleDBProviders.csproj project, with the /seed argument. This argument triggers the seeding of initial data into the database.\nConclusion Configuring multiple database providers in a Blazor application is essential when you need to work with different databases or switch between databases based on the environment. By using the provided JSON configuration, you can easily specify the desired database provider and connection strings for each provider. This flexibility allows your Blazor application to seamlessly interact with different databases, providing a robust and scalable solution.\nThis example demonstrates how to implement multiple database providers in a Blazor application using C#. By configuring the services and connection string based on the specified provider, you can easily switch between different databases. The code also shows how to use migrations and seed data to manage the database schema and initial data.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppEFMultipleDBProviders\n","date":"July 31, 2023","hero":"/dotnet/2023-07-31-blazor-ef-multipledbproviders/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-31-blazor-ef-multipledbproviders/","summary":"Blazor Blazor Entity Framework Migrations with Multiple Providers This code demonstrates how to implement multiple database providers in a Blazor application using C#. It allows you to switch between different database providers, such as InMemory, SQLite, and SQL Server, based on the configuration settings.\nDatabase Provider: Refers to the type of database being used, such as InMemory, SQLite, or SQL Server.\nConnection String: A string that contains the necessary information to connect to a specific database.","tags":["Dotnet","Blazor EF Migrations with Multiple Providers"],"title":"Blazor EF Migrations with Multiple Providers"},{"categories":["Dotnet","Blazor Authentication and Authorization"],"contents":" Blazor Authentication and Authorization This example represents a Blazor application that allows users to view a list of blog posts. The application uses ASP.NET Core and Blazor authentication and authorization to control access to the blog posts.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables developers to write code that runs on the client-side in the browser using WebAssembly or on the server-side using SignalR.\nASP.NET Core: ASP.NET Core is an open-source, cross-platform framework for building modern, cloud-based web applications. It provides a unified programming model for building web APIs, web UIs, and real-time applications.\nBlazor Authentication and Authorization: Blazor provides built-in support for authentication and authorization. It allows developers to secure their applications by restricting access to certain resources based on user roles or policies.\nRazor: Razor is a syntax for combining HTML markup with C# code in a single file. It is used in Blazor to create dynamic web UIs.\nThe code is structured as a Blazor component with a Razor markup file (.razor) and a code-behind file (.cs). The Razor markup file contains the HTML and Razor syntax for rendering the UI, while the code-behind file contains the C# code for handling events and data manipulation.\nList Posts (Index.razor) The code starts with the @page directive, which specifies the URL route for this component (\u0026quot;/BlogPost\u0026quot;). The @using directives import the necessary namespaces for using classes and services in the code.\nThe @inject directives are used to inject dependencies into the component. In this case, the IMapper, NavigationManager, and BlogPostService are injected. The IMapper is used for object mapping, the NavigationManager is used for navigation, and the BlogPostService is used for retrieving blog posts.\nThe \u0026lt;PageTitle\u0026gt; component sets the page title to \u0026ldquo;Index\u0026rdquo;.\nThe \u0026lt;AuthorizeView\u0026gt; component is used to control access to the content based on the user\u0026rsquo;s authorization. The Policy attribute specifies the policy required to access the content. Inside the \u0026lt;Authorized\u0026gt; block, the UI for displaying the list of blog posts is rendered.\nThe code checks if the blogPosts variable is null. If it is null, a loading message is displayed. Otherwise, a table is rendered with the blog post data. The @foreach loop iterates over each blog post in the blogPosts collection and displays the blog post\u0026rsquo;s ID, title, and content. The AuthorizeView component is used to conditionally render the edit and delete links based on the user\u0026rsquo;s authorization.\nThe \u0026lt;NotAuthorized\u0026gt; block is rendered when the user is not authorized to access the content.\nThe @code block contains the C# code for the component. The blogPosts variable is declared as an IEnumerable\u0026lt;BlogPostViewModel\u0026gt; and is initially set to null. The OnInitializedAsync method is overridden to retrieve the blog posts from the BlogPostService and map them to the BlogPostViewModel using the IMapper.\nCreate Post (Create.razor) Let\u0026rsquo;s take a look at some code examples to better understand how the blog post creation works:\nCreating the BlogPostViewModel:\nprivate BlogPostViewModel? blogPost; protected override void OnInitialized() { blogPost = new(); } In the OnInitialized method, we initialize the blogPost variable as a new instance of the BlogPostViewModel class. This class represents the data structure for the blog post.\nHandling the Valid Submit:\nprivate async void HandleValidSubmit() { var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.AddBlogPostAsync(model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } The HandleValidSubmit method is called when the user clicks the submit button. It maps the blogPost object to the BlogPost model using AutoMapper. Then, it calls the AddBlogPostAsync method of the BlogPostService to add the blog post to the database. If the operation is successful, the user is redirected to the \u0026ldquo;/BlogPost\u0026rdquo; page.\nPost Detail (Details.razor) Here are some key code examples from the Blazor BlogPost Details page:\nRetrieving the blog post data:\nprotected override async Task OnInitializedAsync() { if (blogPost == null) { var result = await BlogPostService.GetbyId(id); if (result != null) blogPost = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(result); } } In the OnInitializedAsync method, the blog post data is retrieved from the server using the BlogPostService.GetbyId method. If the result is not null, the data is mapped to a BlogPostViewModel object using AutoMapper and assigned to the blogPost variable.\nDisplaying the blog post details:\n\u0026lt;dl class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Id) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Id \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Title) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Title \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Content) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Content \u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; The blog post details are displayed using an HTML definition list (\u0026lt;dl\u0026gt;) with rows and columns. The @nameof directive is used to get the name of the properties of the BlogPost class, and the @blogPost variable is used to display the corresponding values.\nEdit Post (Edit.razor) Here are some code examples from the provided code:\nBinding the blogPost.Title property to an input field:\n\u0026lt;InputText @bind-Value=\u0026#34;blogPost.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; Handling the form submission and updating the blog post:\nprivate async void HandleValidSubmit() { var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.UpdateBlogPostAsync(id, model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } Delete Post (Delete.razor) Let\u0026rsquo;s take a closer look at some code examples to understand the implementation:\nDelete Confirmation:\n\u0026lt;h3\u0026gt;Are you sure you want to delete this?\u0026lt;/h3\u0026gt; Blog Post Details:\n\u0026lt;dl class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Id) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Id \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Title) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Title \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Content) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Content \u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; Delete Button:\n\u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @onclick=\u0026#34;DeleteButtonClick\u0026#34;\u0026gt;Delete\u0026lt;/button\u0026gt; | \u0026lt;a href=\u0026#34;/BlogPost\u0026#34;\u0026gt;Back to List\u0026lt;/a\u0026gt; Source Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppAuth\n","date":"July 30, 2023","hero":"/dotnet/2023-07-30-blazor-authentication-authorization/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-30-blazor-authentication-authorization/","summary":"Blazor Authentication and Authorization This example represents a Blazor application that allows users to view a list of blog posts. The application uses ASP.NET Core and Blazor authentication and authorization to control access to the blog posts.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables developers to write code that runs on the client-side in the browser using WebAssembly or on the server-side using SignalR.","tags":["Dotnet","Blazor Authentication and Authorization"],"title":"Blazor Authentication and Authorization"},{"categories":["Dotnet","Blazor Radzen CRUD"],"contents":" Blazor Radzen CRUD In this article, we will explore the code for a Blazor page called \u0026ldquo;BlogPost\u0026rdquo;. This page displays a list of blog posts using a RadzenDataGrid component. We will go through the key concepts, code structure, and code examples to understand how this page works.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor and RadzenDataGrid:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables the development of single-page applications (SPAs) with the power of .NET.\nRadzenDataGrid: RadzenDataGrid is a component provided by Radzen, a popular UI component library for Blazor. It is used to display tabular data with features like sorting, filtering, and paging.\nAutoMapper: AutoMapper is a library used for object-to-object mapping. It simplifies the mapping process between different object types by automatically mapping properties with matching names.\nBlogPostViewModel: BlogPostViewModel is a class that represents the data model for the blog post form. It contains properties for the title and content of the blog post.\nBlogPostService: BlogPostService is a service class responsible for handling CRUD operations related to blog posts. It provides methods for adding, updating, deleting, and retrieving blog posts from the database.\nNavigationManager: NavigationManager is a Blazor service that provides navigation functionality. It allows us to navigate to different pages within the application.\nThe code provided represents the \u0026quot;BlogPost\u0026quot; page in a Blazor application. Let\u0026rsquo;s break down the code structure and understand its different sections:\nPage Directive: The @page \u0026quot;/BlogPost\u0026quot; directive specifies the URL route for this page. It means that when the user navigates to \u0026ldquo;/BlogPost\u0026rdquo;, this page will be displayed.\nPage Directive: The @page directive specifies the URL route for this page. In this case, the page is accessible at \u0026ldquo;/BlogPost/Create\u0026rdquo;.\nRadzenDataGrid Component: The main component on this page is the RadzenDataGrid. It is configured with various properties and columns to display the blog post data.\nUsing Directives: The @using directives import the necessary namespaces for the code to work correctly. We import the AutoMapper, BlazorAppRadzenCRUD.Data, BlazorAppRadzenCRUD.Models, and BlazorAppRadzenCRUD.Services namespaces.\nDependency Injection: The @inject directives inject the required services into the page. We inject the IMapper, NavigationManager, and BlogPostService services.\nPage Content: The page content is wrapped in a \u0026lt;RadzenStack\u0026gt; component, which provides a vertical stack layout for the elements.\nLoading Indicator: If the blogPostViewModel is null, a loading message is displayed. This is useful when the page is still initializing and fetching data.\nBlog Post Form: Once the blogPostViewModel is populated, the blog post form is rendered. The form is wrapped in an \u0026lt;EditForm\u0026gt; component, which handles form validation and submission.\nForm Fields: The form contains two fields: title and content. Each field is wrapped in a \u0026lt;RadzenRow\u0026gt; component, which represents a row in the form layout. The \u0026lt;RadzenColumn\u0026gt; components define the size of the columns within the row.\nInput Fields: The \u0026lt;InputText\u0026gt; components represent the input fields for the title and content. The @bind-Value attribute binds the input field to the corresponding property in the blogPostViewModel.\nValidation: The \u0026lt;DataAnnotationsValidator\u0026gt; and \u0026lt;ValidationSummary\u0026gt; components handle form validation. They display error messages if the user enters invalid data.\nSave Button: The \u0026lt;RadzenButton\u0026gt; component represents the save button. It triggers the form submission when clicked and has a success style.\nBack Button: The \u0026lt;RadzenButton\u0026gt; component represents the back button. It navigates the user back to the blog post index page when clicked.\nCode Block: The @code block contains the C# code for the page. It defines the blogPostViewModel property, initializes it in the OnInitialized method, and handles the form submission and navigation.\nList Posts (Index.razor) Now, let\u0026rsquo;s take a closer look at some important code examples from the provided code:\nLoading Data: private async Task LoadData(LoadDataArgs args) { isLoading = true; var result = await BlogPostService.GetBlogPostsAsync(filter: args.Filter, top: args.Top, skip: args.Skip, orderby: args.OrderBy, count: true); blogPosts = Mapper.Map\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;, IEnumerable\u0026lt;BlogPostViewModel\u0026gt;\u0026gt;(result.Result); totalCount = result.TotalCount; isLoading = false; } The LoadData method is responsible for loading the blog post data. It is called when the RadzenDataGrid needs to fetch new data, such as when the user changes the page or applies filters. It makes an asynchronous call to the BlogPostService.GetBlogPostsAsync method to retrieve the data. The result is then mapped to a collection of BlogPostViewModel objects using the Mapper class. Finally, the isLoading flag is updated to indicate the loading state.\nNavigation Methods: private void NavigatetoCreate() =\u0026gt; NavigationManager.NavigateTo(\u0026#34;/BlogPost/Create\u0026#34;); private void NavigatetoDetail(int id) =\u0026gt; NavigationManager.NavigateTo(quot;/BlogPost/Detail/{id}\u0026#34;); private void NavigatetoEdit(int id) =\u0026gt; NavigationManager.NavigateTo(quot;/BlogPost/Edit/{id}\u0026#34;); private void NavigatetoDelete(int id) =\u0026gt; NavigationManager.NavigateTo(quot;/BlogPost/Delete/{id}\u0026#34;); These methods handle the navigation to different pages related to the blog posts. For example, NavigatetoCreate navigates to the page for creating a new blog post, NavigatetoDetail navigates to the page for viewing the details of a specific blog post, and so on. The NavigationManager class is used to perform the navigation by specifying the desired URL.\nCreate Post (Create.razor) Here are some code examples to illustrate the concepts discussed above:\nMapping the BlogPostViewModel to BlogPost:\nvar blogPost = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPostViewModel); In this example, we use AutoMapper to map the properties of the blogPostViewModel to the corresponding properties of the BlogPost model.\nAdding a new blog post:\nbool result = await BlogPostService.AddBlogPostAsync(blogPost); Here, we call the AddBlogPostAsync method of the BlogPostService to add the new blog post to the database. The method returns a boolean value indicating the success of the operation.\nNavigating to the blog post index page:\nNavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); This code snippet uses the NavigationManager to navigate the user back to the blog post index page (\u0026quot;/BlogPost\u0026quot;) after a successful save operation.\nPost Detail (Detail.razor) Here is an example of how the code retrieves the blog post data and maps it to the view model:\nprotected override async Task OnInitializedAsync() { if (blogPostViewModel == null) { var blogPost = await BlogPostService.GetbyId(id); if (blogPost == null) return; blogPostViewModel = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(blogPost); } } In this example, the GetbyId method of the BlogPostService is called to retrieve the blog post data based on the provided ID. If the blog post is found, it is then mapped to the BlogPostViewModel using AutoMapper.\nEdit Post (Edit.razor) Here are some key code examples from the provided code:\nBinding the input fields to the blogPostViewModel properties:\n\u0026lt;InputText id=\u0026#34;title\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Title\u0026#34; @bind-Value=\u0026#34;blogPostViewModel.Title\u0026#34; /\u0026gt; The @bind-Value directive binds the value of the input field to the Title property of the blogPostViewModel.\nHandling the form submission:\n\u0026lt;EditForm Context=\u0026#34;editFormEdit\u0026#34; Model=\u0026#34;@blogPostViewModel\u0026#34; OnValidSubmit=\u0026#34;HandleValidSubmit\u0026#34;\u0026gt; ... \u0026lt;RadzenButton Text=\u0026#34;Save\u0026#34; Icon=\u0026#34;save\u0026#34; ButtonType=\u0026#34;ButtonType.Submit\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Success\u0026#34; /\u0026gt; \u0026lt;/EditForm\u0026gt; The OnValidSubmit event handler is triggered when the form is submitted and passes the form data to the HandleValidSubmit method.\nNavigating to the blog post index page:\nprivate void NavigatetoBlogPostIndex() =\u0026gt; NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); The NavigatetoBlogPostIndex method uses the NavigationManager service to navigate to the blog post index page.\nDelete Post (Delete.razor) The code example provided includes the following key components:\nRetrieving the Blog Post Details:\nprotected override async Task OnInitializedAsync() { if (blogPostViewModel == null) { var blogPost = await BlogPostService.GetbyId(id); if (blogPost == null) return; blogPostViewModel = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(blogPost); } } This method is executed when the page is initialized. It retrieves the blog post details using the BlogPostService and maps the retrieved BlogPost object to a BlogPostViewModel object using AutoMapper. The blogPostViewModel property is then set to the mapped object.\nDeleting the Blog Post:\nprivate async void RemoveButtonClick() { bool result = await BlogPostService.DeletebyIdAsync(id); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } This method is called when the \u0026ldquo;REMOVE\u0026rdquo; button is clicked. It calls the DeletebyIdAsync method of the BlogPostService to delete the blog post with the specified ID. If the deletion is successful, the user is redirected to the blog post index page using the NavigationManager.\nNavigating to the Blog Post Index Page:\nprivate void NavigatetoBlogPostIndex() =\u0026gt; NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); This method is called when the \u0026ldquo;Back\u0026rdquo; button is clicked. It uses the NavigationManager to navigate to the blog post index page.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenCRUD\n","date":"July 26, 2023","hero":"/dotnet/2023-07-26-blazor-radzen-crud/blazor_radzen_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-26-blazor-radzen-crud/","summary":"Blazor Radzen CRUD In this article, we will explore the code for a Blazor page called \u0026ldquo;BlogPost\u0026rdquo;. This page displays a list of blog posts using a RadzenDataGrid component. We will go through the key concepts, code structure, and code examples to understand how this page works.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor and RadzenDataGrid:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript.","tags":["Dotnet","Blazor Radzen CRUD"],"title":"Blazor Radzen CRUD"},{"categories":["Dotnet","Blazor Radzen SearchComponent"],"contents":" Blazor Radzen SearchComponent 1. Blazor Radzen List Page The code provided is a Blazor component that demonstrates how to fetch data from a service and display it in a RadzenDataList component. It also includes a custom search component that allows users to search for specific blog posts.\nBlazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code in C# that runs on the client-side, eliminating the need for JavaScript. Radzen: Radzen is a set of UI components for Blazor that provides pre-built components for building responsive and interactive web applications. RadzenDataList: RadzenDataList is a component from the Radzen UI library that displays a list of items in a grid-like format. It supports features like paging, sorting, and filtering. RadzenCard: RadzenCard is a component from the Radzen UI library that displays content in a card-like format. It provides a visually appealing way to present data. ComponentSearch: ComponentSearch is a custom search component that allows users to search for specific blog posts. It triggers the search functionality when the user clicks the search button. BlogPostService: BlogPostService is a service that provides methods for fetching blog post data from a backend API. The code starts with the @page directive, which specifies the URL route for this component. In this case, the component is accessible at \u0026ldquo;/fetchdata\u0026rdquo;.\nThe code then includes the necessary @using directives to import the required namespaces and inject the BlogPostService into the component. The component\u0026rsquo;s markup is defined within the \u0026lt;PageTitle\u0026gt; tag. It starts with an \u0026lt;h1\u0026gt; heading that displays the title \u0026ldquo;Blogposts\u0026rdquo; followed by a paragraph explaining the purpose of the component.\nNext, a \u0026lt;RadzenCard\u0026gt; component is used to wrap the search component. The search component is a custom component called ComponentSearch that is defined in a separate file. It is injected into the component using the @using directive and its SearchButtonClick event is bound to the SearchButtonClick method in the code section.\nAfter the search component, a \u0026lt;RadzenDataList\u0026gt; component is used to display the list of blog posts. It is configured with various properties like WrapItems, AllowPaging, IsLoading, LoadData, Data, Count, TItem, PageSize, PagerHorizontalAlign, and ShowPagingSummary. These properties control the behavior and appearance of the data list.\nInside the \u0026lt;RadzenDataList\u0026gt;, a \u0026lt;Template\u0026gt; component is used to define the layout of each item in the list. It contains a \u0026lt;RadzenCard\u0026gt; component that displays the blog post details in a card-like format. The details include the blog post ID, title, and content.\nThe code section contains the C# code that handles the data loading and search functionality. It defines various private fields and properties like itemPageSize, totalCount, isLoading, currentArgs, blogposts, search, and searchProperty.\nThe LoadData method is responsible for fetching the blog post data from the BlogPostService based on the provided arguments. It sets the isLoading flag to true, assigns the current arguments, and calls the GetBlogPostsbyPageAsync method of the BlogPostService. It then assigns the result to the blogposts field and updates the totalCount field. Finally, it sets the isLoading flag to false.\nThe SearchButtonClick method is triggered when the user clicks the search button in the custom search component. It updates the search field with the provided search value and calls the LoadData method to reload the data with the updated search value.\nHere is an example of how to use the RadzenDataList component in a Blazor application:\n\u0026lt;RadzenDataList Data=\u0026#34;@blogposts\u0026#34; PageSize=\u0026#34;10\u0026#34; AllowPaging=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Template Context=\u0026#34;blogpost\u0026#34;\u0026gt; \u0026lt;div\u0026gt;@blogpost.Title\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;@blogpost.Content\u0026lt;/div\u0026gt; \u0026lt;/Template\u0026gt; \u0026lt;/RadzenDataList\u0026gt; In this example, the RadzenDataList component is bound to a collection of blogposts and is configured to display 10 items per page with paging enabled. The \u0026lt;Template\u0026gt; component is used to define the layout of each item in the list, displaying the title and content of each blog post.\nThe provided code demonstrates how to fetch data from a service and display it in a Blazor component using the Radzen UI library. It also includes a custom search component for filtering the data based on user input. By understanding the key concepts and code structure, you can leverage this code to build similar functionality in your own Blazor applications.\n2. Blazor Radzen Search Component Here is an example of how the search component can be used in a Blazor application:\n\u0026lt;SearchComponent SearchButtonClick=\u0026#34;HandleSearch\u0026#34; /\u0026gt; @code { private async Task HandleSearch(string searchValue) { // Perform search logic here // Example: Call an API endpoint with the search query await SearchService.Search(searchValue); } } In the above example, the SearchComponent is used with the SearchButtonClick event callback. When the user clicks the search button, the HandleSearch method is invoked. Inside the HandleSearch method, you can implement the search logic, such as calling an API endpoint with the search query.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenSearch\n","date":"July 21, 2023","hero":"/dotnet/2023-07-21-blazor-radzen-searchcomponent/blazor_radzen_searchcomponent.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-21-blazor-radzen-searchcomponent/","summary":"Blazor Radzen SearchComponent 1. Blazor Radzen List Page The code provided is a Blazor component that demonstrates how to fetch data from a service and display it in a RadzenDataList component. It also includes a custom search component that allows users to search for specific blog posts.\nBlazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code in C# that runs on the client-side, eliminating the need for JavaScript.","tags":["Dotnet","Blazor Radzen SearchComponent"],"title":"Blazor Radzen Search Comp."},{"categories":["Dotnet","Blazor Plyr Video Player"],"contents":" Blazor Plyr Video Player This code provides a video player component in a Blazor application. It allows users to watch videos with controls and captions. The video player is customizable using the Plyr.io library.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET. Plyr.io: Plyr.io is a JavaScript library that provides a customizable video player with a modern UI. It supports various features like controls, captions, and responsive design.\nThe code is structured as a Blazor component with a Razor markup file (.razor) and a code-behind file (.razor.cs). The Razor markup file defines the UI elements and the code-behind file contains the logic for the component.\nThe code uses the @page directive to define the URL routes for the component. It injects the IJSRuntime service to interact with JavaScript code.\nThe video variable is used to store the selected video. If the video is null, a loading message is displayed. Otherwise, the video player is rendered with the Plyr.io library.\nThe code dynamically generates \u0026lt;source\u0026gt; elements for the video files and \u0026lt;track\u0026gt; elements for the captions. It also provides a fallback download link for browsers that don\u0026rsquo;t support the \u0026lt;video\u0026gt; element.\nThe OnInitializedAsync method is called when the component is initialized. It retrieves the video based on the Id parameter from the Data.VideosData.Videos collection.\nThe OnAfterRenderAsync method is called after the component has been rendered. It loads a custom video player using JavaScript interop. The LoadCustomPlayer function is invoked from a JavaScript file located in the ./js/components/video.js path.\nThe provided code demonstrates how to create a video player component in a Blazor application using the Plyr.io library. It allows users to watch videos with controls and captions. The code can be customized further to meet specific requirements and integrate additional features.\nSource Full source code is available at this repository in GitHub: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppVideoPlayer\n","date":"July 20, 2023","hero":"/dotnet/2023-07-20-blazor-plyr-video-player/blazor_plyr.png","permalink":"https://akifmt.github.io/dotnet/2023-07-20-blazor-plyr-video-player/","summary":"Blazor Plyr Video Player This code provides a video player component in a Blazor application. It allows users to watch videos with controls and captions. The video player is customizable using the Plyr.io library.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET. Plyr.io: Plyr.io is a JavaScript library that provides a customizable video player with a modern UI.","tags":["Dotnet","Blazor Plyr Video Player"],"title":"Blazor Plyr Video Player"},{"categories":["Programming","OOP"],"contents":" Programming A programming language is a formal computer language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs to control the behavior of a machine or to express algorithms. (Source: wikipedia)\nObject Oriented Programming(OOP) Object Oriented Programming(OOP) is a programming paradigm based on the concept of objects, which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.\nEncapsulation Abstraction Inheritance Polymorphism There are five principles when design a class.\nSRP (The Single Responsibility Principle) A class should have one, and only one, reason to change. OCP (The Open Closed Principle) Should be able to extend any classes\u0026rsquo; behaviors, without modifying the classes.. LSP (The Liskov Substitution Principle) Derived classes must be substitutable for their base classes. ISP (The Interface Segregation Principle) Make fine grained interfaces that are client specific. DIP (The Dependency Inversion Principle) Depend on abstractions, not on concretions. What is Encapsulation (or Information Hiding)? The encapsulation is the inclusion-within a program object-of all the resources needed for the object to function, basically, the methods and the data. In OOP the encapsulation is mainly achieved by creating classes, the classes expose public methods and properties. A class is kind of a container or capsule or a cell, which encapsulate a set of methods, attribute and properties to provide its indented functionalities to other classes. In that sense, encapsulation also allows a class to change its internal implementation without hurting the overall functioning of the system. That idea of encapsulation is to hide how a class does its business, while allowing other classes to make requests of it.\nIn order to modularize/ define the functionality of a one class, that class can uses functions or properties exposed by another class in many different ways. According to Object Oriented Programming there are several techniques classes can use to link with each other. Those techniques are named association, aggregation, and composition.\nAssociation A relationship where all objects have their own lifecycle and there is no owner.\nAggregation A specialised form of Association where all objects have their own lifecycle, but there is ownership and child objects can not belong to another parent object.\nComposition A specialised form of Aggregation and we can call this as a “death” relationship. It is a strong type of Aggregation. Child object does not have its lifecycle and if parent object is deleted, all child objects will also be deleted.\nAbstraction Abstraction is an emphasis on the idea, qualities and properties rather than the particulars (a suppression of detail). The importance of abstraction is derived from its ability to hide irrelevant details and from the use of names to reference objects. Abstraction is essential in the construction of programs. It places the emphasis on what an object is or does rather than how it is represented or how it works. Thus, it is the primary means of managing complexity in large programs.\nGeneralization Generalization is the broadening of application to encompass a larger domain of objects of the same or different type. Programming languages provide generalization through variables, parameterization, generics and polymorphism. It places the emphasis on the similarities between objects. Thus, it helps to manage complexity by collecting individuals into groups and providing a representative which can be used to specify any individual of the group.\nAbstraction and generalization are often used together. Abstracts are generalized through parameterization to provide greater utility. In parameterization, one or more parts of an entity are replaced with a name which is new to the entity. The name is used as a parameter. When the parameterized abstract is invoked, it is invoked with a binding of the parameter to an argument.\n","date":"July 1, 2023","hero":"/posts/2023-07-01-programming/blog18_Programming.jpg","permalink":"https://akifmt.github.io/posts/2023-07-01-programming/","summary":"Programming A programming language is a formal computer language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs to control the behavior of a machine or to express algorithms. (Source: wikipedia)\nObject Oriented Programming(OOP) Object Oriented Programming(OOP) is a programming paradigm based on the concept of objects, which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.","tags":["Programming","OOP"],"title":"Programming"},{"categories":["IIS","Node.js","Deployment","Release","iisnode"],"contents":"\nNode.js Deployment and Publishing on IIS - iisnode\nTested on Windows Server 2016 x64 and IIS 10.0. All the requirements for different versions are the same, only the appropriate version for iisnode should be installed.\nRequirements:\nWebPlatformInstaller: WebPlatformInstaller IIS URL Rewrite extension: IIS URL Rewrite extension Node.js: node.js iisnode v0.22.1 x64 : iisnode v0.22.1 x64 After installation, the project should have \u0026ldquo;web.config\u0026rdquo;. The following config example can also be used with Express Framework. The app will be started with server.js. Outputs in the console can be checked from the folder specified with logDirectory. The debug sections in the \u0026ldquo;config\u0026rdquo; should be updated when going to the \u0026ldquo;production\u0026rdquo; phase.\n\u0026lt;configuration\u0026gt; \u0026lt;system.webServer\u0026gt; \u0026lt;httpErrors existingResponse=\u0026#34;PassThrough\u0026#34; /\u0026gt; \u0026lt;handlers\u0026gt; \u0026lt;add name=\u0026#34;iisnode\u0026#34; path=\u0026#34;server.js\u0026#34; verb=\u0026#34;*\u0026#34; modules=\u0026#34;iisnode\u0026#34; /\u0026gt; \u0026lt;/handlers\u0026gt; \u0026lt;iisnode node_env=\u0026#34;%node_env%\u0026#34; nodeProcessCountPerApplication=\u0026#34;1\u0026#34; maxConcurrentRequestsPerProcess=\u0026#34;1024\u0026#34; maxNamedPipeConnectionRetry=\u0026#34;100\u0026#34; namedPipeConnectionRetryDelay=\u0026#34;250\u0026#34; maxNamedPipeConnectionPoolSize=\u0026#34;512\u0026#34; maxNamedPipePooledConnectionAge=\u0026#34;30000\u0026#34; asyncCompletionThreadCount=\u0026#34;0\u0026#34; initialRequestBufferSize=\u0026#34;4096\u0026#34; maxRequestBufferSize=\u0026#34;65536\u0026#34; watchedFiles=\u0026#34;*.js;iisnode.yml\u0026#34; uncFileChangesPollingInterval=\u0026#34;5000\u0026#34; gracefulShutdownTimeout=\u0026#34;60000\u0026#34; loggingEnabled=\u0026#34;true\u0026#34; logDirectory=\u0026#34;C:\\Logs\u0026#34; debuggingEnabled=\u0026#34;true\u0026#34; debugHeaderEnabled=\u0026#34;false\u0026#34; debuggerPortRange=\u0026#34;5058-6058\u0026#34; debuggerPathSegment=\u0026#34;debug\u0026#34; maxLogFileSizeInKB=\u0026#34;128\u0026#34; maxTotalLogFileSizeInKB=\u0026#34;1024\u0026#34; maxLogFiles=\u0026#34;20\u0026#34; devErrorsEnabled=\u0026#34;true\u0026#34; flushResponse=\u0026#34;false\u0026#34; enableXFF=\u0026#34;false\u0026#34; promoteServerVars=\u0026#34;\u0026#34; configOverrides=\u0026#34;iisnode.yml\u0026#34; /\u0026gt; \u0026lt;rewrite\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;rule name=\u0026#34;rulename\u0026#34;\u0026gt; \u0026lt;match url=\u0026#34;/*\u0026#34; /\u0026gt; \u0026lt;action type=\u0026#34;Rewrite\u0026#34; url=\u0026#34;server.js\u0026#34; /\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/rules\u0026gt; \u0026lt;/rewrite\u0026gt; \u0026lt;/system.webServer\u0026gt; \u0026lt;/configuration\u0026gt; ","date":"August 8, 2019","hero":"/posts/2019-08-08-iisnode.js/blog17_IISNodejs.png","permalink":"https://akifmt.github.io/posts/2019-08-08-iisnode.js/","summary":"Node.js Deployment and Publishing on IIS - iisnode\nTested on Windows Server 2016 x64 and IIS 10.0. All the requirements for different versions are the same, only the appropriate version for iisnode should be installed.\nRequirements:\nWebPlatformInstaller: WebPlatformInstaller IIS URL Rewrite extension: IIS URL Rewrite extension Node.js: node.js iisnode v0.22.1 x64 : iisnode v0.22.1 x64 After installation, the project should have \u0026ldquo;web.config\u0026rdquo;. The following config example can also be used with Express Framework.","tags":["IIS","Node.js","Deployment","Publish","iisnode"],"title":"Node.js Deployment and Publishing on IIS - iisnode"},{"categories":["NodeJS","Different","Versions","Together","Using"],"contents":"\nCombining NodeJS Versions;\n# Setup: npm install -g nvmw # nvmw install nvmw install v8.12.0 # installation of the versions to be used nvmw use v8.12.0 # Use the specific version # Use: nvmw help # help nvmw install [version] # Version install [version] nvmw uninstall [version] # Uninstall version [version] nvmw use [version] # Change version [version] nvmw ls # List of installed versions NodeJS Releases List: Versions\nNPM: NPM Link\nGithub: Github Link\n","date":"February 10, 2019","hero":"/posts/2019-02-10-nodejsfarklisurumleribiraradakullanma/blog16_NodeJSFarkliSurumleriBiraradaKullanma.png","permalink":"https://akifmt.github.io/posts/2019-02-10-nodejsfarklisurumleribiraradakullanma/","summary":"Combining NodeJS Versions;\n# Setup: npm install -g nvmw # nvmw install nvmw install v8.12.0 # installation of the versions to be used nvmw use v8.12.0 # Use the specific version # Use: nvmw help # help nvmw install [version] # Version install [version] nvmw uninstall [version] # Uninstall version [version] nvmw use [version] # Change version [version] nvmw ls # List of installed versions NodeJS Releases List: Versions","tags":["NodeJS","Different","Versions","Together","Using"],"title":"Combining NodeJS Versions"},{"categories":["Google","Cloud","Ubuntu",16.04,"VNC","Server"],"contents":"\nVNC Server on Google Cloud Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade # Setup: sudo apt install xfce4 xfce4-goodies tightvncserver vncserver vncserver -kill :1 mv ~/.vnc/xstartup ~/.vnc/xstartup.bak nano ~/.vnc/xstartup xstartup content: #!/bin/bash xrdb $HOME/.Xresources startxfce4 \u0026amp; sudo chmod +x ~/.vnc/xstartup vncserver To connect via Windows: Download link\n","date":"September 21, 2017","hero":"/posts/2017-09-21-googlecloudubuntuvnc/blog15_GoogleCloudUbuntuVNC.jpg","permalink":"https://akifmt.github.io/posts/2017-09-21-googlecloudubuntuvnc/","summary":"VNC Server on Google Cloud Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade # Setup: sudo apt install xfce4 xfce4-goodies tightvncserver vncserver vncserver -kill :1 mv ~/.vnc/xstartup ~/.vnc/xstartup.bak nano ~/.vnc/xstartup xstartup content: #!/bin/bash xrdb $HOME/.Xresources startxfce4 \u0026amp; sudo chmod +x ~/.vnc/xstartup vncserver To connect via Windows: Download link","tags":["Google","Cloud","Ubuntu",16.04,"VNC","Server"],"title":"VNC Server on Google Cloud Ubuntu"},{"categories":["Torch","OpenCV Installation and Testing"],"contents":"\nOpenCV and Torch installation on Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade shutdown -r 0 sudo apt-get install git #Torch Installation #Run in terminal in order: git clone https://github.com/torch/distro.git ~/torch --recursive cd ~/torch; bash install-deps; ./install.sh source ~/.bashrc source ~/.profile #OpenCV Installation: sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev 2015-12-21 VERSION 3.1 OpenCV for Linux/Mac cd ~ wget https://github.com/Itseez/opencv/archive/3.1.0.zip --no-check-certificate unzip 3.1.0.zip cd opencv-3.1.0 mkdir build cd build cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_V4L=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D WITH_QT=ON -D WITH_GTK=ON -D WITH_OPENGL=ON .. make sudo make install While in the openCV build folder; source ~/.profile luarocks install cv luarocks install camera luarocks install ffmpeg /// If a luarocks package installation error occurs, run the following line to fix it and install the packages again: /// sudo rm -rf ~/.cache/luarocks IDE: Download link\nKurulumu Test etmek için: Download link , Github link\n","date":"May 27, 2017","hero":"/posts/2017-05-27-torchveopencvkurulum/blog14_torchVeopenCVKurulum.png","permalink":"https://akifmt.github.io/posts/2017-05-27-torchveopencvkurulum/","summary":"OpenCV and Torch installation on Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade shutdown -r 0 sudo apt-get install git #Torch Installation #Run in terminal in order: git clone https://github.com/torch/distro.git ~/torch --recursive cd ~/torch; bash install-deps; ./install.sh source ~/.bashrc source ~/.profile #OpenCV Installation: sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev 2015-12-21 VERSION 3.1 OpenCV for Linux/Mac cd ~ wget https://github.com/Itseez/opencv/archive/3.1.0.zip --no-check-certificate unzip 3.1.0.zip cd opencv-3.","tags":["Torch","OpenCV Installation and Testing"],"title":"Torch, OpenCV Installation and Test"},{"categories":["epub calibre"],"contents":"\nThe cover pages of some e-books do not appear on other devices due to incompatibility. The solution for this is caliber. It provides the opportunity to edit not only the cover page but also the content. Download link\nTo edit the cover page; It will be enough to edit the following line with the \u0026ldquo;Edit Metadata\u0026rdquo; option or add it if it does not exist.\n\u0026lt;item id=\u0026#34;cover_image\u0026#34; href=\u0026#34;cover.jpg\u0026#34; media-type=\u0026#34;image/jpeg\u0026#34;\u0026gt; ","date":"May 2, 2017","hero":"/posts/2017-05-02-epubcover/blog13_epub.png","permalink":"https://akifmt.github.io/posts/2017-05-02-epubcover/","summary":"\nThe cover pages of some e-books do not appear on other devices due to incompatibility. The solution for this is caliber. It provides the opportunity to edit not only the cover page but also the content. Download link\nTo edit the cover page; It will be enough to edit the following line with the \u0026ldquo;Edit Metadata\u0026rdquo; option or add it if it does not exist.\n\u0026lt;item id=\u0026#34;cover_image\u0026#34; href=\u0026#34;cover.jpg\u0026#34; media-type=\u0026#34;image/jpeg\u0026#34;\u0026gt; ","tags":["epub calibre"],"title":"Edit EPub Cover"},{"categories":["Game Theory","Prisoner Dilemma","Nash Equilibrium"],"contents":"\nGet two people caught. If one testifies against the other and the other remains silent, the witness will be released, and the party who chooses to remain silent will be sentenced to 20 years in prison. If both remain silent, they will be sentenced to 1 year each. If both testify against each other, they will each be sentenced to 5 years.\nThe optimal option of the two is to keep both silent. The player, who is unaware of the other party\u0026rsquo;s decision, will not remain silent and will testify against the other party, not risking the possibility of serving 20 years in prison. By testifying against the other party, he will consent to a shorter prison sentence of 5 years or be released. Here the player will aim at minimizing his loss (maximizing his win). It will be inevitable that the other party will testify by acting rationally under the same conditions.\nThe sole aim of the players is to maximize their own winnings, independently of the other player. Here, the Nash Equilibrium is formed when two individuals act by considering the other\u0026rsquo;s movement and choose the best for their own situation instead of maximum gain.\n","date":"March 16, 2017","hero":"/posts/2017-03-16-prisonersdilemmavenashdengesi/blog11_prisoners-dilemma-kural-tablosu.jpg","permalink":"https://akifmt.github.io/posts/2017-03-16-prisonersdilemmavenashdengesi/","summary":"Get two people caught. If one testifies against the other and the other remains silent, the witness will be released, and the party who chooses to remain silent will be sentenced to 20 years in prison. If both remain silent, they will be sentenced to 1 year each. If both testify against each other, they will each be sentenced to 5 years.\nThe optimal option of the two is to keep both silent.","tags":["Game Theory","Prisoner Dilemma","Nash Equilibrium"],"title":"Game Theory - Prisoner's Dilemma and Nash Equilibrium"},{"categories":["shields.io"],"contents":"\nA tool for the ReadMe files of projects to display the project status in a nicer way. shields.io supports many tools used for project tracking. Travis, Jenkins and even Github allow badges to be added up to the release status of the project on SourceForce.\n","date":"March 16, 2017","hero":"/posts/2017-03-19-shields.io/blog12_shields.io.png","permalink":"https://akifmt.github.io/posts/2017-03-19-shields.io/","summary":"A tool for the ReadMe files of projects to display the project status in a nicer way. shields.io supports many tools used for project tracking. Travis, Jenkins and even Github allow badges to be added up to the release status of the project on SourceForce.","tags":["shields.io"],"title":"shields.io"},{"categories":["bash"],"contents":"\nActive folder: pwd Appearance: ls \u0026#39;Detailed View Parameters: -l *detailed* -lrt *detailed* -d *folder* -r *read* -w *write* -x *execute*\u0026#39; Active Folder Change: cd \u0026lt;folder name\u0026gt; File Creation: touch \u0026lt;filename\u0026gt; Displayed: ctrl+k \u0026#39;delete to the right\u0026#39; echo \u0026#34;hello world\u0026#34; echo \u0026#34;hello coders\u0026#34; \u0026gt; filename \u0026#39;Send output to file\u0026#39; echo $? \u0026#39;Returns the result of the last operation (0 successful)\u0026#39; cat filename \u0026#39;prints file contents\u0026#39; more filename \u0026#39;prints file contents\u0026#39; less filename \u0026#39;prints file contents\u0026#39; nano filename \u0026#39;opens with nano text editor\u0026#39; vim filename \u0026#39;opens with vim text editor\u0026#39; head -n 5 output-1.txt \u0026#39;show first 5 lines\u0026#39; tail -n 5 output-1.txt \u0026#39;show last 5 lines\u0026#39; tail -f log-file.txt \u0026#39;prints the last lines and follows the new incoming lines\u0026#39; Creating Folder: mkdir foldername \u0026#39;Creates folder\u0026#39; Run by Sending or Receiving Content: ./prog \u0026lt; input-1.txt \u0026#39;Executes the content of input-1 by sending it to the prog.\u0026#39; ./my-prog \u0026lt; input-1.txt \u0026gt; output-1.txt \u0026#39;assigns output to output\u0026#39; ./my-prog 12 2\u0026gt; output-1.txt \u0026#39;redirects input from stderr to output\u0026#39; ./my-prog \u0026lt; input-1.txt \u0026gt; all-output.txt 2\u0026gt;\u0026amp;1 \u0026#39;stderr, redirect to stdoutput\u0026#39; echo \u0026#34;asdasd\u0026#34; \u0026gt;\u0026gt; log-file.txt \u0026#39;add to end of file\u0026#39; Compilation: gcc -o my-prog my-prog.c \u0026#39;compiles with gcc.\u0026#39; Search in Process: ps aux | grep my-prog \u0026#39;do not search among running processes\u0026#39; Process Operations: \u0026#39;All processes start with: 0:stdinput 1:stdoutput 2:stderror\u0026#39; \u0026#39;The system proc folder where processes are kept.\u0026#39; \u0026#39; ctrl+c : interrupt (sigint) (sigterm) (sighup) -\u0026gt; updates the configuration (sigkill) -\u0026gt; kills without question ctrl+l : clear terminal does the action ctrl+d : (end of stream) kills the active process running \u0026#39; kill -l\t\u0026#39;shows list of signals for kill\u0026#39; kill -INT 12334\t\u0026#39;sends sigint signal\u0026#39; kill -TERM 12334\t\u0026#39;kills with sigterm signal\u0026#39; cat cmdline \u0026#39;running location\u0026#39; cat environ \u0026#39;process in environment variables\u0026#39; cat limits \u0026#39;process limits\u0026#39; top \u0026#39;shows transactions momentarily\u0026#39; htop \u0026#39;shows by updating\u0026#39; Path Operations: echo $PATH\t\u0026#39;path content\u0026#39; export PATH=$PATH:/home/vm/deneme\t\u0026#39;add new directory to end of path\u0026#39; Device Transactions: ls /dev \u0026#39;shows all devices\u0026#39; ls -lrt /dev/null \u0026#39;sends output to null\u0026#39; Data transfer: curl http://akifmt.github.io \u0026#39;downloads\u0026#39; curl http://akifmt.github.io \u0026gt; /dev/null \u0026#39;downloads results to null\u0026#39; curl -s http://akifmt.github.io \u0026gt; /dev/null\t\u0026#39;downloads in silent mode, sends results to null\u0026#39; curl http://akifmt.github.io \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\t\u0026#39;forward also incoming from stderr\u0026#39; curl -s https://demo.consul.io/v1/catalog/services \u0026#39;download in silent mode\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty \u0026#39;downloads in silent mode\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | grep Address \u0026#39;downloads in silent mode, finds Address lines\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | jq \u0026#39;.[0].Address\u0026#39; \u0026#39;Retrieves the first of the address part\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | jq -r \u0026#39;.[].Address\u0026#39; \u0026#39;Retrieves all Address parts\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | jq -r \u0026#39;.[].Address\u0026#39; | while read serverAddr; do curl -s $serverAddr \u0026gt; $serverAddr.txt; done \u0026#39;Finds all Address lines, sends them to the right, creates a file based on the Address names\u0026#39; File Operations: echo \u0026#34;asd,qwe,qwwww\u0026#34; | cut -d, -f2 \u0026#39;takes the 2nd word after\u0026#39; echo \u0026#34;asd;qwe;qwwww\u0026#34; | cut -d\\; -f2 \u0026#39;; takes the 2nd word after\u0026#39; echo \u0026#34;asd,qwe,qwwww\u0026#34; | awk -F, \u0026#39;{print $2}\u0026#39; \u0026#39;takes the 2nd word after\u0026#39; ls -lrt | awk \u0026#39;{print $9}\u0026#39; \u0026#39;9. print columns\u0026#39; ls -lrt | cat \u0026#39;pipe outputs to the right one\u0026#39; wc -l \u0026#39;line counts\u0026#39; ls -lrt | wc -l \u0026#39;sends results from ls to the right and counts lines\u0026#39; find . -name my-prog \u0026#39;finds names starting with my-prog\u0026#39; find . -type f \u0026#39;finds files\u0026#39; find . -name \u0026#34;*.txt\u0026#34; \u0026#39;finds txt extension\u0026#39; find -name \u0026#34;*.txt\u0026#34; | while read filename; do echo $filename; done \u0026#39;finds txt, sends it to the server, prints it as filename\u0026#39; find -name \u0026#34;*.txt\u0026#34; | while read filename; do rm $filename; done \u0026#39;delete files found\u0026#39; dd if=/dev/zero of=zero-file.txt bs=512 count=2 \u0026#39;Creates 2x512KB empty file. \u0026#39; hexdump zero-file.txt \u0026#39;Displays in hex and abbreviated repetitive parts.\u0026#39; hexdump -v zero-file.txt \u0026#39;shows all without abbreviations\u0026#39; dd if=/dev/urandom of=random-file.txt bs=512 count=4 \u0026#39;creates 4x512KB file with random value\u0026#39; Operations on CPU: dd if=/dev/zero of=null \u0026#39;generates zero to send null to device (uncontrolled cpu load)\u0026#39; stress-ng -c 1 -l 40 \u0026#39;40% load on 1 CPU\u0026#39; stress-ng -c 0 -l 40 \u0026#39;loads 40% on all CPUs\u0026#39; Network Transactions: ifconfig \u0026#39;shows network devices and connections\u0026#39; route -n \u0026#39;shows all access\u0026#39; sudo wondershaper ens33 512 512 \u0026#39;Limits downloading and sending 512Kpbs\u0026#39; sudo wondershaper ens33 clear \u0026#39;removes limits\u0026#39; Satır Sonları (lineending): OS Desc Code Linux LF (line feed) (\\n) Unix CR (carriage return) (\\r) Windows CRLF (carriage return line feed) \\r\\n ","date":"February 24, 2017","hero":"/posts/2017-02-24-linuxbashkomutlari/blog10_bash.png","permalink":"https://akifmt.github.io/posts/2017-02-24-linuxbashkomutlari/","summary":"Active folder: pwd Appearance: ls \u0026#39;Detailed View Parameters: -l *detailed* -lrt *detailed* -d *folder* -r *read* -w *write* -x *execute*\u0026#39; Active Folder Change: cd \u0026lt;folder name\u0026gt; File Creation: touch \u0026lt;filename\u0026gt; Displayed: ctrl+k \u0026#39;delete to the right\u0026#39; echo \u0026#34;hello world\u0026#34; echo \u0026#34;hello coders\u0026#34; \u0026gt; filename \u0026#39;Send output to file\u0026#39; echo $? \u0026#39;Returns the result of the last operation (0 successful)\u0026#39; cat filename \u0026#39;prints file contents\u0026#39; more filename \u0026#39;prints file contents\u0026#39; less filename \u0026#39;prints file contents\u0026#39; nano filename \u0026#39;opens with nano text editor\u0026#39; vim filename \u0026#39;opens with vim text editor\u0026#39; head -n 5 output-1.","tags":["bash"],"title":"Linux Bash Commands"},{"categories":["vmware hyper v"],"contents":"\nTo turn off Hyper-V; As administrator on cmd: bcdedit /set hypervisorlaunchtype off vmware available after reboot.\nTo turn Hyper-V back on As administrator on cmd: bcdedit /set hypervisorlaunchtype auto Hyper-V is available upon reboot.\n","date":"February 22, 2017","hero":"/posts/2017-02-22-hypervmwarebirlikte/blog9_vmwarehyperv.png","permalink":"https://akifmt.github.io/posts/2017-02-22-hypervmwarebirlikte/","summary":"To turn off Hyper-V; As administrator on cmd: bcdedit /set hypervisorlaunchtype off vmware available after reboot.\nTo turn Hyper-V back on As administrator on cmd: bcdedit /set hypervisorlaunchtype auto Hyper-V is available upon reboot.","tags":["vmware hyper v"],"title":"VMware and Hyper-V Combine"},{"categories":["Agile"],"contents":"\nAgile Methodology is a practice-based method for modeling and documenting software systems effectively and efficiently.\nSoftware projects are faced with the danger of failure due to improper use of resources, wrong prioritization and inaccurate understanding of customer demands throughout their lifecycle. According to The Standish Group\u0026rsquo;s 2009 Chaos Report, software projects fail at a rate of 68% worldwide. This has led large companies in Europe and America to try various methods to produce projects with higher productivity, and most companies have adopted Agile software development approaches, which they find most successful in management and practice.\nIncreasing when Agile approaches are applied;\nproject productivity, the ability of the project to adapt quickly to changes, project quality and speed to market of the project In line with this, the success rates of the projects have been increased to 80% and project profitability has been increased with the significant competitive advantage obtained.\nSource: www.acm-software.com/agile\n","date":"February 20, 2017","hero":"/posts/2017-02-20-agile/blog8_agile.jpg","permalink":"https://akifmt.github.io/posts/2017-02-20-agile/","summary":"Agile Methodology is a practice-based method for modeling and documenting software systems effectively and efficiently.\nSoftware projects are faced with the danger of failure due to improper use of resources, wrong prioritization and inaccurate understanding of customer demands throughout their lifecycle. According to The Standish Group\u0026rsquo;s 2009 Chaos Report, software projects fail at a rate of 68% worldwide. This has led large companies in Europe and America to try various methods to produce projects with higher productivity, and most companies have adopted Agile software development approaches, which they find most successful in management and practice.","tags":["Agile"],"title":"Agile"},{"categories":["Docker"],"contents":"What is Docker Docker is an open source project that deploy application. It works like a virtual machine, but better. Using a linux instance, it isolates itself from OS and works more secure. Docker defines itself like that on official website;\nDocker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries – anything that can be installed on a server. This guarantees that the software will always run the same, regardless of its environment.\nFor more information, www.docker.com\n","date":"November 24, 2016","hero":"/posts/2016-11-24-docker/blog7_docker.png","permalink":"https://akifmt.github.io/posts/2016-11-24-docker/","summary":"What is Docker Docker is an open source project that deploy application. It works like a virtual machine, but better. Using a linux instance, it isolates itself from OS and works more secure. Docker defines itself like that on official website;\nDocker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries – anything that can be installed on a server.","tags":["Docker"],"title":"What is Docker?"},{"categories":["Android 7 Nougat"],"contents":"\nNew features\nMulti-window / running two apps on the same screen (The most important feature) New notification center Revamped settings menu Notifications settings have been enriched. We will now be able to prevent every notification from appearing. Added the ability to go to the relevant menu of the settings by long pressing the icons in the notification Refreshing battery graph ","date":"November 2, 2016","hero":"/posts/2016-11-02-android7nougat/blog6_android7n_teaser.png","permalink":"https://akifmt.github.io/posts/2016-11-02-android7nougat/","summary":"\nNew features\nMulti-window / running two apps on the same screen (The most important feature) New notification center Revamped settings menu Notifications settings have been enriched. We will now be able to prevent every notification from appearing. Added the ability to go to the relevant menu of the settings by long pressing the icons in the notification Refreshing battery graph ","tags":["Android 7 Nougat"],"title":"Android 7 Nougat"},{"categories":["monte carlo metodu"],"contents":"\nNedir: Rastgele sayılar kullanılarak sistemlerin modellenmesinde kullanılabilir. Sistemin kesin sonucunun olduğu bazı durumlarda, veya olmadığı tüm durumlarda uygulanabilir. Örnek sayısı doğru sonuçlar elde etmede büyük önem taşımaktadır. Pi sayısı hesaplama, yazı tura ve zar hesaplaması örnek gösterilebilir.\nÖrnek: C ile Yazı-Tura double rastgele(){ double r = (double) rand()/RAND_MAX; return r; } int main() { int i, tura, yazi, n; double r, p; printf(\u0026#34;deney sayisini girin: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); srand( time(NULL) ); for(tura=0, i=1; i\u0026lt;=n; i++){ r = rastgele(); if(r\u0026lt;0.5) tura++; } p = (double) tura/n; yazi = n-tura; printf(\u0026#34;tura sayisi: %d\\n\u0026#34;,tura); printf(\u0026#34;yazi sayisi: %d\\n\u0026#34;,yazi); printf(\u0026#34;Olasiliklar: %lf %lf\\n\u0026#34;,p, 1.0-p); return 0; } ","date":"October 9, 2016","hero":"/posts/2016-10-09-montecarlometodu/blog5_montecarlometodu.png","permalink":"https://akifmt.github.io/posts/2016-10-09-montecarlometodu/","summary":"Nedir: Rastgele sayılar kullanılarak sistemlerin modellenmesinde kullanılabilir. Sistemin kesin sonucunun olduğu bazı durumlarda, veya olmadığı tüm durumlarda uygulanabilir. Örnek sayısı doğru sonuçlar elde etmede büyük önem taşımaktadır. Pi sayısı hesaplama, yazı tura ve zar hesaplaması örnek gösterilebilir.\nÖrnek: C ile Yazı-Tura double rastgele(){ double r = (double) rand()/RAND_MAX; return r; } int main() { int i, tura, yazi, n; double r, p; printf(\u0026#34;deney sayisini girin: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); srand( time(NULL) ); for(tura=0, i=1; i\u0026lt;=n; i++){ r = rastgele(); if(r\u0026lt;0.","tags":["monte carlo metodu"],"title":"Monte Carlo Method"},{"categories":["Raspberry Pi","Remote Desktop Connection"],"contents":"\nProblem: Raspbery Pi Remote Connection TR Keyboard Not Recognizing Solution: missing km-041f.ini file\nCopy the km-041f.ini file to the /etc/xrdp/ directory on the Raspberry Pi. When xrdp is restarted, TR characters are no longer a problem.\nThe thing to note is that you must access the directory as root.\nThe step I followed; sudo pcmanfm on RasPi Copy the km-041f.ini file to /etc/xrdp/.\nsudo service xrdp restart\nNote: For those who have problems finding the file on the net, I downloaded it from this repo: Link ","date":"September 18, 2016","hero":"/posts/2016-09-18-raspberrypiilerdcbaglantisi/blog4_rasPiRDC.png","permalink":"https://akifmt.github.io/posts/2016-09-18-raspberrypiilerdcbaglantisi/","summary":"\nProblem: Raspbery Pi Remote Connection TR Keyboard Not Recognizing Solution: missing km-041f.ini file\nCopy the km-041f.ini file to the /etc/xrdp/ directory on the Raspberry Pi. When xrdp is restarted, TR characters are no longer a problem.\nThe thing to note is that you must access the directory as root.\nThe step I followed; sudo pcmanfm on RasPi Copy the km-041f.ini file to /etc/xrdp/.\nsudo service xrdp restart\nNote: For those who have problems finding the file on the net, I downloaded it from this repo: Link ","tags":["Raspberry Pi","Remote Desktop Connection"],"title":"Raspberry Pi Remote Desktop Turkish Keyboard Problem"},{"categories":["remote desktop","amazon aws","microsoft azure"],"contents":"\nSince VPS devices on AWS or Azure do not have a real sound card, it is not possible to receive sound on these devices. The solution for this is VA, that is, virtual audio. Our convenient application solution is solved with VAC installation. The application creates a virtual sound driver and directs the sound to our device.\nProblem: Voice over VPS Solution: Virtual Audio Cable 4.15 installation and Setup\nInstall \u0026ldquo;Virtual Audio Cable 4.15\u0026rdquo; that I tested on VPS.\nRDP-Tcp -\u0026gt; client services -\u0026gt; audio in \u0026ldquo;tsconfig.msc\u0026rdquo; on VPS remove the option. Reset VPS.\nAfter this step, the sound is ready.\nDownload link:\nGoogle -\u0026gt; Virtual Audio Cable 4.15 ","date":"August 22, 2016","hero":"/posts/2016-08-22-rdcileawsveazurevpsuzerindevacileses/blog3_vac_teaser.png","permalink":"https://akifmt.github.io/posts/2016-08-22-rdcileawsveazurevpsuzerindevacileses/","summary":"Since VPS devices on AWS or Azure do not have a real sound card, it is not possible to receive sound on these devices. The solution for this is VA, that is, virtual audio. Our convenient application solution is solved with VAC installation. The application creates a virtual sound driver and directs the sound to our device.\nProblem: Voice over VPS Solution: Virtual Audio Cable 4.15 installation and Setup","tags":["remote desktop","amazon aws","microsoft azure"],"title":"Application Sounds on Amazon AWS and Azure with Remote Desktop"},{"categories":["INVICTUS"],"contents":"\nThe company works on cyber security and security training. I also contacted my friend\u0026rsquo;s reference. The sincerity I saw from day one surprised me. I saw a full family relationship in the company, from management to employees. With the experienced team, they included them at every point by providing training on cyber security at a high-level security level, starting from scratch. The company is experienced in cyber security and even works towards becoming a world brand. The training activities of the company in cyber security are also successful enough to be called the first in their field. Thank you to everyone from the company\u0026rsquo;s management to its employees. I would suggest those interested in cyber security to follow the link. Company information is below.\nwww.invictuseurope.com Contact: www.invictuseurope.com/iletisim Education: egitim.invictuseurope.com\n","date":"August 3, 2016","hero":"/posts/2016-08-03-invictusbilisimguvenlikstajyapmak/blog2_invictus_teaser.png","permalink":"https://akifmt.github.io/posts/2016-08-03-invictusbilisimguvenlikstajyapmak/","summary":"The company works on cyber security and security training. I also contacted my friend\u0026rsquo;s reference. The sincerity I saw from day one surprised me. I saw a full family relationship in the company, from management to employees. With the experienced team, they included them at every point by providing training on cyber security at a high-level security level, starting from scratch. The company is experienced in cyber security and even works towards becoming a world brand.","tags":["INVICTUS"],"title":"INVICTUS, Internship in IT Security"},{"categories":["pokemon go","what is it"],"contents":"A game that can be played on mobile platforms. The biggest innovation and feature is virtualized reality technology. Using real location information, it provides a better player experience, catching 722 Pokemon characters, trades and battles. The official introduction is as follows:\n","date":"July 10, 2016","hero":"/posts/2016-07-10-pokemongooynamak/blog1_pokemon_go_logo.png","permalink":"https://akifmt.github.io/posts/2016-07-10-pokemongooynamak/","summary":"A game that can be played on mobile platforms. The biggest innovation and feature is virtualized reality technology. Using real location information, it provides a better player experience, catching 722 Pokemon characters, trades and battles. The official introduction is as follows:","tags":["pokemon go","what is it"],"title":"Playing Pokemon GO!"},{"categories":null,"contents":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/projects/project1/","summary":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","tags":null,"title":"project1en"},{"categories":null,"contents":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/projects/project2/","summary":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","tags":null,"title":"project2en"}]