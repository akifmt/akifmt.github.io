[{"categories":null,"contents":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/notes/bash/basic/","summary":" Variable NAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME} Condition if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi ","tags":null,"title":"Bash Variables"},{"categories":null,"contents":" Startup.cs No image display bug fix appsettings.json Uploading Image ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/notes/dotnet/gists/","summary":" Startup.cs No image display bug fix appsettings.json Uploading Image ","tags":null,"title":"Dotnet"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Upgrade Radzen 4 to 5"],"contents":" Blazor Radzen .NET 8 Upgrade Radzen 4 to 5 The process of upgrading the Radzen.Blazor package from version 4 to version 5 in a Blazor project targeting .NET 8.0. This upgrade is essential to leverage the latest features, improvements, and bug fixes provided by Radzen.\nInformation\nRadzen Blazor Components v5 Changelog Track and review changes to Radzen Blazor Components v5.\nMore: https://blazor.radzen.com/changelog?theme=default\n.csproj Update NuGet packages In the updated .csproj file, the version of the Radzen.Blazor package has been changed from 4 to 5. This modification ensures that the project now references the latest version of the Radzen.Blazor package.\n(OLD) .csproj\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net8.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; ... \u0026lt;PackageReference Include=\u0026#34;Radzen.Blazor\u0026#34; Version=\u0026#34;4.34.0\u0026#34; /\u0026gt; ... \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; (NEW) .csproj\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net8.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; ... \u0026lt;PackageReference Include=\u0026#34;Radzen.Blazor\u0026#34; Version=\u0026#34;5.0.8\u0026#34; /\u0026gt; ... \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt; App.razor he section of the App.razor file responsible for linking CSS files. In the old version, the CSS file default-base.css from Radzen was referenced using a relative path. However, in the new version, the reference to the CSS file has been updated to use the correct path.\n(OLD) App.razor\n... \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bootstrap/bootstrap.min.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/default-base.css\u0026#34;\u0026gt; ... (NEW) App.razor\n... \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/default-base.css\u0026#34; /\u0026gt; ... MainLayout.razor MainLayout.razor file before and after the upgrade from Radzen version 4 to version 5. The structure of the file remains the same, with the inclusion of Radzen components for Dialog, Notification, Tooltip, ContextMenu, and the new RadzenComponents.\n(OLD) MainLayout.razor\n... @inherits LayoutComponentBase @inject IJSRuntime JSRuntime @inject NavigationManager NavigationManager @inject DialogService DialogService @inject ContextMenuService ContextMenuService @inject TooltipService TooltipService @inject NotificationService NotificationService \u0026lt;RadzenDialog /\u0026gt; \u0026lt;RadzenNotification /\u0026gt; \u0026lt;RadzenTooltip /\u0026gt; \u0026lt;RadzenContextMenu /\u0026gt; ... (NEW) MainLayout.razor\n... @inherits LayoutComponentBase @inject IJSRuntime JSRuntime @inject NavigationManager NavigationManager @inject DialogService DialogService @inject ContextMenuService ContextMenuService @inject TooltipService TooltipService @inject NotificationService NotificationService \u0026lt;RadzenDialog /\u0026gt; \u0026lt;RadzenNotification /\u0026gt; \u0026lt;RadzenTooltip /\u0026gt; \u0026lt;RadzenContextMenu /\u0026gt; \u0026lt;RadzenComponents /\u0026gt; ... Upgrading Radzen components from version 4 to version 5 is essential to leverage the latest features and improvements offered by Radzen. By following the provided code examples and ensuring that all necessary components are included, you can successfully upgrade your Blazor application to use Radzen version 5 seamlessly.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenNet8UpgradeRadzen4to5\n","date":"August 11, 2024","hero":"/dotnet/2024-08-11-blazor-radzen-.net8-upgrade-radzen-4-to-5/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-08-11-blazor-radzen-.net8-upgrade-radzen-4-to-5/","summary":"Blazor Radzen .NET 8 Upgrade Radzen 4 to 5 The process of upgrading the Radzen.Blazor package from version 4 to version 5 in a Blazor project targeting .NET 8.0. This upgrade is essential to leverage the latest features, improvements, and bug fixes provided by Radzen.\nInformation\nRadzen Blazor Components v5 Changelog Track and review changes to Radzen Blazor Components v5.\nMore: https://blazor.radzen.com/changelog?theme=default\n.csproj Update NuGet packages In the updated .","tags":["dotnet8",".NET8","Blazor","Radzen","Upgrade Radzen 4 to 5"],"title":"Blazor Radzen .NET 8 Upgrade Radzen 4 to 5"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Role-based Authorization","Identity"],"contents":" Blazor Radzen .NET 8 Role-based Authorization with Identity Blazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows you to write code that runs on the client-side in the browser.\nRadzen: Radzen is a low-code development tool for building web applications. It provides a visual interface for designing UI components and generating code.\n.NET 8: .NET 8 is the latest version of the .NET framework, which is a software development platform for building applications.\nRole-based Authorization: Role-based authorization is a security mechanism that allows you to control access to certain parts of your application based on the roles assigned to users. Users with specific roles are granted access to specific resources or actions.\nIdentity: Identity is a membership system in ASP.NET that provides user authentication and authorization functionality. It allows you to manage user accounts, roles, and permissions.\nDbContext: The DbContext class is a fundamental part of Entity Framework, responsible for managing the connection and communication with the database. It provides an abstraction layer for interacting with the database and performing CRUD operations on the entities.\nClaimsPrincipal: Represents the user's identity and associated claims.\nAuthenticationStateProvider: Provides access to the current authentication state.\nTest Users:\nRole Username Password Admin admin@admin.com 123456 User register with any email register with any password BlazorAppRadzenRoleBasedAuthwithIdentity.csproj BlazorAppRadzenRoleBasedAuthwithIdentity.csproj\n... \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;8.0.5\u0026#34; /\u0026gt; ... One fundamental component in this ecosystem is Microsoft.AspNetCore.Identity.EntityFrameworkCore. This package plays a pivotal role in managing user authentication and authorization within a Blazor application.\nProgram.cs Program.cs file in a Blazor Radzen application. It configures the services and options required for role-based authorization using Identity.\nProgram.cs\n... // Add services to the container. builder.Services.AddCascadingAuthenticationState(); builder.Services.AddScoped\u0026lt;IdentityUserAccessor\u0026gt;(); builder.Services.AddScoped\u0026lt;IdentityRedirectManager\u0026gt;(); builder.Services.AddScoped\u0026lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider\u0026gt;(); builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = IdentityConstants.ApplicationScheme; options.DefaultSignInScheme = IdentityConstants.ExternalScheme; }); builder.Services.AddDbContext\u0026lt;ApplicationDbContext\u0026gt;(options =\u0026gt; options.UseInMemoryDatabase(\u0026#34;ConnectionInMemory\u0026#34;)); builder.Services.AddDatabaseDeveloperPageExceptionFilter(); builder.Services.AddIdentity\u0026lt;ApplicationUser, ApplicationRole\u0026gt;() .AddSignInManager\u0026lt;SignInManager\u0026lt;ApplicationUser\u0026gt;\u0026gt;() .AddUserStore\u0026lt;UserStore\u0026lt;ApplicationUser, ApplicationRole, ApplicationDbContext, string, ApplicationUserClaim, ApplicationUserRole, ApplicationUserLogin, ApplicationUserToken, ApplicationRoleClaim\u0026gt;\u0026gt;() .AddRoleStore\u0026lt;RoleStore\u0026lt;ApplicationRole, ApplicationDbContext, string, ApplicationUserRole, ApplicationRoleClaim\u0026gt;\u0026gt;() .AddUserManager\u0026lt;UserManager\u0026lt;ApplicationUser\u0026gt;\u0026gt;() .AddRoles\u0026lt;ApplicationRole\u0026gt;() .AddRoleManager\u0026lt;RoleManager\u0026lt;ApplicationRole\u0026gt;\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApplicationDbContext\u0026gt;() .AddDefaultTokenProviders(); ... ApplicationDbContext.cs The ApplicationDbContext.cs file is a class that extends the IdentityDbContext class, which is provided by the Identity framework. It defines the database context for the application and includes the configuration for the database tables and their relationships.\nApplicationDbContext.cs\n... public DbSet\u0026lt;ApplicationUser\u0026gt; ApplicationUsers =\u0026gt; Set\u0026lt;ApplicationUser\u0026gt;(); public DbSet\u0026lt;ApplicationRole\u0026gt; ApplicationRoles =\u0026gt; Set\u0026lt;ApplicationRole\u0026gt;(); public DbSet\u0026lt;ApplicationUserClaim\u0026gt; ApplicationUserClaims =\u0026gt; Set\u0026lt;ApplicationUserClaim\u0026gt;(); public DbSet\u0026lt;ApplicationUserRole\u0026gt; ApplicationUserRoles =\u0026gt; Set\u0026lt;ApplicationUserRole\u0026gt;(); public DbSet\u0026lt;ApplicationUserLogin\u0026gt; ApplicationUserLogins =\u0026gt; Set\u0026lt;ApplicationUserLogin\u0026gt;(); public DbSet\u0026lt;ApplicationRoleClaim\u0026gt; ApplicationRoleClaims =\u0026gt; Set\u0026lt;ApplicationRoleClaim\u0026gt;(); public DbSet\u0026lt;ApplicationUserToken\u0026gt; ApplicationUserTokens =\u0026gt; Set\u0026lt;ApplicationUserToken\u0026gt;(); protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); //models modelBuilder.Entity\u0026lt;ApplicationUser\u0026gt;(b =\u0026gt; { // Primary key b.HasKey(u =\u0026gt; u.Id); // Indexes for \u0026#34;normalized\u0026#34; username and email, to allow efficient lookups b.HasIndex(u =\u0026gt; u.NormalizedUserName).HasDatabaseName(\u0026#34;UserNameIndex\u0026#34;).IsUnique(); b.HasIndex(u =\u0026gt; u.NormalizedEmail).HasDatabaseName(\u0026#34;EmailIndex\u0026#34;); // Maps to the AspNetUsers table b.ToTable(\u0026#34;AspNetUsers\u0026#34;); // A concurrency token for use with the optimistic concurrency checking b.Property(u =\u0026gt; u.ConcurrencyStamp).IsConcurrencyToken(); // Limit the size of columns to use efficient database types b.Property(u =\u0026gt; u.UserName).HasMaxLength(256); b.Property(u =\u0026gt; u.NormalizedUserName).HasMaxLength(256); b.Property(u =\u0026gt; u.Email).HasMaxLength(256); b.Property(u =\u0026gt; u.NormalizedEmail).HasMaxLength(256); // The relationships between User and other entity types // Note that these relationships are configured with no navigation properties // Each User can have many UserClaims b.HasMany\u0026lt;ApplicationUserClaim\u0026gt;().WithOne().HasForeignKey(uc =\u0026gt; uc.UserId).IsRequired(); // Each User can have many UserLogins b.HasMany\u0026lt;ApplicationUserLogin\u0026gt;().WithOne().HasForeignKey(ul =\u0026gt; ul.UserId).IsRequired(); // Each User can have many UserTokens b.HasMany\u0026lt;ApplicationUserToken\u0026gt;().WithOne().HasForeignKey(ut =\u0026gt; ut.UserId).IsRequired(); // Each User can have many entries in the UserRole join table b.HasMany\u0026lt;ApplicationUserRole\u0026gt;().WithOne().HasForeignKey(ur =\u0026gt; ur.UserId).IsRequired(); }); modelBuilder.Entity\u0026lt;ApplicationUserClaim\u0026gt;(b =\u0026gt; { // Primary key b.HasKey(uc =\u0026gt; uc.Id); // Maps to the AspNetUserClaims table b.ToTable(\u0026#34;AspNetUserClaims\u0026#34;); }); modelBuilder.Entity\u0026lt;ApplicationUserLogin\u0026gt;(b =\u0026gt; { // Composite primary key consisting of the LoginProvider and the key to use // with that provider b.HasKey(l =\u0026gt; new { l.LoginProvider, l.ProviderKey }); // Limit the size of the composite key columns due to common DB restrictions b.Property(l =\u0026gt; l.LoginProvider).HasMaxLength(128); b.Property(l =\u0026gt; l.ProviderKey).HasMaxLength(128); // Maps to the AspNetUserLogins table b.ToTable(\u0026#34;AspNetUserLogins\u0026#34;); }); modelBuilder.Entity\u0026lt;ApplicationUserToken\u0026gt;(b =\u0026gt; { // Composite primary key consisting of the UserId, LoginProvider and Name b.HasKey(t =\u0026gt; new { t.UserId, t.LoginProvider, t.Name }); // Limit the size of the composite key columns due to common DB restrictions //b.Property(t =\u0026gt; t.LoginProvider).HasMaxLength(maxKeyLength); //b.Property(t =\u0026gt; t.Name).HasMaxLength(maxKeyLength); // Maps to the AspNetUserTokens table b.ToTable(\u0026#34;AspNetUserTokens\u0026#34;); }); modelBuilder.Entity\u0026lt;ApplicationRole\u0026gt;(b =\u0026gt; { // Primary key b.HasKey(r =\u0026gt; r.Id); // Index for \u0026#34;normalized\u0026#34; role name to allow efficient lookups b.HasIndex(r =\u0026gt; r.NormalizedName).HasDatabaseName(\u0026#34;RoleNameIndex\u0026#34;).IsUnique(); // Maps to the AspNetRoles table b.ToTable(\u0026#34;AspNetRoles\u0026#34;); // A concurrency token for use with the optimistic concurrency checking b.Property(r =\u0026gt; r.ConcurrencyStamp).IsConcurrencyToken(); // Limit the size of columns to use efficient database types b.Property(u =\u0026gt; u.Id).HasMaxLength(50); b.Property(u =\u0026gt; u.Name).HasMaxLength(256); b.Property(u =\u0026gt; u.NormalizedName).HasMaxLength(256); // The relationships between Role and other entity types // Note that these relationships are configured with no navigation properties // Each Role can have many entries in the UserRole join table b.HasMany\u0026lt;ApplicationUserRole\u0026gt;().WithOne().HasForeignKey(ur =\u0026gt; ur.RoleId).IsRequired(); // Each Role can have many associated RoleClaims b.HasMany\u0026lt;ApplicationRoleClaim\u0026gt;().WithOne().HasForeignKey(rc =\u0026gt; rc.RoleId).IsRequired(); }); modelBuilder.Entity\u0026lt;ApplicationRoleClaim\u0026gt;(b =\u0026gt; { // Primary key b.HasKey(rc =\u0026gt; rc.Id); // Maps to the AspNetRoleClaims table b.ToTable(\u0026#34;AspNetRoleClaims\u0026#34;); }); modelBuilder.Entity\u0026lt;ApplicationUserRole\u0026gt;(b =\u0026gt; { // Primary key b.HasKey(r =\u0026gt; new { r.UserId, r.RoleId }); // Maps to the AspNetUserRoles table b.ToTable(\u0026#34;AspNetUserRoles\u0026#34;); }); // navigation props modelBuilder.Entity\u0026lt;ApplicationUser\u0026gt;(b =\u0026gt; { // Each User can have many UserClaims b.HasMany(e =\u0026gt; e.Claims) .WithOne(e =\u0026gt; e.User) .HasForeignKey(uc =\u0026gt; uc.UserId) .IsRequired(); // Each User can have many UserLogins b.HasMany(e =\u0026gt; e.Logins) .WithOne(e =\u0026gt; e.User) .HasForeignKey(ul =\u0026gt; ul.UserId) .IsRequired(); // Each User can have many UserTokens b.HasMany(e =\u0026gt; e.Tokens) .WithOne(e =\u0026gt; e.User) .HasForeignKey(ut =\u0026gt; ut.UserId) .IsRequired(); // Each User can have many entries in the UserRole join table b.HasMany(e =\u0026gt; e.UserRoles) .WithOne(e =\u0026gt; e.User) .HasForeignKey(ur =\u0026gt; ur.UserId) .IsRequired(); }); modelBuilder.Entity\u0026lt;ApplicationRole\u0026gt;(b =\u0026gt; { // Each Role can have many entries in the UserRole join table b.HasMany(e =\u0026gt; e.UserRoles) .WithOne(e =\u0026gt; e.Role) .HasForeignKey(ur =\u0026gt; ur.RoleId) .IsRequired(); // Each Role can have many associated RoleClaims b.HasMany(e =\u0026gt; e.RoleClaims) .WithOne(e =\u0026gt; e.Role) .HasForeignKey(rc =\u0026gt; rc.RoleId) .IsRequired(); }); } ... The ApplicationDbContext.cs file is a crucial part of a Blazor application with Radzen and .NET 8 that implements role-based authorization using the Identity framework. It defines the database context for the application and includes the configuration for the database tables and their relationships.\nLogin.razor The code for the login page in a Blazor Radzen application with .NET 8 and role-based authorization using Identity.\nLogin.razor\n@page \u0026#34;/Account/Login\u0026#34; @layout AccountLayout @using System.ComponentModel.DataAnnotations @using BlazorAppRadzenRoleBasedAuthwithIdentity.Models.Identity @using Microsoft.AspNetCore.Authentication @using Microsoft.AspNetCore.Identity @using BlazorAppRadzenRoleBasedAuthwithIdentity.Models @inject SignInManager\u0026lt;ApplicationUser\u0026gt; SignInManager @inject ILogger\u0026lt;Login\u0026gt; Logger @inject NavigationManager NavigationManager @inject IdentityRedirectManager RedirectManager \u0026lt;PageTitle\u0026gt;Log in\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Log in\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;StatusMessage Message=\u0026#34;@errorMessage\u0026#34; /\u0026gt; \u0026lt;EditForm Model=\u0026#34;Input\u0026#34; method=\u0026#34;post\u0026#34; OnValidSubmit=\u0026#34;LoginUser\u0026#34; FormName=\u0026#34;login\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;h2\u0026gt;Use a local account to log in.\u0026lt;/h2\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;div class=\u0026#34;mb-3\u0026#34;\u0026gt; \u0026lt;p\u0026gt; \u0026lt;b\u0026gt;Admin User\u0026lt;/b\u0026gt; \u0026lt;br /\u0026gt; email: admin@admin.com \u0026lt;br /\u0026gt; pass: 123456 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ValidationSummary class=\u0026#34;text-danger\u0026#34; role=\u0026#34;alert\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;Input.Email\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;username\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;name@example.com\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Email\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText type=\u0026#34;password\u0026#34; @bind-Value=\u0026#34;Input.Password\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;current-password\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Password\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;checkbox mb-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-label\u0026#34;\u0026gt; \u0026lt;InputCheckbox @bind-Value=\u0026#34;Input.RememberMe\u0026#34; class=\u0026#34;darker-border-checkbox form-check-input\u0026#34; /\u0026gt; Remember me \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;w-100 btn btn-lg btn-primary\u0026#34;\u0026gt;Log in\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;Account/ForgotPassword\u0026#34;\u0026gt;Forgot your password?\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;@(NavigationManager.GetUriWithQueryParameters(\u0026#34;Account/Register\u0026#34;, new Dictionary\u0026lt;string, object?\u0026gt; { [\u0026#34;ReturnUrl\u0026#34;] = ReturnUrl }))\u0026#34;\u0026gt;Register as a new user\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;Account/ResendEmailConfirmation\u0026#34;\u0026gt;Resend email confirmation\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-2\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h3\u0026gt;Use another service to log in.\u0026lt;/h3\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ExternalLoginPicker /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; @code { private string? errorMessage; [CascadingParameter] private HttpContext HttpContext { get; set; } = default!; [SupplyParameterFromForm] private InputModel Input { get; set; } = new(); [SupplyParameterFromQuery] private string? ReturnUrl { get; set; } protected override async Task OnInitializedAsync() { if (HttpMethods.IsGet(HttpContext.Request.Method)) { // Clear the existing external cookie to ensure a clean login process await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme); } } public async Task LoginUser() { // This doesn\u0026#39;t count login failures towards account lockout // To enable password failures to trigger account lockout, set lockoutOnFailure: true var result = await SignInManager.PasswordSignInAsync(Input.Email, Input.Password, Input.RememberMe, lockoutOnFailure: false); if (result.Succeeded) { Logger.LogInformation(\u0026#34;User logged in.\u0026#34;); RedirectManager.RedirectTo(ReturnUrl); } else if (result.RequiresTwoFactor) { RedirectManager.RedirectTo( \u0026#34;Account/LoginWith2fa\u0026#34;, new() { [\u0026#34;returnUrl\u0026#34;] = ReturnUrl, [\u0026#34;rememberMe\u0026#34;] = Input.RememberMe }); } else if (result.IsLockedOut) { Logger.LogWarning(\u0026#34;User account locked out.\u0026#34;); RedirectManager.RedirectTo(\u0026#34;Account/Lockout\u0026#34;); } else { errorMessage = \u0026#34;Error: Invalid login attempt.\u0026#34;; } } private sealed class InputModel { [Required] [EmailAddress] public string Email { get; set; } = \u0026#34;\u0026#34;; [Required] [DataType(DataType.Password)] public string Password { get; set; } = \u0026#34;\u0026#34;; [Display(Name = \u0026#34;Remember me?\u0026#34;)] public bool RememberMe { get; set; } } } The InputModel class represents the model for the login form. It includes properties for email, password, and remember me checkbox.\nThe LoginUser method is called when the user submits the login form. It uses the SignInManager service to authenticate the user based on the provided email and password.\nRegister.razor The Register page in a Blazor Radzen application with Role-based Authorization using Identity.\nRegister.razor\n@page \u0026#34;/Account/Register\u0026#34; @layout AccountLayout @using System.ComponentModel.DataAnnotations @using System.Text @using System.Text.Encodings.Web @using BlazorAppRadzenRoleBasedAuthwithIdentity.Models.Identity @using Microsoft.AspNetCore.Identity @using Microsoft.AspNetCore.WebUtilities @using BlazorAppRadzenRoleBasedAuthwithIdentity.Models @inject UserManager\u0026lt;ApplicationUser\u0026gt; UserManager @inject IUserStore\u0026lt;ApplicationUser\u0026gt; UserStore @inject SignInManager\u0026lt;ApplicationUser\u0026gt; SignInManager @inject IEmailSender\u0026lt;ApplicationUser\u0026gt; EmailSender @inject ILogger\u0026lt;Register\u0026gt; Logger @inject NavigationManager NavigationManager @inject IdentityRedirectManager RedirectManager \u0026lt;PageTitle\u0026gt;Register\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Register\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;StatusMessage Message=\u0026#34;@Message\u0026#34; /\u0026gt; \u0026lt;EditForm Model=\u0026#34;Input\u0026#34; asp-route-returnUrl=\u0026#34;@ReturnUrl\u0026#34; method=\u0026#34;post\u0026#34; OnValidSubmit=\u0026#34;RegisterUser\u0026#34; FormName=\u0026#34;register\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;h2\u0026gt;Create a new account.\u0026lt;/h2\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ValidationSummary class=\u0026#34;text-danger\u0026#34; role=\u0026#34;alert\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;Input.Email\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;username\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;name@example.com\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Email\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText type=\u0026#34;password\u0026#34; @bind-Value=\u0026#34;Input.Password\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;new-password\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Password\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText type=\u0026#34;password\u0026#34; @bind-Value=\u0026#34;Input.ConfirmPassword\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;new-password\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;confirm-password\u0026#34;\u0026gt;Confirm Password\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.ConfirmPassword\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;w-100 btn btn-lg btn-primary\u0026#34;\u0026gt;Register\u0026lt;/button\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-2\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h3\u0026gt;Use another service to register.\u0026lt;/h3\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ExternalLoginPicker /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; @code { private IEnumerable\u0026lt;IdentityError\u0026gt;? identityErrors; [SupplyParameterFromForm] private InputModel Input { get; set; } = new(); [SupplyParameterFromQuery] private string? ReturnUrl { get; set; } private string? Message =\u0026gt; identityErrors is null ? null : $\u0026#34;Error: {string.Join(\u0026#34;, \u0026#34;, identityErrors.Select(error =\u0026gt; error.Description))}\u0026#34;; public async Task RegisterUser(EditContext editContext) { var user = CreateUser(); await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None); var emailStore = GetEmailStore(); await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None); var result = await UserManager.CreateAsync(user, Input.Password); if (!result.Succeeded) { identityErrors = result.Errors; return; } Logger.LogInformation(\u0026#34;User created a new account with password.\u0026#34;); await UserManager.AddToRoleAsync(user, \u0026#34;User\u0026#34;); Logger.LogInformation(\u0026#34;User added to \u0026#39;User\u0026#39; role.\u0026#34;); var userId = await UserManager.GetUserIdAsync(user); var code = await UserManager.GenerateEmailConfirmationTokenAsync(user); code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code)); var callbackUrl = NavigationManager.GetUriWithQueryParameters( NavigationManager.ToAbsoluteUri(\u0026#34;Account/ConfirmEmail\u0026#34;).AbsoluteUri, new Dictionary\u0026lt;string, object?\u0026gt; { [\u0026#34;userId\u0026#34;] = userId, [\u0026#34;code\u0026#34;] = code, [\u0026#34;returnUrl\u0026#34;] = ReturnUrl }); await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl)); if (UserManager.Options.SignIn.RequireConfirmedAccount) { RedirectManager.RedirectTo( \u0026#34;Account/RegisterConfirmation\u0026#34;, new() { [\u0026#34;email\u0026#34;] = Input.Email, [\u0026#34;returnUrl\u0026#34;] = ReturnUrl }); } await SignInManager.SignInAsync(user, isPersistent: false); RedirectManager.RedirectTo(ReturnUrl); } private ApplicationUser CreateUser() { try { return Activator.CreateInstance\u0026lt;ApplicationUser\u0026gt;(); } catch { throw new InvalidOperationException($\u0026#34;Can\u0026#39;t create an instance of \u0026#39;{nameof(ApplicationUser)}\u0026#39;. \u0026#34; + $\u0026#34;Ensure that \u0026#39;{nameof(ApplicationUser)}\u0026#39; is not an abstract class and has a parameterless constructor.\u0026#34;); } } private IUserEmailStore\u0026lt;ApplicationUser\u0026gt; GetEmailStore() { if (!UserManager.SupportsUserEmail) { throw new NotSupportedException(\u0026#34;The default UI requires a user store with email support.\u0026#34;); } return (IUserEmailStore\u0026lt;ApplicationUser\u0026gt;)UserStore; } private sealed class InputModel { [Required] [EmailAddress] [Display(Name = \u0026#34;Email\u0026#34;)] public string Email { get; set; } = \u0026#34;\u0026#34;; [Required] [StringLength(100, ErrorMessage = \u0026#34;The {0} must be at least {2} and at max {1} characters long.\u0026#34;, MinimumLength = 6)] [DataType(DataType.Password)] [Display(Name = \u0026#34;Password\u0026#34;)] public string Password { get; set; } = \u0026#34;\u0026#34;; [DataType(DataType.Password)] [Display(Name = \u0026#34;Confirm password\u0026#34;)] [Compare(\u0026#34;Password\u0026#34;, ErrorMessage = \u0026#34;The password and confirmation password do not match.\u0026#34;)] public string ConfirmPassword { get; set; } = \u0026#34;\u0026#34;; } } Creates a new user using the CreateUser method. Creates the user with the provided password using the UserManager.CreateAsync method.\nAdds the user to the \u0026quot;User\u0026quot; role using the UserManager.AddToRoleAsync method.\nSigns in the user and redirects to the specified return URL.\nAuth.razor Auth.razor, role-based authorization in a Blazor application using Radzen, .NET 8, and Identity. By checking the user\u0026rsquo;s roles, you can control access to different parts of your application based on specific permissions.\nAuth.razor\n@page \u0026#34;/auth\u0026#34; @using Microsoft.AspNetCore.Authorization @using Microsoft.AspNetCore.Identity @using System.Security.Claims; @inject AuthenticationStateProvider authenticationStateProvider @attribute [Authorize] \u0026lt;PageTitle\u0026gt;Auth\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;You are authenticated\u0026lt;/h1\u0026gt; \u0026lt;AuthorizeView\u0026gt; User: @context.User.Identity?.Name \u0026lt;br /\u0026gt; User: @user?.Identity?.Name \u0026lt;br /\u0026gt; Roles: @(string.Join(\u0026#34;, \u0026#34;, userRoleNames)) \u0026lt;br /\u0026gt; \u0026lt;/AuthorizeView\u0026gt; @code { ClaimsPrincipal? user; string[]? userRoleNames; protected override async Task OnInitializedAsync() { var auth = await authenticationStateProvider.GetAuthenticationStateAsync(); user = auth.User as ClaimsPrincipal; //var userIdentity = auth.User.Identity as ClaimsIdentity; userRoleNames = user.FindAll(ClaimTypes.Role).Select(x =\u0026gt; x.Value).ToArray(); } } The Authorize attribute is used to restrict access to the page to authenticated users only.\nAuthAdminRole.razor By utilizing the Authorize attribute and ClaimsPrincipal, the application restricts access to specific roles, ensuring that only users with the \u0026quot;Admin\u0026quot; role can view the content of the page.\nAuthAdminRole.razor\n@page \u0026#34;/auth-admin-role\u0026#34; @using Microsoft.AspNetCore.Authorization @using Microsoft.AspNetCore.Identity @using System.Security.Claims; @inject AuthenticationStateProvider authenticationStateProvider @attribute [Authorize(Roles = \u0026#34;Admin\u0026#34;)] \u0026lt;PageTitle\u0026gt;Auth\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;You are authenticated (Admin)\u0026lt;/h1\u0026gt; \u0026lt;AuthorizeView\u0026gt; \u0026lt;Authorized\u0026gt; This is admin authorize page. \u0026lt;br /\u0026gt; User: @context.User.Identity?.Name \u0026lt;br /\u0026gt; User: @user?.Identity?.Name \u0026lt;br /\u0026gt; Roles: @(string.Join(\u0026#34;, \u0026#34;, userRoleNames)) \u0026lt;br /\u0026gt; \u0026lt;/Authorized\u0026gt; \u0026lt;NotAuthorized\u0026gt; You don\u0026#39;t have permission to access this page. (Need Admin Role) \u0026lt;/NotAuthorized\u0026gt; \u0026lt;/AuthorizeView\u0026gt; @code { ClaimsPrincipal? user; string[]? userRoleNames; protected override async Task OnInitializedAsync() { var auth = await authenticationStateProvider.GetAuthenticationStateAsync(); user = auth.User as ClaimsPrincipal; //var userIdentity = auth.User.Identity as ClaimsIdentity; userRoleNames = user.FindAll(ClaimTypes.Role).Select(x =\u0026gt; x.Value).ToArray(); } } Only users with the \u0026quot;Admin\u0026quot; role can access the content of the page.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenRoleBasedAuthwithIdentity\n","date":"August 10, 2024","hero":"/dotnet/2024-08-10-blazor-radzen-.net8-role-based-authorization-with-identity/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-08-10-blazor-radzen-.net8-role-based-authorization-with-identity/","summary":"Blazor Radzen .NET 8 Role-based Authorization with Identity Blazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows you to write code that runs on the client-side in the browser.\nRadzen: Radzen is a low-code development tool for building web applications. It provides a visual interface for designing UI components and generating code.\n.NET 8: .NET 8 is the latest version of the .","tags":["dotnet8",".NET8","Blazor","Radzen","Role-based Authorization","Identity"],"title":"Blazor Radzen .NET 8 Role-based Authorization with Identity"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Identity","Automatically Logout Timer"],"contents":" Blazor Radzen .NET 8 Identity Automatically Logout Timer Blazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code that runs on the client-side and interacts with the server-side.\nRadzen: Radzen is a low-code development platform that provides tools and components for building web applications. It simplifies the development process by generating code and providing a visual interface for designing UI components.\n.NET 8: .NET is a free, open-source, cross-platform framework for building modern applications. .NET 8 is the latest version of the framework, offering improved performance, new features, and enhanced security.\n.NET 8 Identity: .NET Identity is a membership system that allows developers to add authentication and authorization to their applications. It provides features like user registration, login, and role-based access control.\nProgram.cs It sets up authentication, user management, password policies, lockout settings, and cookie configurations. Additionally, it registers services required for Identity management and access to the HTTP context.\nProgram.cs\n... builder.Services.AddCascadingAuthenticationState(); builder.Services.AddScoped\u0026lt;IdentityUserAccessor\u0026gt;(); builder.Services.AddScoped\u0026lt;IdentityRedirectManager\u0026gt;(); builder.Services.AddScoped\u0026lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider\u0026gt;(); builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = IdentityConstants.ApplicationScheme; options.DefaultSignInScheme = IdentityConstants.ExternalScheme; }) .AddIdentityCookies(); builder.Services.AddDbContext\u0026lt;ApplicationDbContext\u0026gt;(options =\u0026gt; options.UseInMemoryDatabase(\u0026#34;ConnectionInMemory\u0026#34;)); builder.Services.AddDatabaseDeveloperPageExceptionFilter(); builder.Services.AddIdentityCore\u0026lt;ApplicationUser\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApplicationDbContext\u0026gt;() .AddSignInManager() .AddDefaultTokenProviders(); builder.Services.Configure\u0026lt;IdentityOptions\u0026gt;(options =\u0026gt; { // Default Lockout settings. options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5); options.Lockout.MaxFailedAccessAttempts = 5; options.Lockout.AllowedForNewUsers = true; // Default Password settings. options.Password.RequireDigit = false; options.Password.RequireLowercase = false; options.Password.RequireNonAlphanumeric = false; options.Password.RequireUppercase = false; options.Password.RequiredLength = 6; options.Password.RequiredUniqueChars = 0; // Default SignIn settings. options.SignIn.RequireConfirmedEmail = false; options.SignIn.RequireConfirmedPhoneNumber = false; // Default User settings. options.User.AllowedUserNameCharacters = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+\u0026#34;; options.User.RequireUniqueEmail = false; }); builder.Services.ConfigureApplicationCookie(options =\u0026gt; { //options.AccessDeniedPath = \u0026#34;/Identity/Account/AccessDenied\u0026#34;; options.Cookie.Name = COOKIE_NAME; options.Cookie.HttpOnly = true; options.ExpireTimeSpan = EXPIRE_TIMESPAN; //options.LoginPath = \u0026#34;/Identity/Account/Login\u0026#34;; options.ReturnUrlParameter = CookieAuthenticationDefaults.ReturnUrlParameter; options.SlidingExpiration = true; }); builder.Services.Configure\u0026lt;PasswordHasherOptions\u0026gt;(option =\u0026gt; { option.IterationCount = 12000; }); builder.Services.AddSingleton\u0026lt;IEmailSender\u0026lt;ApplicationUser\u0026gt;, IdentityNoOpEmailSender\u0026gt;(); builder.Services.AddHttpContextAccessor(); builder.Services.AddTransient\u0026lt;AuthCheckService\u0026gt;(); ... AuthCheckService.cs AuthCheckService that is responsible for checking the expiration time of the user's authentication in a Blazor Radzen application using .NET 8 Identity. The service retrieves the expiration time of the user's authentication token and calculates the remaining time until logout.\nAuthCheckService.cs\nusing Microsoft.AspNetCore.Authentication; using Microsoft.AspNetCore.Authentication.Cookies; using Microsoft.AspNetCore.DataProtection; using Microsoft.Extensions.Options; namespace BlazorAppRadzenAuthIdentityAutoLogoutTimer.Services; public class AuthCheckService { private readonly IHttpContextAccessor _httpContextAccessor; private readonly CookieAuthenticationOptions _options; public AuthCheckService(IHttpContextAccessor httpContextAccessor, IOptions\u0026lt;CookieAuthenticationOptions\u0026gt; options) { _httpContextAccessor = httpContextAccessor; _options = options.Value; } public Task\u0026lt;TimeSpan?\u0026gt; GetAuthExpiration() { TimeSpan? timeSpan = null; string? cookie = _httpContextAccessor?.HttpContext?.Request.Cookies[Program.COOKIE_NAME]; if (cookie is null) return Task.FromResult(timeSpan); IDataProtectionProvider? provider = _options.DataProtectionProvider; if (provider is null) return Task.FromResult(timeSpan); IDataProtector protector = provider.CreateProtector( \u0026#34;Microsoft.AspNetCore.Authentication.Cookies.\u0026#34; + \u0026#34;CookieAuthenticationMiddleware\u0026#34;, \u0026#34;Identity.Application\u0026#34;, \u0026#34;v2\u0026#34;); TicketDataFormat format = new TicketDataFormat(protector); AuthenticationTicket? authTicket = format.Unprotect(cookie); if (authTicket is null) return Task.FromResult(timeSpan); AuthenticationProperties property = authTicket.Properties; DateTimeOffset? expiresUtc = property.ExpiresUtc; timeSpan = expiresUtc - DateTimeOffset.UtcNow; return Task.FromResult(timeSpan); } } The AuthCheckService class has two private fields: _httpContextAccessor and _options. The constructor initializes these fields using dependency injection. The GetAuthExpiration method retrieves the authentication cookie, decrypts it using the data protector, and calculates the remaining time until expiration.\nComponentAuthTimer.razor ComponentAuthTimer.razor, it is responsible for displaying the remaining authentication expiration time and automatically logging the user out when the time expires.\nComponentAuthTimer.razor\n@using BlazorAppRadzenAuthIdentityAutoLogoutTimer.Services @using Microsoft.AspNetCore.Authorization @using System.Security.Claims @implements IDisposable @attribute [Authorize] @inject AuthCheckService AuthCheckService @inject NavigationManager? NavigationManager \u0026lt;AuthorizeView\u0026gt; @if (NavigationManager is not null \u0026amp;\u0026amp; NavigationManager.Uri.Contains(\u0026#34;/Account\u0026#34;) == true) { \u0026lt;span style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; Auto logout after \u0026lt;b\u0026gt;\u0026lt;span id=\u0026#34;logoutTime\u0026#34; val-seconds=\u0026#34;@((int)authExpiration?.TotalSeconds)\u0026#34;\u0026gt;@(authExpiration is not null ? authExpiration.Value.ToString(@\u0026#34;hh\\:mm\\:ss\u0026#34;) : \u0026#34;\u0026#34;)\u0026lt;/span\u0026gt;\u0026lt;/b\u0026gt; \u0026lt;/span\u0026gt; } else { \u0026lt;span style=\u0026#34;margin: 10px;\u0026#34;\u0026gt; Auto logout after \u0026lt;b\u0026gt;@(authExpiration is not null ? authExpiration.Value.ToString(@\u0026#34;hh\\:mm\\:ss\u0026#34;) : \u0026#34;\u0026#34;)\u0026lt;/b\u0026gt; \u0026lt;/span\u0026gt; } \u0026lt;/AuthorizeView\u0026gt; @code { TimeSpan? authExpiration; System.Timers.Timer? authExpirationTimer; protected override async Task OnInitializedAsync() { authExpiration = await AuthCheckService.GetAuthExpiration(); if (authExpirationTimer is null \u0026amp;\u0026amp; NavigationManager?.Uri.Contains(\u0026#34;/Account\u0026#34;) != true) { authExpirationTimer = new System.Timers.Timer(1000); authExpirationTimer.Elapsed += AuthExpirationTimer_Elapsed; authExpirationTimer.Enabled = true; } } private async void AuthExpirationTimer_Elapsed(object? sender, System.Timers.ElapsedEventArgs e) { if (authExpiration is null || authExpirationTimer is null) return; if (authExpiration.Value.TotalSeconds \u0026gt; 0) { if (((int)authExpiration.Value.TotalSeconds % 60) == 0) { var expiration = await AuthCheckService.GetAuthExpiration(); if (expiration is not null) authExpiration = expiration; } authExpiration -= TimeSpan.FromSeconds(1); await InvokeAsync(StateHasChanged); } else { authExpirationTimer.Enabled = false; authExpirationTimer.Elapsed -= AuthExpirationTimer_Elapsed; NavigationManager?.Refresh(forceReload: true); } } public void Dispose() { if (authExpirationTimer is not null) authExpirationTimer.Elapsed -= AuthExpirationTimer_Elapsed; authExpirationTimer?.Dispose(); } } The code block starts with the declaration of two variables: authExpiration of type TimeSpan? and authExpirationTimer of type System.Timers.Timer?. The authExpiration variable stores the authentication expiration time, and the authExpirationTimer is used to update the countdown every second.\nThe AuthExpirationTimer_Elapsed method is the event handler for the timer\u0026rsquo;s Elapsed event. It checks if the authentication expiration time is null or the timer is null and returns if either condition is true.\nIf the authentication expiration time is greater than zero, it checks if the remaining seconds are divisible by 60. If so, it retrieves the updated expiration time from the AuthCheckService. Then, it subtracts one second from the remaining time and updates the UI using StateHasChanged.\nComponentAuthTimer.razor component provides an automatic logout timer functionality in a Blazor application using Radzen and .NET 8 Identity. It displays a countdown timer indicating the time remaining before the user is automatically logged out due to inactivity.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenAuthIdentityAutoLogoutTimer\n","date":"August 3, 2024","hero":"/dotnet/2024-08-03-blazor-radzen-.net8-identity-automatically-logout-timer/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-08-03-blazor-radzen-.net8-identity-automatically-logout-timer/","summary":"Blazor Radzen .NET 8 Identity Automatically Logout Timer Blazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code that runs on the client-side and interacts with the server-side.\nRadzen: Radzen is a low-code development platform that provides tools and components for building web applications. It simplifies the development process by generating code and providing a visual interface for designing UI components.","tags":["dotnet8",".NET8","Blazor","Radzen","Identity","Automatically Logout Timer"],"title":"Blazor Radzen .NET 8 Identity Automatically Logout Timer"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Authentication","Authorization","Identity"],"contents":" Blazor Radzen .NET 8 Authentication \u0026amp; Authorization with Identity Blazor: Blazor is a framework for building interactive web UIs using C# instead of JavaScript. It allows developers to create web applications using .NET.\nRadzen: Radzen is a low-code development tool that helps in building web applications quickly and efficiently.\n.NET 8: .NET 8 is a software framework developed by Microsoft for building different types of applications, including web applications.\nAuthentication: Authentication is the process of verifying the identity of users accessing an application.\nAuthorization: Authorization determines what actions users are allowed to perform within an application.\nIdentity: Identity is a membership system in ASP.NET that provides user authentication and authorization functionality.\nBlazorAppRadzenAuthwithIdentity.csproj One fundamental component in this ecosystem is Microsoft.AspNetCore.Identity.EntityFrameworkCore. This package plays a pivotal role in managing user authentication and authorization within a Blazor application.\nBlazorAppRadzenAuthwithIdentity.csproj\n... \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;8.0.5\u0026#34; /\u0026gt; ... Program.cs Program.cs provided configures services and settings related to Identity, authentication, and authorization in a Blazor Radzen application.\nProgram.cs\n... builder.Services.AddCascadingAuthenticationState(); builder.Services.AddScoped\u0026lt;IdentityUserAccessor\u0026gt;(); builder.Services.AddScoped\u0026lt;IdentityRedirectManager\u0026gt;(); builder.Services.AddScoped\u0026lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider\u0026gt;(); builder.Services.AddAuthentication(options =\u0026gt; { options.DefaultScheme = IdentityConstants.ApplicationScheme; options.DefaultSignInScheme = IdentityConstants.ExternalScheme; }) .AddIdentityCookies(); builder.Services.AddIdentityCore\u0026lt;ApplicationUser\u0026gt;() .AddEntityFrameworkStores\u0026lt;ApplicationDbContext\u0026gt;() .AddSignInManager() .AddDefaultTokenProviders(); builder.Services.AddSingleton\u0026lt;IEmailSender\u0026lt;ApplicationUser\u0026gt;, IdentityNoOpEmailSender\u0026gt;(); ... // Add additional endpoints required by the Identity /Account Razor components. app.MapAdditionalIdentityEndpoints(); ... AddCascadingAuthenticationState(): Registers the cascading authentication state service.\nAddScoped\u0026lt;IdentityUserAccessor\u0026gt;(): Registers the IdentityUserAccessor service.\nAddScoped\u0026lt;IdentityRedirectManager\u0026gt;(): Registers the IdentityRedirectManager service.\nAddScoped\u0026lt;AuthenticationStateProvider, IdentityRevalidatingAuthenticationStateProvider\u0026gt;(): Registers the IdentityRevalidatingAuthenticationStateProvider service for managing authentication state.\nApplicationDbContext.cs ApplicationDbContext class, which inherits from IdentityDbContext\u0026lt;ApplicationUser\u0026gt;. This class is responsible for managing the database context for the application, specifically related to user authentication and authorization.\nApplicationDbContext.cs\nusing BlazorAppRadzenAuthwithIdentity.Models; using Microsoft.AspNetCore.Identity.EntityFrameworkCore; using Microsoft.EntityFrameworkCore; namespace BlazorAppRadzenAuthwithIdentity.Data; public class ApplicationDbContext(DbContextOptions\u0026lt;ApplicationDbContext\u0026gt; options) : IdentityDbContext\u0026lt;ApplicationUser\u0026gt;(options) { public DbSet\u0026lt;BlogPost\u0026gt; BlogPosts =\u0026gt; Set\u0026lt;BlogPost\u0026gt;(); protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); } } The ApplicationDbContext class takes DbContextOptions\u0026lt;ApplicationDbContext\u0026gt; as a parameter in its constructor.\nIt defines a DbSet\u0026lt;BlogPost\u0026gt; property named BlogPosts to interact with the BlogPost entity in the database.\nThe OnModelCreating method is overridden to configure the model for the database context.\nLogin.razor Login.razor\n@page \u0026#34;/Account/Login\u0026#34; @layout AccountLayout @using System.ComponentModel.DataAnnotations @using Microsoft.AspNetCore.Authentication @using Microsoft.AspNetCore.Identity @using BlazorAppRadzenAuthwithIdentity.Models @inject SignInManager\u0026lt;ApplicationUser\u0026gt; SignInManager @inject ILogger\u0026lt;Login\u0026gt; Logger @inject NavigationManager NavigationManager @inject IdentityRedirectManager RedirectManager \u0026lt;PageTitle\u0026gt;Log in\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Log in\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;StatusMessage Message=\u0026#34;@errorMessage\u0026#34; /\u0026gt; \u0026lt;EditForm Model=\u0026#34;Input\u0026#34; method=\u0026#34;post\u0026#34; OnValidSubmit=\u0026#34;LoginUser\u0026#34; FormName=\u0026#34;login\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;h2\u0026gt;Use a local account to log in.\u0026lt;/h2\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ValidationSummary class=\u0026#34;text-danger\u0026#34; role=\u0026#34;alert\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;Input.Email\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;username\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;name@example.com\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Email\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText type=\u0026#34;password\u0026#34; @bind-Value=\u0026#34;Input.Password\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;current-password\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34; class=\u0026#34;form-label\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Password\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;checkbox mb-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-label\u0026#34;\u0026gt; \u0026lt;InputCheckbox @bind-Value=\u0026#34;Input.RememberMe\u0026#34; class=\u0026#34;darker-border-checkbox form-check-input\u0026#34; /\u0026gt; Remember me \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;w-100 btn btn-lg btn-primary\u0026#34;\u0026gt;Log in\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;Account/ForgotPassword\u0026#34;\u0026gt;Forgot your password?\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;@(NavigationManager.GetUriWithQueryParameters(\u0026#34;Account/Register\u0026#34;, new Dictionary\u0026lt;string, object?\u0026gt; { [\u0026#34;ReturnUrl\u0026#34;] = ReturnUrl }))\u0026#34;\u0026gt;Register as a new user\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;Account/ResendEmailConfirmation\u0026#34;\u0026gt;Resend email confirmation\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-2\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h3\u0026gt;Use another service to log in.\u0026lt;/h3\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ExternalLoginPicker /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; @code { private string? errorMessage; [CascadingParameter] private HttpContext HttpContext { get; set; } = default!; [SupplyParameterFromForm] private InputModel Input { get; set; } = new(); [SupplyParameterFromQuery] private string? ReturnUrl { get; set; } protected override async Task OnInitializedAsync() { if (HttpMethods.IsGet(HttpContext.Request.Method)) { // Clear the existing external cookie to ensure a clean login process await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme); } } public async Task LoginUser() { // This doesn\u0026#39;t count login failures towards account lockout // To enable password failures to trigger account lockout, set lockoutOnFailure: true var result = await SignInManager.PasswordSignInAsync(Input.Email, Input.Password, Input.RememberMe, lockoutOnFailure: false); if (result.Succeeded) { Logger.LogInformation(\u0026#34;User logged in.\u0026#34;); RedirectManager.RedirectTo(ReturnUrl); } else if (result.RequiresTwoFactor) { RedirectManager.RedirectTo( \u0026#34;Account/LoginWith2fa\u0026#34;, new() { [\u0026#34;returnUrl\u0026#34;] = ReturnUrl, [\u0026#34;rememberMe\u0026#34;] = Input.RememberMe }); } else if (result.IsLockedOut) { Logger.LogWarning(\u0026#34;User account locked out.\u0026#34;); RedirectManager.RedirectTo(\u0026#34;Account/Lockout\u0026#34;); } else { errorMessage = \u0026#34;Error: Invalid login attempt.\u0026#34;; } } private sealed class InputModel { [Required] [EmailAddress] public string Email { get; set; } = \u0026#34;\u0026#34;; [Required] [DataType(DataType.Password)] public string Password { get; set; } = \u0026#34;\u0026#34;; [Display(Name = \u0026#34;Remember me?\u0026#34;)] public bool RememberMe { get; set; } } } The @inject directives inject dependencies into the page, such as the SignInManager, Logger, NavigationManager, and RedirectManager.\nRegister.razor Register.razor\n@page \u0026#34;/Account/Register\u0026#34; @layout AccountLayout @using System.ComponentModel.DataAnnotations @using System.Text @using System.Text.Encodings.Web @using Microsoft.AspNetCore.Identity @using Microsoft.AspNetCore.WebUtilities @using BlazorAppRadzenAuthwithIdentity.Models @inject UserManager\u0026lt;ApplicationUser\u0026gt; UserManager @inject IUserStore\u0026lt;ApplicationUser\u0026gt; UserStore @inject SignInManager\u0026lt;ApplicationUser\u0026gt; SignInManager @inject IEmailSender\u0026lt;ApplicationUser\u0026gt; EmailSender @inject ILogger\u0026lt;Register\u0026gt; Logger @inject NavigationManager NavigationManager @inject IdentityRedirectManager RedirectManager \u0026lt;PageTitle\u0026gt;Register\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Register\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;StatusMessage Message=\u0026#34;@Message\u0026#34; /\u0026gt; \u0026lt;EditForm Model=\u0026#34;Input\u0026#34; asp-route-returnUrl=\u0026#34;@ReturnUrl\u0026#34; method=\u0026#34;post\u0026#34; OnValidSubmit=\u0026#34;RegisterUser\u0026#34; FormName=\u0026#34;register\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;h2\u0026gt;Create a new account.\u0026lt;/h2\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ValidationSummary class=\u0026#34;text-danger\u0026#34; role=\u0026#34;alert\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;Input.Email\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;username\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;name@example.com\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Email\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText type=\u0026#34;password\u0026#34; @bind-Value=\u0026#34;Input.Password\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;new-password\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;password\u0026#34;\u0026gt;Password\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.Password\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-floating mb-3\u0026#34;\u0026gt; \u0026lt;InputText type=\u0026#34;password\u0026#34; @bind-Value=\u0026#34;Input.ConfirmPassword\u0026#34; class=\u0026#34;form-control\u0026#34; autocomplete=\u0026#34;new-password\u0026#34; aria-required=\u0026#34;true\u0026#34; placeholder=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;label for=\u0026#34;confirm-password\u0026#34;\u0026gt;Confirm Password\u0026lt;/label\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; Input.ConfirmPassword\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;w-100 btn btn-lg btn-primary\u0026#34;\u0026gt;Register\u0026lt;/button\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-6 col-md-offset-2\u0026#34;\u0026gt; \u0026lt;section\u0026gt; \u0026lt;h3\u0026gt;Use another service to register.\u0026lt;/h3\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;ExternalLoginPicker /\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; @code { private IEnumerable\u0026lt;IdentityError\u0026gt;? identityErrors; [SupplyParameterFromForm] private InputModel Input { get; set; } = new(); [SupplyParameterFromQuery] private string? ReturnUrl { get; set; } private string? Message =\u0026gt; identityErrors is null ? null : $\u0026#34;Error: {string.Join(\u0026#34;, \u0026#34;, identityErrors.Select(error =\u0026gt; error.Description))}\u0026#34;; public async Task RegisterUser(EditContext editContext) { var user = CreateUser(); await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None); var emailStore = GetEmailStore(); await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None); var result = await UserManager.CreateAsync(user, Input.Password); if (!result.Succeeded) { identityErrors = result.Errors; return; } Logger.LogInformation(\u0026#34;User created a new account with password.\u0026#34;); var userId = await UserManager.GetUserIdAsync(user); var code = await UserManager.GenerateEmailConfirmationTokenAsync(user); code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code)); var callbackUrl = NavigationManager.GetUriWithQueryParameters( NavigationManager.ToAbsoluteUri(\u0026#34;Account/ConfirmEmail\u0026#34;).AbsoluteUri, new Dictionary\u0026lt;string, object?\u0026gt; { [\u0026#34;userId\u0026#34;] = userId, [\u0026#34;code\u0026#34;] = code, [\u0026#34;returnUrl\u0026#34;] = ReturnUrl }); await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl)); if (UserManager.Options.SignIn.RequireConfirmedAccount) { RedirectManager.RedirectTo( \u0026#34;Account/RegisterConfirmation\u0026#34;, new() { [\u0026#34;email\u0026#34;] = Input.Email, [\u0026#34;returnUrl\u0026#34;] = ReturnUrl }); } await SignInManager.SignInAsync(user, isPersistent: false); RedirectManager.RedirectTo(ReturnUrl); } private ApplicationUser CreateUser() { try { return Activator.CreateInstance\u0026lt;ApplicationUser\u0026gt;(); } catch { throw new InvalidOperationException($\u0026#34;Can\u0026#39;t create an instance of \u0026#39;{nameof(ApplicationUser)}\u0026#39;. \u0026#34; + $\u0026#34;Ensure that \u0026#39;{nameof(ApplicationUser)}\u0026#39; is not an abstract class and has a parameterless constructor.\u0026#34;); } } private IUserEmailStore\u0026lt;ApplicationUser\u0026gt; GetEmailStore() { if (!UserManager.SupportsUserEmail) { throw new NotSupportedException(\u0026#34;The default UI requires a user store with email support.\u0026#34;); } return (IUserEmailStore\u0026lt;ApplicationUser\u0026gt;)UserStore; } private sealed class InputModel { [Required] [EmailAddress] [Display(Name = \u0026#34;Email\u0026#34;)] public string Email { get; set; } = \u0026#34;\u0026#34;; [Required] [StringLength(100, ErrorMessage = \u0026#34;The {0} must be at least {2} and at max {1} characters long.\u0026#34;, MinimumLength = 6)] [DataType(DataType.Password)] [Display(Name = \u0026#34;Password\u0026#34;)] public string Password { get; set; } = \u0026#34;\u0026#34;; [DataType(DataType.Password)] [Display(Name = \u0026#34;Confirm password\u0026#34;)] [Compare(\u0026#34;Password\u0026#34;, ErrorMessage = \u0026#34;The password and confirmation password do not match.\u0026#34;)] public string ConfirmPassword { get; set; } = \u0026#34;\u0026#34;; } } The RegisterUser method handles the user registration process. It creates a new user, sets the user\u0026rsquo;s email and password, and calls the CreateAsync method of the UserManager to create the user in the database. If the registration is successful, it generates an email confirmation token, sends a confirmation email to the user, and signs in the user. Finally, it redirects the user to the specified URL.\nThe InputModel class represents the input fields for the user registration form. It includes properties for the email, password, and confirm password fields, along with validation attributes.\nAuth.razor Auth.razor\n@page \u0026#34;/auth\u0026#34; @using Microsoft.AspNetCore.Authorization @attribute [Authorize] \u0026lt;PageTitle\u0026gt;Auth\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;You are authenticated\u0026lt;/h1\u0026gt; \u0026lt;AuthorizeView\u0026gt; Hello @context.User.Identity?.Name! \u0026lt;/AuthorizeView\u0026gt; @attribute [Authorize]: Decorates the page with the [Authorize] attribute, restricting access to authenticated users only.\nHello @context.User.Identity?.Name!: Displays a greeting message with the authenticated user\u0026rsquo;s name if available.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenAuthwithIdentity\n","date":"July 28, 2024","hero":"/dotnet/2024-07-28-blazor-radzen-.net8-authenticationauthorization-with-identity/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-07-28-blazor-radzen-.net8-authenticationauthorization-with-identity/","summary":"Blazor Radzen .NET 8 Authentication \u0026amp; Authorization with Identity Blazor: Blazor is a framework for building interactive web UIs using C# instead of JavaScript. It allows developers to create web applications using .NET.\nRadzen: Radzen is a low-code development tool that helps in building web applications quickly and efficiently.\n.NET 8: .NET 8 is a software framework developed by Microsoft for building different types of applications, including web applications.","tags":["dotnet8",".NET8","Blazor","Radzen","Authentication","Authorization","Identity"],"title":"Blazor Radzen .NET 8 Authentication \u0026 Authorization with Identity"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Google Maps"],"contents":" Blazor Radzen .NET 8 Google Maps Blazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code in C# and have it run directly in the browser.\nRadzen: Radzen is a low-code development platform that provides tools and components for building web applications. It simplifies the development process by generating code and providing a visual interface for designing user interfaces.\n.NET 8: .NET 8 is the latest version of the .NET framework, a software development platform for building applications. It includes various improvements and new features for developing web, desktop, and mobile applications.\nGoogle Maps: Google Maps is a web mapping service provided by Google. It allows users to view maps, get directions, and search for locations.\nGoogle Maps API: The Google Maps API is a set of APIs provided by Google that allows developers to integrate Google Maps into their applications. It provides various functionalities for displaying maps, adding markers, and handling user interactions.\nMapMarker.cs MapMarker.cs\nnamespace BlazorAppRadzenGoogleMaps.Models; public class MapMarker { public int Id { get; set; } public string Title { get; set; } = string.Empty; public double Lat { get; set; } public double Lng { get; set; } } We have a C# class named MapMarker within the BlazorAppRadzenGoogleMaps.Models namespace. This class represents a map marker with properties such as Id, Title, Latitude (Lat), and Longitude (Lng).\nThe MapMarker class defines properties for Id, Title, Lat, and Lng. The Id property is an integer representing the marker\u0026rsquo;s unique identifier. The Title property is a string initialized to an empty string. The Lat and Lng properties are doubles representing the latitude and longitude coordinates, respectively.\nMapMarkerService.cs MapMarkerService.cs\nusing BlazorAppRadzenGoogleMaps.Data; using BlazorAppRadzenGoogleMaps.Models; using Microsoft.EntityFrameworkCore; using Radzen; using System.Linq.Dynamic.Core; namespace BlazorAppRadzenGoogleMaps.Services; public class MapMarkerService { private readonly ApplicationDbContext _context; public MapMarkerService(ApplicationDbContext context) { _context = context; } public Task\u0026lt;MapMarker?\u0026gt; GetbyId(int id) { return _context.MapMarkers.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); } public async Task\u0026lt;(IEnumerable\u0026lt;MapMarker\u0026gt; Result, int TotalCount)\u0026gt; GetMapMarkersAsync(string? filter = default, int? top = default, int? skip = default, string? orderby = default, string? expand = default, string? select = default, bool? count = default) { var query = _context.MapMarkers.AsQueryable(); if (!string.IsNullOrEmpty(filter)) query = query.Where(filter); if (!string.IsNullOrEmpty(orderby)) query = query.OrderBy(orderby); int totalCount = 0; if (count == true) totalCount = query.Count(); IEnumerable\u0026lt;MapMarker\u0026gt;? result; if (skip == null || top == null) result = await query.ToListAsync(); else result = await query.Skip(skip.Value).Take(top.Value).ToListAsync(); return (result, totalCount); } public async Task\u0026lt;bool\u0026gt; AddMapMarkerAsync(MapMarker mapMarker) { try { await _context.MapMarkers.AddAsync(mapMarker); await _context.SaveChangesAsync(); } catch (Exception ex) { return false; } return true; } public async Task\u0026lt;bool\u0026gt; UpdateMapMarkerAsync(int id, MapMarker mapMarker) { try { var oldMapMarker = _context.MapMarkers.FirstOrDefault(x =\u0026gt; x.Id == id); if (oldMapMarker == null) return false; oldMapMarker.Title = mapMarker.Title; oldMapMarker.Lat = mapMarker.Lat; oldMapMarker.Lng = mapMarker.Lng; await _context.SaveChangesAsync(); } catch (Exception ex) { return false; } return true; } public async Task\u0026lt;bool\u0026gt; DeletebyIdAsync(int id) { var mapMarker = await _context.MapMarkers.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); if (mapMarker == null) return false; _context.MapMarkers.Remove(mapMarker); await _context.SaveChangesAsync(); return true; } } The MapMarkerService class is a service that provides methods for interacting with map markers in a Blazor application. It is responsible for retrieving, adding, updating, and deleting map markers from the database.\nIndex.razor Index.razor\n@page \u0026#34;/GoogleMap\u0026#34; @inject Microsoft.JSInterop.IJSRuntime JSRuntime \u0026lt;PageTitle\u0026gt;GoogleMap\u0026lt;/PageTitle\u0026gt; \u0026lt;RadzenRow\u0026gt; \u0026lt;RadzenColumn SizeSM=\u0026#34;12\u0026#34; SizeMD=\u0026#34;12\u0026#34; SizeLG=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;RadzenStack Orientation=\u0026#34;Orientation.Horizontal\u0026#34; AlignItems=\u0026#34;AlignItems.Center\u0026#34;\u0026gt; \u0026lt;RadzenText Text=\u0026#34;GoogleMap\u0026#34; TextStyle=\u0026#34;TextStyle.H5\u0026#34; /\u0026gt; \u0026lt;/RadzenStack\u0026gt; \u0026lt;/RadzenColumn\u0026gt; \u0026lt;/RadzenRow\u0026gt; \u0026lt;RadzenRow class=\u0026#34;rz-mb-2 rz-p-2\u0026#34;\u0026gt; \u0026lt;RadzenColumn SizeSM=\u0026#34;12\u0026#34; SizeMD=\u0026#34;12\u0026#34; SizeLG=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;RadzenStack Orientation=\u0026#34;Orientation.Horizontal\u0026#34; AlignItems=\u0026#34;AlignItems.Center\u0026#34;\u0026gt; \u0026lt;RadzenGoogleMap @ref=map ApiKey=@YOUR_GOOGLE_MAP_API_KEY style=\u0026#34;height: 400px; width: 100%;\u0026#34; Options=@(new Dictionary\u0026lt;string, object\u0026gt; { { \u0026#34;disableDoubleClickZoom\u0026#34;, true } }) Zoom=@zoom Center=@mapCenter MapClick=@OnMapClick MarkerClick=@OnMarkerClick Data=\u0026#34;radzenGoogleMapMarkers\u0026#34;\u0026gt; \u0026lt;/RadzenGoogleMap\u0026gt; \u0026lt;/RadzenStack\u0026gt; \u0026lt;/RadzenColumn\u0026gt; \u0026lt;/RadzenRow\u0026gt; \u0026lt;RadzenRow\u0026gt; \u0026lt;RadzenColumn SizeSM=\u0026#34;12\u0026#34; SizeMD=\u0026#34;12\u0026#34; SizeLG=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;RadzenStack Orientation=\u0026#34;Orientation.Horizontal\u0026#34; AlignItems=\u0026#34;AlignItems.Center\u0026#34;\u0026gt; \u0026lt;RadzenText Text=\u0026#34;MapMarkers\u0026#34; TextStyle=\u0026#34;TextStyle.H5\u0026#34; /\u0026gt; \u0026lt;RadzenButton Text=\u0026#34;Create\u0026#34; Icon=\u0026#34;add_circle_outline\u0026#34; Click=\u0026#34;NavigatetoCreate\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Success\u0026#34; class=\u0026#34;rz-mb-2 rz-p-2\u0026#34; /\u0026gt; \u0026lt;/RadzenStack\u0026gt; \u0026lt;/RadzenColumn\u0026gt; \u0026lt;/RadzenRow\u0026gt; \u0026lt;RadzenDataGrid KeyProperty=\u0026#34;Id\u0026#34; IsLoading=\u0026#34;@isLoading\u0026#34; ShowPagingSummary=true Count=\u0026#34;@totalCount\u0026#34; Data=\u0026#34;@mapMarkers\u0026#34; LoadData=\u0026#34;@LoadData\u0026#34; FilterPopupRenderMode=\u0026#34;PopupRenderMode.OnDemand\u0026#34; FilterCaseSensitivity=\u0026#34;FilterCaseSensitivity.CaseInsensitive\u0026#34; FilterMode=\u0026#34;FilterMode.Advanced\u0026#34; AllowSorting=\u0026#34;true\u0026#34; AllowFiltering=\u0026#34;true\u0026#34; AllowPaging=\u0026#34;true\u0026#34; PageSize=\u0026#34;@itemPageSize\u0026#34; PagerHorizontalAlign=\u0026#34;HorizontalAlign.Center\u0026#34; TItem=\u0026#34;MapMarkerViewModel\u0026#34; ColumnWidth=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;Columns\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;MapMarkerViewModel\u0026#34; Property=\u0026#34;Id\u0026#34; Filterable=\u0026#34;false\u0026#34; Title=\u0026#34;Id\u0026#34; Frozen=\u0026#34;true\u0026#34; Width=\u0026#34;30px\u0026#34; MinWidth=\u0026#34;30px\u0026#34; TextAlign=\u0026#34;TextAlign.Center\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;MapMarkerViewModel\u0026#34; Property=\u0026#34;Title\u0026#34; Title=\u0026#34;Title\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;MapMarkerViewModel\u0026#34; Property=\u0026#34;Lat\u0026#34; Title=\u0026#34;Lat\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;MapMarkerViewModel\u0026#34; Property=\u0026#34;Lng\u0026#34; Title=\u0026#34;Lng\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;MapMarkerViewModel\u0026#34; Context=\u0026#34;mapMarker\u0026#34; Filterable=\u0026#34;false\u0026#34; Sortable=\u0026#34;false\u0026#34; Width=\u0026#34;150px\u0026#34; TextAlign=\u0026#34;TextAlign.Center\u0026#34;\u0026gt; \u0026lt;Template Context=\u0026#34;mapMarker\u0026#34;\u0026gt; \u0026lt;RadzenRow JustifyContent=\u0026#34;JustifyContent.Center\u0026#34;\u0026gt; \u0026lt;RadzenButton Icon=\u0026#34;pageview\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Info\u0026#34; Variant=\u0026#34;Variant.Flat\u0026#34; Size=\u0026#34;ButtonSize.Medium\u0026#34; Click=\u0026#34;@(args =\u0026gt; NavigatetoDetail(mapMarker.Id))\u0026#34; @onclick:stopPropagation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/RadzenButton\u0026gt; \u0026lt;RadzenButton Icon=\u0026#34;edit\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Warning\u0026#34; Variant=\u0026#34;Variant.Flat\u0026#34; Size=\u0026#34;ButtonSize.Medium\u0026#34; Click=\u0026#34;@(args =\u0026gt; NavigatetoEdit(mapMarker.Id))\u0026#34; @onclick:stopPropagation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/RadzenButton\u0026gt; \u0026lt;RadzenButton Icon=\u0026#34;delete_forever\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Danger\u0026#34; Variant=\u0026#34;Variant.Flat\u0026#34; Size=\u0026#34;ButtonSize.Medium\u0026#34; Click=\u0026#34;@(args =\u0026gt; NavigatetoDelete(mapMarker.Id))\u0026#34; @onclick:stopPropagation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/RadzenButton\u0026gt; \u0026lt;/RadzenRow\u0026gt; \u0026lt;/Template\u0026gt; \u0026lt;/RadzenDataGridColumn\u0026gt; \u0026lt;/Columns\u0026gt; \u0026lt;/RadzenDataGrid\u0026gt; @code { const int itemPageSize = 10; private bool isLoading; private int totalCount; private IEnumerable\u0026lt;MapMarkerViewModel\u0026gt;? mapMarkers; private RadzenGoogleMap map; private string YOUR_GOOGLE_MAP_API_KEY = \u0026#34;\u0026#34;; private int zoom = 3; private GoogleMapPosition mapCenter = new GoogleMapPosition() { Lat = 39.931348444036296, Lng = 32.86293982331063 }; private IEnumerable\u0026lt;RadzenGoogleMapMarker\u0026gt;? radzenGoogleMapMarkers; protected override async Task OnInitializedAsync() { isLoading = true; var result = await MapMarkerService.GetMapMarkersAsync(); mapMarkers = Mapper.Map\u0026lt;IEnumerable\u0026lt;MapMarker\u0026gt;, IEnumerable\u0026lt;MapMarkerViewModel\u0026gt;\u0026gt;(result.Result); totalCount = result.TotalCount; List\u0026lt;RadzenGoogleMapMarker\u0026gt; gMapMarkers = new(); foreach (var mapMarker in mapMarkers) gMapMarkers.Add(new() { Title = mapMarker.Title, Label = mapMarker.Title, Position = new() { Lat = mapMarker.Lat, Lng = mapMarker.Lng } }); radzenGoogleMapMarkers = gMapMarkers; isLoading = false; } private async Task LoadData(LoadDataArgs args) { isLoading = true; var result = await MapMarkerService.GetMapMarkersAsync(filter: args.Filter, top: args.Top, skip: args.Skip, orderby: args.OrderBy, count: true); mapMarkers = Mapper.Map\u0026lt;IEnumerable\u0026lt;MapMarker\u0026gt;, IEnumerable\u0026lt;MapMarkerViewModel\u0026gt;\u0026gt;(result.Result); totalCount = result.TotalCount; isLoading = false; } private void NavigatetoCreate() =\u0026gt; NavigationManager.NavigateTo(\u0026#34;/GoogleMap/Create\u0026#34;); private void NavigatetoDetail(int id) =\u0026gt; NavigationManager.NavigateTo($\u0026#34;/GoogleMap/Detail/{id}\u0026#34;); private void NavigatetoEdit(int id) =\u0026gt; NavigationManager.NavigateTo($\u0026#34;/GoogleMap/Edit/{id}\u0026#34;); private void NavigatetoDelete(int id) =\u0026gt; NavigationManager.NavigateTo($\u0026#34;/GoogleMap/Delete/{id}\u0026#34;); void OnMapClick(GoogleMapClickEventArgs args) { } async Task OnMarkerClick(RadzenGoogleMapMarker marker) { var message = $\u0026#34;Custom information about \u0026lt;b\u0026gt;{marker.Title}\u0026lt;/b\u0026gt;\u0026#34;; var code = $@\u0026#34; var map = Radzen[\u0026#39;{map.UniqueID}\u0026#39;].instance; var marker = map.markers.find(m =\u0026gt; m.title == \u0026#39;{marker.Title}\u0026#39;); if(window.infoWindow) {{window.infoWindow.close();}} window.infoWindow = new google.maps.InfoWindow({{content: \u0026#39;{message}\u0026#39;}}); setTimeout(() =\u0026gt; window.infoWindow.open(map, marker), 200); \u0026#34;; await JSRuntime.InvokeVoidAsync(\u0026#34;eval\u0026#34;, code); } } A Blazor component called GoogleMap. It includes the necessary imports, injects the IJSRuntime for JavaScript interop, and defines the UI layout using Radzen components.\nThe RadzenGoogleMap component is used to initialize the Google Map. It requires an API key to authenticate with the Google Maps API. The Options parameter is used to customize the map\u0026rsquo;s behavior, such as disabling double-click zoom. The Zoom and Center parameters define the initial zoom level and center position of the map. The MapClick and MarkerClick parameters specify the event handlers for map clicks and marker clicks, respectively. The Data parameter is used to bind the map markers.\nWhen a marker is clicked, it creates a custom information message and opens an info window on the map with the message. The RadzenGoogleMap component provides access to the underlying Google Map instance through the map variable. The marker parameter contains information about the clicked marker.\nThe GoogleMap component in this Blazor application allows users to display and interact with a Google Map. It provides features such as zooming, centering, adding markers, and handling map and marker click events. By leveraging the Radzen componentsand the Google Maps API, developers can easily integrate maps into their Blazor applications.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenGoogleMaps\n","date":"June 8, 2024","hero":"/dotnet/2024-06-08-blazor-radzen-.net8-google-maps/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-06-08-blazor-radzen-.net8-google-maps/","summary":"Blazor Radzen .NET 8 Google Maps Blazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code in C# and have it run directly in the browser.\nRadzen: Radzen is a low-code development platform that provides tools and components for building web applications. It simplifies the development process by generating code and providing a visual interface for designing user interfaces.","tags":["dotnet8",".NET8","Blazor","Radzen","Google Maps"],"title":"Blazor Radzen .NET 8 Google Maps"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Serilog Logging to Console","File and Database"],"contents":" Blazor Radzen .NET 8 Serilog Logging to Console, File and Database Logging: Logging is the process of recording events, messages, or exceptions that occur during the execution of an application. It helps developers understand the behavior of the application, diagnose issues, and track its performance. Logging is an essential aspect of software development and plays a crucial role in maintaining and troubleshooting applications.\nSerilog: Serilog is a popular logging library for .NET applications. It provides a flexible and extensible logging framework that allows developers to capture and store log events for debugging, monitoring, and analysis purposes. Serilog supports various logging sinks, including console logging, file logging, and database logging.\nConsole Logging: Console logging is a type of logging where log messages are displayed in the console window. It is useful during development and debugging.\nFile Logging: File logging is a type of logging where log messages are written to a file. It helps in storing log data for future analysis and troubleshooting.\nSQLite Database Logging: SQLite database logging is a type of logging where log messages are stored in an SQLite database. It provides a structured way to store and query log data.\nLog.cs The provided code defines a Log model class within the BlazorAppSerilogLogging.Models namespace. The Log class has the following properties:\nLog.cs\nnamespace BlazorAppSerilogLogging.Models; public class Log { public int id { get; set; } public DateTime Timestamp { get; set; } public string Level { get; set; } = string.Empty; public string Exception { get; set; } = string.Empty; public string RenderedMessage { get; set; } = string.Empty; public string Properties { get; set; } = string.Empty; } id: An integer property that represents the unique identifier of the log entry.\nTimestamp: A DateTime property that stores the timestamp when the log entry was created.\nLevel: A string property that indicates the log level of the entry (e.g., Information, Warning, Error).\nException: A string property that holds the exception details, if any, associated with the log entry.\nRenderedMessage: A string property that contains the formatted log message.\nProperties: A string property that stores additional properties or metadata related to the log entry.\nApplicationLoggerDbContext.cs The ApplicationLoggerDbContext class is a C# code that represents the database context for logging in a Blazor application using Serilog. It is responsible for managing the connection to the database and providing access to the Logs table.\nApplicationLoggerDbContext.cs\nusing BlazorAppRadzenNet8SerilogLogging.Models; using Microsoft.EntityFrameworkCore; namespace BlazorAppRadzenNet8SerilogLogging.Data; public class ApplicationLoggerDbContext : DbContext { public ApplicationLoggerDbContext(DbContextOptions\u0026lt;ApplicationLoggerDbContext\u0026gt; options) : base(options) { } public DbSet\u0026lt;Log\u0026gt; Logs =\u0026gt; Set\u0026lt;Log\u0026gt;(); protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); } } The ApplicationLoggerDbContext class is defined within the BlazorAppSerilogLogging.Data namespace. It extends the DbContext class provided by Entity Framework Core.\nThe class has a constructor that takes an instance of DbContextOptions\u0026lt;ApplicationLoggerDbContext\u0026gt; as a parameter. This allows the class to configure the database connection options.\nThe class also defines a property called Logs of type DbSet\u0026lt;Log\u0026gt;. This property represents the Logs table in the database and allows you to query and manipulate log data.\nThe OnModelCreating method is overridden but left empty in this code example. This method is used to configure the database model and define relationships between entities.\nLoggerService.cs The LoggerService class is defined within the BlazorAppSerilogLogging.Data namespace. It implements several methods for logging operations and interacts with the ApplicationLoggerDbContext class.\nLoggerService.cs\nusing BlazorAppRadzenNet8SerilogLogging.Models; using Microsoft.EntityFrameworkCore; using Radzen; using System.Linq.Dynamic.Core; namespace BlazorAppRadzenNet8SerilogLogging.Data; public class LoggerService { private readonly ILogger\u0026lt;LoggerService\u0026gt; _logger; private readonly ApplicationLoggerDbContext _loggerDbContext; public LoggerService(ILogger\u0026lt;LoggerService\u0026gt; logger, ApplicationLoggerDbContext loggerDbContext) { _logger = logger; _loggerDbContext = loggerDbContext; } public async Task\u0026lt;Log?\u0026gt; GetLogByIdAsync(int id) { _logger.LogInformation($\u0026#34;Called GetLogByIdAsync\u0026#34;, id); return await _loggerDbContext.Logs.FirstOrDefaultAsync(x =\u0026gt; x.id == id); } public async Task\u0026lt;(IEnumerable\u0026lt;Log\u0026gt; Result, int TotalCount)\u0026gt; GetLogsAsync(string? filter = default, int? top = default, int? skip = default, string? orderby = default, string? expand = default, string? select = default, bool? count = default) { _logger.LogInformation($\u0026#34;Called GetLogsAsync\u0026#34;); var query = _loggerDbContext.Logs.AsQueryable(); if (!string.IsNullOrEmpty(filter)) query = query.Where(filter); if (!string.IsNullOrEmpty(orderby)) query = query.OrderBy(orderby); int totalCount = 0; if (count == true) totalCount = query.Count(); IEnumerable\u0026lt;Log\u0026gt;? result; if (skip == null || top == null) result = await query.ToListAsync(); else result = await query.Skip(skip.Value).Take(top.Value).ToListAsync(); return (result, totalCount); } public async Task\u0026lt;bool\u0026gt; DeleteLogByIdAsync(int id) { _logger.LogInformation($\u0026#34;Called DeleteLogByIdAsync\u0026#34;, id); var log = await _loggerDbContext.Logs.FirstOrDefaultAsync(x =\u0026gt; x.id == id); if (log == null) return false; _loggerDbContext.Logs.Remove(log); await _loggerDbContext.SaveChangesAsync(); return true; } public async Task\u0026lt;bool?\u0026gt; DeleteAllLogsAsync() { _logger.LogInformation($\u0026#34;Called DeleteAllLogsAsync\u0026#34;); var all = await _loggerDbContext.Logs.ToListAsync(); _loggerDbContext.Logs.RemoveRange(all); ; await _loggerDbContext.SaveChangesAsync(); _logger.LogInformation($\u0026#34;Deleted All Logs.\u0026#34;); return true; } } The class has the following members:\n_logger: An instance of the ILogger\u0026lt;LoggerService\u0026gt; interface, which is used for logging messages.\n_loggerDbContext: An instance of the ApplicationLoggerDbContext class, which represents the database context for logging.\nThe constructor of the LoggerService class takes in an ILogger\u0026lt;LoggerService\u0026gt; instance and an ApplicationLoggerDbContext instance as parameters. These dependencies are injected into the class using dependency injection.\nIndex.razor Index.razor is a Blazor component that displays logs retrieved from a logging service. It allows users to view and delete logs. The logs are fetched asynchronously and displayed in a table format.\nIndex.razor\n@page \u0026#34;/Log\u0026#34; @inject DialogService DialogService \u0026lt;PageTitle\u0026gt;Logs\u0026lt;/PageTitle\u0026gt; \u0026lt;RadzenRow\u0026gt; \u0026lt;RadzenColumn SizeSM=\u0026#34;12\u0026#34; SizeMD=\u0026#34;12\u0026#34; SizeLG=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;RadzenStack Orientation=\u0026#34;Orientation.Horizontal\u0026#34; AlignItems=\u0026#34;AlignItems.Center\u0026#34;\u0026gt; \u0026lt;RadzenText Text=\u0026#34;Logs\u0026#34; TextStyle=\u0026#34;TextStyle.H5\u0026#34; /\u0026gt; \u0026lt;RadzenButton Text=\u0026#34;DELETE ALL LOGS\u0026#34; Icon=\u0026#34;delete_forever\u0026#34; Click=\u0026#34;DeleteAllLogs\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Danger\u0026#34; class=\u0026#34;rz-mb-2 rz-p-2\u0026#34; /\u0026gt; \u0026lt;/RadzenStack\u0026gt; \u0026lt;/RadzenColumn\u0026gt; \u0026lt;/RadzenRow\u0026gt; \u0026lt;RadzenDataGrid KeyProperty=\u0026#34;id\u0026#34; IsLoading=\u0026#34;@isLoading\u0026#34; ShowPagingSummary=true Count=\u0026#34;@totalCount\u0026#34; Data=\u0026#34;@logs\u0026#34; LoadData=\u0026#34;@LoadData\u0026#34; FilterPopupRenderMode=\u0026#34;PopupRenderMode.OnDemand\u0026#34; FilterCaseSensitivity=\u0026#34;FilterCaseSensitivity.CaseInsensitive\u0026#34; FilterMode=\u0026#34;FilterMode.Advanced\u0026#34; AllowSorting=\u0026#34;true\u0026#34; AllowFiltering=\u0026#34;true\u0026#34; AllowPaging=\u0026#34;true\u0026#34; PageSize=\u0026#34;@itemPageSize\u0026#34; PagerHorizontalAlign=\u0026#34;HorizontalAlign.Center\u0026#34; TItem=\u0026#34;LogViewModel\u0026#34; ColumnWidth=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;Columns\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;LogViewModel\u0026#34; Property=\u0026#34;id\u0026#34; Filterable=\u0026#34;false\u0026#34; Title=\u0026#34;Id\u0026#34; Frozen=\u0026#34;true\u0026#34; Width=\u0026#34;30px\u0026#34; MinWidth=\u0026#34;30px\u0026#34; TextAlign=\u0026#34;TextAlign.Center\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;LogViewModel\u0026#34; Property=\u0026#34;Timestamp\u0026#34; Title=\u0026#34;Timestamp\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;LogViewModel\u0026#34; Property=\u0026#34;Level\u0026#34; Title=\u0026#34;Level\u0026#34; Context=\u0026#34;log\u0026#34;\u0026gt; \u0026lt;Template\u0026gt; \u0026lt;span class=\u0026#34;text-@Helpers.LogEventLevelHelper.GetBootstrapUIClass(log.Level)\u0026#34;\u0026gt; @log.Level \u0026lt;/span\u0026gt; \u0026lt;/Template\u0026gt; \u0026lt;/RadzenDataGridColumn\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;LogViewModel\u0026#34; Property=\u0026#34;Exception\u0026#34; Title=\u0026#34;Exception\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;LogViewModel\u0026#34; Property=\u0026#34;RenderedMessage\u0026#34; Title=\u0026#34;RenderedMessage\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;LogViewModel\u0026#34; Property=\u0026#34;Properties\u0026#34; Title=\u0026#34;Properties\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;LogViewModel\u0026#34; Context=\u0026#34;log\u0026#34; Filterable=\u0026#34;false\u0026#34; Sortable=\u0026#34;false\u0026#34; Width=\u0026#34;150px\u0026#34; TextAlign=\u0026#34;TextAlign.Center\u0026#34;\u0026gt; \u0026lt;Template Context=\u0026#34;log\u0026#34;\u0026gt; \u0026lt;RadzenRow JustifyContent=\u0026#34;JustifyContent.Center\u0026#34;\u0026gt; \u0026lt;RadzenButton Icon=\u0026#34;pageview\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Info\u0026#34; Variant=\u0026#34;Variant.Flat\u0026#34; Size=\u0026#34;ButtonSize.Medium\u0026#34; Click=\u0026#34;@(args =\u0026gt; NavigatetoDetail(log.id))\u0026#34; @onclick:stopPropagation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/RadzenButton\u0026gt; \u0026lt;RadzenButton Icon=\u0026#34;delete_forever\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Danger\u0026#34; Variant=\u0026#34;Variant.Flat\u0026#34; Size=\u0026#34;ButtonSize.Medium\u0026#34; Click=\u0026#34;@(args =\u0026gt; NavigatetoDelete(log.id))\u0026#34; @onclick:stopPropagation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/RadzenButton\u0026gt; \u0026lt;/RadzenRow\u0026gt; \u0026lt;/Template\u0026gt; \u0026lt;/RadzenDataGridColumn\u0026gt; \u0026lt;/Columns\u0026gt; \u0026lt;/RadzenDataGrid\u0026gt; @code { const int itemPageSize = 10; private bool isLoading; private int totalCount; private IEnumerable\u0026lt;LogViewModel\u0026gt;? logs; private async Task LoadData(LoadDataArgs args) { isLoading = true; var result = await LoggerService.GetLogsAsync(filter: args.Filter, top: args.Top, skip: args.Skip, orderby: args.OrderBy, count: true); logs = Mapper.Map\u0026lt;IEnumerable\u0026lt;Log\u0026gt;, IEnumerable\u0026lt;LogViewModel\u0026gt;\u0026gt;(result.Result); totalCount = result.TotalCount; isLoading = false; } private async Task DeleteAllLogs() { var dialogResult = await DialogService.Confirm(\u0026#34;Are you sure DELETE All Logs?\u0026#34;, \u0026#34;Delete All Logs\u0026#34;, new ConfirmOptions { OkButtonText = \u0026#34;Ok\u0026#34;, CancelButtonText = \u0026#34;Cancel\u0026#34; }); if (dialogResult == true) { var deleteAllLogsResult = await LoggerService.DeleteAllLogsAsync(); if (deleteAllLogsResult == true) NavigationManager.NavigateTo(\u0026#34;/Log\u0026#34;, true); } } private void NavigatetoDetail(int id) =\u0026gt; NavigationManager.NavigateTo($\u0026#34;/Log/Detail/{id}\u0026#34;); private void NavigatetoDelete(int id) =\u0026gt; NavigationManager.NavigateTo($\u0026#34;/Log/Delete/{id}\u0026#34;); } This code block is executed when the component is initialized. It calls the GetLogsAsync method of the LoggerService to fetch the logs asynchronously. The retrieved logs are then mapped to LogViewModel objects using AutoMapper. The logs variable is assigned the mapped logs.\nProgram.cs Program.cs\nbuilder.Host.UseSerilog((ctx, lc) =\u0026gt; lc .MinimumLevel.Information() //.WriteTo.Console(new JsonFormatter(), restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.Console(restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.Seq(\u0026#34;http://localhost:5001\u0026#34;, restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.File(serilogFileLoggerFilePath, restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Verbose, rollingInterval: RollingInterval.Hour, encoding: System.Text.Encoding.UTF8) .WriteTo.SQLite(sqliteDbFilePath, tableName: \u0026#34;Logs\u0026#34;, restrictedToMinimumLevel: builder.Environment.IsDevelopment() ? Serilog.Events.LogEventLevel.Information : Serilog.Events.LogEventLevel.Warning, storeTimestampInUtc: false, batchSize: builder.Environment.IsDevelopment() ? (uint)1 : (uint)100, retentionPeriod: new TimeSpan(0, 1, 0, 0, 0), maxDatabaseSize: 10) ); Retrieves the connection string for the SQLite logger from the configuration file and modifies it to include the current directory path.\nConfigures Serilog with various log sinks, including console logging, Seq logging, file logging, and SQLite database logging. It sets the minimum log level based on the application environment.\nRegisters the ApplicationLoggerDbContext and ApplicationDbContext services in the dependency injection container. It configures the ApplicationLoggerDbContext to use the SQLite logger connection string and the ApplicationDbContext to use an in-memory database.\nWe discussed the key concepts of logging, console logging, file logging, and SQLite database logging. We also examined the code structure and provided code examples to illustrate the configuration process. By understanding this code, developers can effectively set up logging in their Blazor applications using Serilog.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenNet8SerilogLogging\n","date":"May 29, 2024","hero":"/dotnet/2024-05-29-blazor-radzen-.net8-serilog-logging/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-05-29-blazor-radzen-.net8-serilog-logging/","summary":"Blazor Radzen .NET 8 Serilog Logging to Console, File and Database Logging: Logging is the process of recording events, messages, or exceptions that occur during the execution of an application. It helps developers understand the behavior of the application, diagnose issues, and track its performance. Logging is an essential aspect of software development and plays a crucial role in maintaining and troubleshooting applications.\nSerilog: Serilog is a popular logging library for .","tags":["dotnet8",".NET8","Blazor","Radzen","Serilog Logging to Console","File and Database"],"title":"Blazor Radzen .NET 8 Serilog Logging to Console, File and Database"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Html Editor"],"contents":" Blazor Radzen .NET 8 Html Editor Blazor: Blazor is a framework for building interactive web UIs using C# instead of JavaScript. Radzen: Radzen is a suite of tools that provides UI components for Blazor applications. .NET 8: .NET 8 is the latest version of the .NET framework that supports Blazor development. Html Editor: An HTML editor is a tool that enables users to create, edit, and format HTML content.\nThe RadzenHtmlEditor is a powerful tool that allows users to input and edit HTML content within a Blazor application. We will explore its key concepts, code structure, and provide code examples to illustrate its functionality.\nCreate.razor The implementation of the RadzenHtmlEditor component in a Blazor application. The component is bound to a blogPostViewModel.Content property, allowing users to manipulate the HTML content within the editor.\nCreate.razor\n... \u0026lt;RadzenHtmlEditor @bind-Value=@blogPostViewModel.Content Input=@OnInput Change=@OnChange Paste=@OnPaste Execute=@OnExecute UploadUrl=\u0026#34;upload/image\u0026#34; /\u0026gt; ... @code { ... void OnPaste(HtmlEditorPasteEventArgs args) { } void OnChange(string html) { } void OnInput(string html) { } void OnExecute(HtmlEditorExecuteEventArgs args) { } ... } OnPaste: Handles the paste event when content is pasted into the editor.\nOnChange: Handles the change event when the HTML content is modified.\nOnInput: Handles the input event when the HTML content is being inputted.\nOnExecute: Handles the execute event when specific actions are executed within the editor.\nProgram.cs Program.cs\n... builder.Services.AddControllersWithViews(); builder.Services.AddRazorPages(); builder.Services.Configure\u0026lt;Microsoft.AspNetCore.Http.Features.FormOptions\u0026gt;(options =\u0026gt; { options.MultipartBodyLengthLimit = long.MaxValue; }); builder.Services.AddRazorComponents() .AddInteractiveServerComponents(); ... UploadController.cs The UploadController.cs file in a Blazor application, focuses on uploading images to the server using a controller in a Blazor application.\nUploadController.cs\n... [HttpPost(\u0026#34;upload/image\u0026#34;)] public IActionResult Image(IFormFile file) { try { var fileName = $\u0026#34;upload-{DateTime.Today.ToString(\u0026#34;yyyy-MM-dd\u0026#34;)}-{Guid.NewGuid()}{Path.GetExtension(file.FileName)}\u0026#34;; var filePath = Path.Combine(environment.WebRootPath, fileName); using (var stream = new FileStream(filePath, FileMode.Create)) { // Save the file file.CopyTo(stream); // Return the URL of the file var url = Url.Content($\u0026#34;~/{fileName}\u0026#34;); return Ok(new { Url = url }); } } catch (Exception ex) { return StatusCode(500, ex.Message); } } ... The UploadController.cs file contains a method named Image that handles image uploads. It accepts an IFormFile parameter representing the file to be uploaded. It generates a unique file name based on the current date and a GUID, saves the uploaded file to the server using the generated file name, constructs the URL of the uploaded file, returns the URL of the uploaded file if the upload is successful or an error message if an exception occurs.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenHtmlEditor\n","date":"May 15, 2024","hero":"/dotnet/2024-05-15-blazor-radzen-.net8-htmleditor/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-05-15-blazor-radzen-.net8-htmleditor/","summary":"Blazor Radzen .NET 8 Html Editor Blazor: Blazor is a framework for building interactive web UIs using C# instead of JavaScript. Radzen: Radzen is a suite of tools that provides UI components for Blazor applications. .NET 8: .NET 8 is the latest version of the .NET framework that supports Blazor development. Html Editor: An HTML editor is a tool that enables users to create, edit, and format HTML content.","tags":["dotnet8",".NET8","Blazor","Radzen","Html Editor"],"title":"Blazor Radzen .NET 8 Html Editor"},{"categories":["dotnet8",".NET8","Blazor","Radzen","Multiple Themes Dark and Light Mode"],"contents":" Blazor Radzen .NET 8 Multiple Themes Dark and Light Mode We are implementing dynamic theme switching in a Blazor application using Radzen. The code allows users to switch between different themes (e.g., default, dark, humanistic, software, standard, material) based on their preference.\n.NET 8: .NET 8 is a version of the .NET framework that provides developers with a platform to build various types of applications. It offers improved performance, security, and features for developing modern applications.\nBlazor: Blazor is a web framework by Microsoft that allows developers to build interactive web applications using C# and .NET instead of JavaScript. It enables developers to create single-page applications with rich user interfaces.\nRadzen: Radzen is a low-code development platform that simplifies and accelerates web and mobile application development. It provides tools and components to build responsive and customizable applications quickly.\nDark and Light Theme: Dark and Light themes refer to the visual appearance of an application. Dark themes use darker colors for backgrounds and lighter colors for text, providing a sleek and modern look. Light themes, on the other hand, use lighter colors for backgrounds and darker colors for text, offering a more traditional and bright appearance. Users can choose between these themes based on their preference and visual comfort.\nInformation\nFree Themes\nMaterial:\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;_content/Radzen.Blazor/css/material.css\u0026quot;\u0026gt; Standard:\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;_content/Radzen.Blazor/css/standard.css\u0026quot;\u0026gt; Default:\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;_content/Radzen.Blazor/css/default.css\u0026quot;\u0026gt; Humanistic:\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;_content/Radzen.Blazor/css/humanistic.css\u0026quot;\u0026gt; Software:\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;_content/Radzen.Blazor/css/software.css\u0026quot;\u0026gt; Dark:\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;_content/Radzen.Blazor/css/dark.css\u0026quot;\u0026gt; Premium Themes\nMaterial 3 Fluent Material 3 Dark Material Dark Fluent Dark Explore free theming options in Radzen Blazor Components demos.\nPremium themes can be used with an active Radzen Professional or Enterprise subscription.\nMore: https://blazor.radzen.com/themes\nApp.razor App.razor\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bootstrap/bootstrap.min.css\u0026#34; /\u0026gt; @* THEME CSS *@ \u0026lt;Theme /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;favicon.png\u0026#34; /\u0026gt; \u0026lt;HeadOutlet @rendermode=\u0026#34;InteractiveServer\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;Routes @rendermode=\u0026#34;InteractiveServer\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;_content/Radzen.Blazor/Radzen.Blazor.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;_framework/blazor.web.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; It includes the necessary HTML structure and references to CSS files for styling. Notably, it contains a placeholder \u0026lt;Theme /\u0026gt; where the theme-specific CSS will be injected dynamically based on the selected theme (dark or light mode).\nMainLayout.razor MainLayout.razor\n... \u0026lt;ThemeComponent /\u0026gt; ... To implement Dark and Light Mode with Multiple Themes in Blazor using Radzen, we need to create a ThemeComponent that handles the theme switching logic. This component will dynamically apply the selected theme to the application based on user preference.\nTheme.razor Theme.razor\n@inject NavigationManager NavigationManager @inject ThemeService ThemeService \u0026lt;link href=\u0026#34;@Href\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; @* //////// THEMES \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/default.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/dark.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/humanistic.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/software.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/standard.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;_content/Radzen.Blazor/css/material-base.css\u0026#34;\u0026gt; *@ @code { //string Href =\u0026gt; $\u0026#34;_content/Radzen.Blazor/css/{ThemeService.CurrentTheme}-base.css\u0026#34;; string Href =\u0026gt; $\u0026#34;_content/Radzen.Blazor/css/{ThemeService.CurrentTheme}.css\u0026#34;; protected override void OnInitialized() { #if !RADZEN ThemeService.Initialize(NavigationManager); #endif } } The code begins by injecting the NavigationManager and ThemeService into the component. It then includes a \u0026lt;link\u0026gt; tag that references the stylesheet based on the current theme selected. The available themes are predefined in the commented section.\nThe Href property dynamically generates the path to the CSS file based on the current theme selected in the ThemeService. The OnInitialized method initializes the theme service, but only if the RADZEN preprocessor directive is not defined.\nThemeComponent.razor ThemeComponent.razor\n@inject ThemeService ThemeService @inject NavigationManager UriHelper \u0026lt;RadzenLabel Text=\u0026#34;Select Theme\u0026#34; Component=\u0026#34;DropDownTextValueProperties\u0026#34; class=\u0026#34;rz-mr-2\u0026#34; /\u0026gt; \u0026lt;RadzenDropDown TValue=\u0026#34;string\u0026#34; Value=\u0026#34;@ThemeService.CurrentTheme\u0026#34; Data=\u0026#34;@ThemeService.Themes\u0026#34; TextProperty=\u0026#34;Text\u0026#34; ValueProperty=\u0026#34;Value\u0026#34; Name=\u0026#34;DropDownTextValueProperties\u0026#34; Change=\u0026#34;@ChangeTheme\u0026#34; /\u0026gt; @code { protected override void OnInitialized() { ThemeService.Initialize(UriHelper); } void ChangeTheme(object value) { ThemeService.Change(UriHelper, $\u0026#34;{value}\u0026#34;); } } By injecting the ThemeService and UriHelper services into the component. It then displays a label prompting the user to select a theme using a dropdown list populated with theme options. The OnInitialized method initializes the ThemeService with the UriHelper. When a user selects a theme from the dropdown, the ChangeTheme method is called to update the selected theme using the ThemeService.\nThemeService.cs ThemeService.cs\nusing System.Web; using Microsoft.AspNetCore.Components; namespace BlazorAppRadzenMultipleThemesDarkAndLightMode; public class ThemeService { public class Theme { public string Text { get; set; } public string Value { get; set; } } public static readonly Theme[] Themes = new[] { new Theme { Text = \u0026#34;Material\u0026#34;, Value = \u0026#34;material\u0026#34; }, new Theme { Text = \u0026#34;Standard\u0026#34;, Value = \u0026#34;standard\u0026#34; }, new Theme { Text = \u0026#34;Default\u0026#34;, Value = \u0026#34;default\u0026#34; }, new Theme { Text = \u0026#34;Humanistic\u0026#34;, Value = \u0026#34;humanistic\u0026#34; }, new Theme { Text = \u0026#34;Software\u0026#34;, Value = \u0026#34;software\u0026#34; }, new Theme { Text = \u0026#34;Dark\u0026#34;, Value=\u0026#34;dark\u0026#34; } }; public const string DefaultTheme = \u0026#34;standard\u0026#34;; public const string QueryParameter = \u0026#34;theme\u0026#34;; public string CurrentTheme { get; set; } = DefaultTheme; public void Initialize(NavigationManager navigationManager) { var uri = new Uri(navigationManager.ToAbsoluteUri(navigationManager.Uri).ToString()); var query = HttpUtility.ParseQueryString(uri.Query); var value = query.Get(QueryParameter); if (Themes.Any(theme =\u0026gt; theme.Value == value)) { CurrentTheme = value; } } public void Change(NavigationManager navigationManager, string theme) { var url = navigationManager.GetUriWithQueryParameters(navigationManager.Uri, new Dictionary\u0026lt;string, object\u0026gt;() { { QueryParameter, theme } }); navigationManager.NavigateTo(url, true); } } The NavigationManager is injected into the component, and the Initialize method of the ThemeService is called to initialize the current theme based on the query parameter in the URL.\nThe NavigationManager is injected into the component, and the Change method of the ThemeService is called to change the theme. The updated URL with the new theme is navigated to.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenMultipleThemesDarkAndLightMode\n","date":"May 4, 2024","hero":"/dotnet/2024-05-04-blazor-radzen-.net8-multiple-themes-dark-and-light-mode/blazor_radzen_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-05-04-blazor-radzen-.net8-multiple-themes-dark-and-light-mode/","summary":"Blazor Radzen .NET 8 Multiple Themes Dark and Light Mode We are implementing dynamic theme switching in a Blazor application using Radzen. The code allows users to switch between different themes (e.g., default, dark, humanistic, software, standard, material) based on their preference.\n.NET 8: .NET 8 is a version of the .NET framework that provides developers with a platform to build various types of applications. It offers improved performance, security, and features for developing modern applications.","tags":["dotnet8",".NET8","Blazor","Radzen","Multiple Themes Dark and Light Mode"],"title":"Blazor Radzen .NET 8 Multiple Themes Dark and Light Mode"},{"categories":["dotnet8",".NET8","Autocompile Sass and Less"],"contents":" Blazor .NET 8 Autocompile Sass and Less Sass: Sass is a CSS preprocessor that simplifies styling by providing features like variables, nesting, and mixins. It allows for more organized and efficient CSS code.\nLess: Less is another CSS preprocessor that offers similar features to Sass, enabling developers to write cleaner and more maintainable stylesheets.\nAutocompile: Autocompilation refers to the automatic conversion of Sass or Less files into standard CSS files whenever changes are made to the source files. This process eliminates the need for manual compilation and ensures that the styles are always up to date.\nTo achieve Sass and Less autocompilation in a Blazor .NET 8 project, we need to follow these key steps:\nInitialize npm in the project directory. Install the necessary Node.js packages, such as node-sass for Sass and lessc for Less. Update the package.json file to include scripts for compiling Sass and Less files into CSS. Configure the scripts to watch for changes in the Sass and Less files and automatically compile them into CSS in the wwwroot directory. npm init npm install node-sass npm install lessc package.json: { ... \u0026#34;scripts\u0026#34;: { ... \u0026#34;sass\u0026#34;: \u0026#34;node-sass styles/ -o ../wwwroot/css/\u0026#34; \u0026#34;less\u0026#34;: \u0026#34;lessc styles/mainless.less ../wwwroot/css/mainless.css --verbose\u0026#34; ... }, ... } To install packages and run the compilation scripts, use:\nnpm install npm run sass npm run less .csproj for Autocompile ... \u0026lt;!--Npm Install and Run (\\nodepack\u0026gt;): \u0026#39;npm install\u0026#39; and \u0026#39;npm run sass\u0026#39; or \u0026#39;npm run less\u0026#39;--\u0026gt; \u0026lt;Target Name=\u0026#34;DebugEnsureNodeEnv\u0026#34; BeforeTargets=\u0026#34;Build\u0026#34; Condition=\u0026#34; \u0026#39;$(Configuration)\u0026#39; == \u0026#39;Debug\u0026#39; And !Exists(\u0026#39;nodepack\\node_modules\u0026#39;) \u0026#34;\u0026gt; \u0026lt;Exec Command=\u0026#34;node --version\u0026#34; ContinueOnError=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Output TaskParameter=\u0026#34;ExitCode\u0026#34; PropertyName=\u0026#34;ErrorCode\u0026#34; /\u0026gt; \u0026lt;/Exec\u0026gt; \u0026lt;Error Condition=\u0026#34;\u0026#39;$(ErrorCode)\u0026#39; != \u0026#39;0\u0026#39;\u0026#34; Text=\u0026#34;Node.js is required to build and run this project. To continue, please install Node.js from https://nodejs.org/, and then restart your command prompt or IDE.\u0026#34; /\u0026gt; \u0026lt;Message Importance=\u0026#34;high\u0026#34; Text=\u0026#34;Restoring dependencies using \u0026#39;npm\u0026#39;. This may take several minutes...\u0026#34; /\u0026gt; \u0026lt;Exec WorkingDirectory=\u0026#34;nodepack\u0026#34; Command=\u0026#34;npm install\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt; \u0026lt;Target Name=\u0026#34;RunSass\u0026#34; BeforeTargets=\u0026#34;Build\u0026#34;\u0026gt; \u0026lt;Exec Command=\u0026#34;npm run sass\u0026#34; WorkingDirectory=\u0026#34;nodepack\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt; \u0026lt;Target Name=\u0026#34;RunLess\u0026#34; BeforeTargets=\u0026#34;Build\u0026#34;\u0026gt; \u0026lt;Exec Command=\u0026#34;npm run less\u0026#34; WorkingDirectory=\u0026#34;nodepack\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt; ... The first target, DebugEnsureNodeEnv, checks for the existence of Node.js and installs dependencies if needed. The subsequent targets, RunSass and RunLess, execute the respective Sass and Less compilation scripts before the build process begins.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppSassLessComp\n","date":"April 16, 2024","hero":"/dotnet/2024-04-16-blazor-.net8-autocompile-sass-and-less/blazor_dotnet8_sass_less.jpg","permalink":"https://akifmt.github.io/dotnet/2024-04-16-blazor-.net8-autocompile-sass-and-less/","summary":"Blazor .NET 8 Autocompile Sass and Less Sass: Sass is a CSS preprocessor that simplifies styling by providing features like variables, nesting, and mixins. It allows for more organized and efficient CSS code.\nLess: Less is another CSS preprocessor that offers similar features to Sass, enabling developers to write cleaner and more maintainable stylesheets.\nAutocompile: Autocompilation refers to the automatic conversion of Sass or Less files into standard CSS files whenever changes are made to the source files.","tags":["dotnet8",".NET8","Blazor","Autocompile Sass and Less"],"title":"Blazor .NET 8 Autocompile Sass and Less"},{"categories":["dotnet8",".NET8","Microservices 2 Blazor Client Ocelot Gateway and Securing API with Duende Identity Server"],"contents":" Blazor .NET 8 Microservices 2 Blazor Client Ocelot Gateway and Securing API with Duende Identity Server Part 1: Demonstrates ASP.NET Core Web API, Blazor Web App and Securing API with Duende Identity Server Click here Part 1\nPart 2: Demonstrates Ocelot Gateway in a Blazor .NET 8 application. Click here Part 2\nProjects Project Name Port Template Microser.IdS :5001 Duende IdentityServer with Entity Framework Stores (Duende Software) Microser.API.Weather :6001 ASP.NET Core Web API Microser.ApiGateway :6501 ASP.NET Core Empty Microser.BlazorAppClient :7001 Blazor Web App Microser.ApiGateway - Ocelot Gateway Project Ocelot is a lightweight API Gateway that sits in front of your microservices architecture, providing features like routing, load balancing, authentication, and more. By setting up the Ocelot middleware, adding authentication services, and loading the Ocelot configuration, developers can create a robust API Gateway for their applications. Understanding and implementing Ocelot in your projects can enhance security, scalability, and routing capabilities.\nProgram.cs\nusing Microsoft.IdentityModel.Tokens; using Ocelot.DependencyInjection; using Ocelot.Middleware; internal class Program { private static void Main(string[] args) { var builder = WebApplication.CreateBuilder(args); builder.Configuration.AddJsonFile(\u0026#34;ocelot.json\u0026#34;, optional: false, reloadOnChange: true); var authenticationProviderKey = \u0026#34;IdentityApiKey\u0026#34;; builder.Services.AddAuthentication() .AddJwtBearer(authenticationProviderKey, x =\u0026gt; { x.Authority = \u0026#34;https://localhost:5001\u0026#34;; x.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false }; }); builder.Services.AddOcelot(builder.Configuration); var app = builder.Build(); app.UseOcelot().Wait(); app.Run(); } } It sets up the Ocelot middleware, adds authentication services for JWT Bearer authentication, and loads the Ocelot configuration from the ocelot.json file.\nocelot.json\n{ \u0026#34;Routes\u0026#34;: [ { \u0026#34;DownstreamPathTemplate\u0026#34;: \u0026#34;/api/weatherforecast\u0026#34;, \u0026#34;DownstreamScheme\u0026#34;: \u0026#34;https\u0026#34;, \u0026#34;DownstreamHostAndPorts\u0026#34;: [ { \u0026#34;Host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;Port\u0026#34;: 6001 } ], \u0026#34;UpstreamPathTemplate\u0026#34;: \u0026#34;/weatherforecast\u0026#34;, \u0026#34;UpstreamHttpMethod\u0026#34;: [ \u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34; ], \u0026#34;AuthenticationOptions\u0026#34;: { \u0026#34;AuthenticationProviderKey\u0026#34;: \u0026#34;IdentityApiKey\u0026#34;, \u0026#34;AllowedScopes\u0026#34;: [] } }, { \u0026#34;DownstreamPathTemplate\u0026#34;: \u0026#34;/api/weatherforecast/{id}\u0026#34;, \u0026#34;DownstreamScheme\u0026#34;: \u0026#34;https\u0026#34;, \u0026#34;DownstreamHostAndPorts\u0026#34;: [ { \u0026#34;Host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;Port\u0026#34;: 6001 } ], \u0026#34;UpstreamPathTemplate\u0026#34;: \u0026#34;/weatherforecast/{id}\u0026#34;, \u0026#34;UpstreamHttpMethod\u0026#34;: [ \u0026#34;GET\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34; ], \u0026#34;AuthenticationOptions\u0026#34;: { \u0026#34;AuthenticationProviderKey\u0026#34;: \u0026#34;IdentityApiKey\u0026#34;, \u0026#34;AllowedScopes\u0026#34;: [] } }, ] } The provided JSON snippet represents the configuration for two routes in the Ocelot Gateway. Each route defines how requests are handled and secured when interacting with the downstream service.\nRoutes: Define the mapping between upstream and downstream paths along with associated configurations. DownstreamPathTemplate: Specifies the path template of the downstream service. DownstreamScheme: Indicates the scheme (HTTP/HTTPS) of the downstream service. DownstreamHostAndPorts: Specifies the host and port of the downstream service. UpstreamPathTemplate: Defines the path template of the upstream request. UpstreamHttpMethod: Specifies the HTTP methods allowed for the upstream path. AuthenticationOptions: Contains settings related to authentication and authorization. AuthenticationProviderKey: Identifies the authentication provider to be used. AllowedScopes: Lists the scopes allowed for accessing the route.\nThe provided Ocelot Gateway configuration snippet demonstrates how routes are defined to secure APIs using Duende Identity Server. By specifying the path mappings, HTTP methods, and authentication settings, developers can ensure secure communication between the client and downstream services. This setup enhances the overall security and control over API access within a microservices architecture.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/Microser\n","date":"April 5, 2024","hero":"/dotnet/2024-04-05-blazor-.net8-microservices-2-blazor-client-ocelot-gateway-and-securing-api-with-duende-identity-server/blazor_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-04-05-blazor-.net8-microservices-2-blazor-client-ocelot-gateway-and-securing-api-with-duende-identity-server/","summary":"Blazor .NET 8 Microservices 2 Blazor Client Ocelot Gateway and Securing API with Duende Identity Server Part 1: Demonstrates ASP.NET Core Web API, Blazor Web App and Securing API with Duende Identity Server Click here Part 1\nPart 2: Demonstrates Ocelot Gateway in a Blazor .NET 8 application. Click here Part 2\nProjects Project Name Port Template Microser.IdS :5001 Duende IdentityServer with Entity Framework Stores (Duende Software) Microser.API.Weather :6001 ASP.","tags":["dotnet8",".NET8","Blazor","Microservices 2 Blazor Client Ocelot Gateway and Securing API with Duende Identity Server"],"title":"Blazor .NET 8 Microservices 2 Blazor Client Ocelot Gateway and Securing API with Duende Identity Server"},{"categories":["dotnet8",".NET8","Microservices Blazor Client and Securing API with Duende Identity Server"],"contents":" Blazor .NET 8 Microservices Blazor Client and Securing API with Duende Identity Server A Blazor .NET 8 microservices client application and integrates it with Duende Identity Server for securing the API endpoints. The code demonstrates the configuration of services, authentication, authorization, and HTTP request pipeline setup.\nBlazor: Blazor is a framework for building interactive web UIs using C# instead of JavaScript. It allows developers to create web applications using .NET and C#.\n.NET 8: .NET 8 is a version of the .NET framework that provides a platform for building various types of applications, including web, desktop, and mobile applications.\nMicroservices: Microservices architecture involves breaking down an application into smaller, independent services that can be developed, deployed, and scaled independently.\nSecuring API: Securing APIs involves implementing authentication and authorization mechanisms to control access to API endpoints.\nIdentity Server: Identity Server is an open-source identity and access control solution for .NET applications. Duende Identity Server is a fork of Identity Server with additional features and improvements.\nAPI Controller: An API controller is a class in a web application that handles HTTP requests and returns HTTP responses. It contains methods (also known as actions) that correspond to different HTTP verbs (GET, POST, PUT, DELETE) and perform specific operations.\nProjects Project Name Port Template Microser.IdS :5001 Duende IdentityServer with Entity Framework Stores (Duende Software) Microser.API.Weather :6001 ASP.NET Core Web API Microser.BlazorAppClient :7001 Blazor Web App Test Users Role Username Password admin alice alice user bob bob Microser.API.Weather - Web API Project A Blazor .NET 8 Microservices project with authentication and authorization using JWT tokens. By configuring services for controllers, Swagger documentation, authentication, and authorization policies, the application ensures secure access to APIs while enabling efficient development and documentation processes.\nProgram.cs\nusing Microsoft.IdentityModel.Tokens; internal class Program { private static void Main(string[] args) { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); builder.Services.AddAuthentication(\u0026#34;Bearer\u0026#34;) .AddJwtBearer(\u0026#34;Bearer\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001\u0026#34;; options.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false }; }); builder.Services.AddAuthorization(options =\u0026gt; { options.AddPolicy(\u0026#34;ClientIdPolicy\u0026#34;, policy =\u0026gt; policy.RequireClaim(\u0026#34;client_id\u0026#34;, \u0026#34;microser_api_weather\u0026#34;, \u0026#34;dotnet_blazor_serverapp\u0026#34;)); }); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseHttpsRedirection(); app.UseAuthentication(); app.UseAuthorization(); app.MapControllers(); app.Run(); } } Initializes a WebApplication builder, adds necessary services like controllers, Swagger, authentication, and authorization. It configures JWT bearer authentication with Duende Identity Server, sets up authorization policies, and defines the request pipeline. In development mode, it enables Swagger UI for API testing.\nWeatherForecastController.cs\nusing Microser.Core.Models; using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Mvc; namespace Microser.API.Weather.Controllers; [Authorize(Policy = \u0026#34;ClientIdPolicy\u0026#34;)] [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class WeatherForecastController : ControllerBase { private readonly ILogger\u0026lt;WeatherForecastController\u0026gt; _logger; public WeatherForecastController(ILogger\u0026lt;WeatherForecastController\u0026gt; logger) { _logger = logger; } [HttpGet(Name = \u0026#34;GetWeatherForecasts\u0026#34;)] public ActionResult\u0026lt;IEnumerable\u0026lt;WeatherForecast\u0026gt;\u0026gt; Get() { return Ok(Data.WeatherForecasts); } [HttpGet(\u0026#34;{id}\u0026#34;, Name = \u0026#34;GetWeatherForecast\u0026#34;)] public ActionResult\u0026lt;WeatherForecast\u0026gt; Get(int id) { var item = Data.WeatherForecasts.FirstOrDefault(x =\u0026gt; x.Id == id); if (item == null) return NotFound(); return Ok(item); } [HttpPost(Name = \u0026#34;PostWeatherForecast\u0026#34;)] public ActionResult\u0026lt;WeatherForecast\u0026gt; Post(WeatherForecast weatherForecast) { var last = Data.WeatherForecasts.LastOrDefault(); if (last == null) weatherForecast.Id = 1; else weatherForecast.Id = last.Id + 1; Data.WeatherForecasts.Add(weatherForecast); return new CreatedAtRouteResult(\u0026#34;GetWeatherForecast\u0026#34;, new { id = weatherForecast.Id }, weatherForecast); } [HttpPut(\u0026#34;{id}\u0026#34;, Name = \u0026#34;PutWeatherForecast\u0026#34;)] public ActionResult\u0026lt;WeatherForecast\u0026gt; Put(int id, WeatherForecast weatherForecast) { var item = Data.WeatherForecasts.FirstOrDefault(x =\u0026gt; x.Id == id); if (item == null) return NotFound(); item.Date = weatherForecast.Date; item.TemperatureC = weatherForecast.TemperatureC; item.Summary = weatherForecast.Summary; return NoContent(); } [HttpDelete(\u0026#34;{id}\u0026#34;, Name = \u0026#34;DeleteWeatherForecast\u0026#34;)] public ActionResult\u0026lt;WeatherForecast\u0026gt; Delete(int id) { var item = Data.WeatherForecasts.FirstOrDefault(x =\u0026gt; x.Id == id); if (item == null) return NotFound(); Data.WeatherForecasts.Remove(item); return Ok(); } } The WeatherForecastController class is defined within the Microser.API.Weather.Controllers namespace. It is decorated with various attributes that provide additional information and behavior to the controller.\n[Authorize(Policy = \u0026quot;ClientIdPolicy\u0026quot;)] This attribute specifies that the controller requires authorization based on a policy named \u0026quot;ClientIdPolicy\u0026quot;. It ensures that only authenticated clients with the appropriate policy can access the controller\u0026rsquo;s actions.\n[ApiController] This attribute indicates that the class is an API controller. It enables various features and conventions for API controllers, such as automatic model validation and attribute routing.\n[Route(\u0026quot;[controller]\u0026quot;)] This attribute specifies the base route for the controller. In this case, the route is determined by the controller\u0026rsquo;s name, which is \u0026quot;WeatherForecast\u0026quot;. So, the base route for this controller is \u0026ldquo;/WeatherForecast\u0026rdquo;.\nThe controller inherits from the ControllerBase class, which provides a base implementation for API controllers in ASP.NET Core.\nMicroser.IdS - IdentityServer Project Create from template: https://github.com/DuendeSoftware/IdentityServer.Templates\nInstall with:\ndotnet new install Duende.IdentityServer.Templates Identity Server migrations and seed:\nMicroser\\Microser.IdS\u0026gt; .\\buildschema.bat Microser\\Microser.IdS\u0026gt; dotnet run /seed The HostingExtensions.cs file contains two extension methods: ConfigureServices and ConfigurePipeline. Let\u0026rsquo;s explore each method in detail.\nHostingExtensions.cs\nusing Duende.IdentityServer; using Microser.IdS.Pages.Admin.ApiScopes; using Microser.IdS.Pages.Admin.Clients; using Microser.IdS.Pages.Admin.IdentityScopes; using Microsoft.AspNetCore.Mvc.RazorPages; using Microsoft.EntityFrameworkCore; using Serilog; namespace Microser.IdS { internal static class HostingExtensions { public static WebApplication ConfigureServices(this WebApplicationBuilder builder) { builder.Services.AddRazorPages(); var connectionString = builder.Configuration.GetConnectionString(\u0026#34;DefaultConnection\u0026#34;); var isBuilder = builder.Services .AddIdentityServer(options =\u0026gt; { options.Events.RaiseErrorEvents = true; options.Events.RaiseInformationEvents = true; options.Events.RaiseFailureEvents = true; options.Events.RaiseSuccessEvents = true; // see https://docs.duendesoftware.com/identityserver/v5/fundamentals/resources/ options.EmitStaticAudienceClaim = true; }) .AddTestUsers(TestUsers.Users) // this adds the config data from DB (clients, resources, CORS) .AddConfigurationStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, dbOpts =\u0026gt; dbOpts.MigrationsAssembly(typeof(Program).Assembly.FullName)); }) // this is something you will want in production to reduce load on and requests to the DB //.AddConfigurationStoreCache() // // this adds the operational data from DB (codes, tokens, consents) .AddOperationalStore(options =\u0026gt; { options.ConfigureDbContext = b =\u0026gt; b.UseSqlite(connectionString, dbOpts =\u0026gt; dbOpts.MigrationsAssembly(typeof(Program).Assembly.FullName)); }); builder.Services.AddAuthentication() .AddGoogle(options =\u0026gt; { options.SignInScheme = IdentityServerConstants.ExternalCookieAuthenticationScheme; // register your IdentityServer with Google at https://console.developers.google.com // enable the Google+ API // set the redirect URI to https://localhost:5001/signin-google options.ClientId = \u0026#34;copy client ID from Google here\u0026#34;; options.ClientSecret = \u0026#34;copy client secret from Google here\u0026#34;; }); // this adds the necessary config for the simple admin/config pages { builder.Services.AddAuthorization(options =\u0026gt; options.AddPolicy(\u0026#34;admin\u0026#34;, policy =\u0026gt; policy.RequireClaim(\u0026#34;sub\u0026#34;, \u0026#34;1\u0026#34;)) ); builder.Services.Configure\u0026lt;RazorPagesOptions\u0026gt;(options =\u0026gt; options.Conventions.AuthorizeFolder(\u0026#34;/Admin\u0026#34;, \u0026#34;admin\u0026#34;)); builder.Services.AddTransient\u0026lt;Microser.IdS.Pages.Portal.ClientRepository\u0026gt;(); builder.Services.AddTransient\u0026lt;ClientRepository\u0026gt;(); builder.Services.AddTransient\u0026lt;IdentityScopeRepository\u0026gt;(); builder.Services.AddTransient\u0026lt;ApiScopeRepository\u0026gt;(); } // if you want to use server-side sessions: https://blog.duendesoftware.com/posts/20220406_session_management/ // then enable it //isBuilder.AddServerSideSessions(); // // and put some authorization on the admin/management pages using the same policy created above //builder.Services.Configure\u0026lt;RazorPagesOptions\u0026gt;(options =\u0026gt; // options.Conventions.AuthorizeFolder(\u0026#34;/ServerSideSessions\u0026#34;, \u0026#34;admin\u0026#34;)); return builder.Build(); } public static WebApplication ConfigurePipeline(this WebApplication app) { app.UseSerilogRequestLogging(); if (app.Environment.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseStaticFiles(); app.UseRouting(); app.UseIdentityServer(); app.UseAuthorization(); app.MapRazorPages() .RequireAuthorization(); return app; } } } The ConfigureServices method is responsible for configuring the services required by the application The ConfigurePipeline method is responsible for configuring the middleware pipeline of the application.\nConfig.cs\nusing Duende.IdentityServer; using Duende.IdentityServer.Models; using IdentityModel; namespace Microser.IdS { public static class Config { public static IEnumerable\u0026lt;IdentityResource\u0026gt; IdentityResources =\u0026gt; new IdentityResource[] { new IdentityResources.OpenId(), new IdentityResources.Profile(), new IdentityResources.Address(), new IdentityResources.Email(), new IdentityResource( \u0026#34;roles\u0026#34;, \u0026#34;Your role(s)\u0026#34;, new List\u0026lt;string\u0026gt;(){ JwtClaimTypes.Role }) }; public static IEnumerable\u0026lt;ApiScope\u0026gt; ApiScopes =\u0026gt; new ApiScope[] { new ApiScope(\u0026#34;scope1\u0026#34;), new ApiScope(\u0026#34;scope2\u0026#34;), new ApiScope(\u0026#34;microser_api_weather\u0026#34;), }; public static IEnumerable\u0026lt;Client\u0026gt; Clients =\u0026gt; new Client[] { new Client { ClientId = \u0026#34;dotnet_blazor_serverapp\u0026#34;, ClientName = \u0026#34;Blazor Server App\u0026#34;, ClientSecrets = { new Secret(\u0026#34;E8C65E41BB0E4E519D409023CF5112F4\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, RequirePkce = true, RequireClientSecret = true, AllowedCorsOrigins = { \u0026#34;https://localhost:7001\u0026#34; }, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, IdentityServerConstants.StandardScopes.Address, IdentityServerConstants.StandardScopes.Email, \u0026#34;roles\u0026#34;, \u0026#34;scope1\u0026#34;, \u0026#34;microser_api_weather\u0026#34; }, RedirectUris = { \u0026#34;https://localhost:7001/signin-oidc\u0026#34; }, PostLogoutRedirectUris = { \u0026#34;https://localhost:7001/signout-callback-oidc\u0026#34; }, Enabled = true }, // m2m client credentials flow client new Client { ClientId = \u0026#34;m2m.client\u0026#34;, ClientName = \u0026#34;Client Credentials Client\u0026#34;, AllowedGrantTypes = GrantTypes.ClientCredentials, ClientSecrets = { new Secret(\u0026#34;511536EF-F270-4058-80CA-1C89C192F69A\u0026#34;.Sha256()) }, AllowedScopes = { \u0026#34;scope1\u0026#34; } }, // interactive client using code flow + pkce new Client { ClientId = \u0026#34;interactive\u0026#34;, ClientSecrets = { new Secret(\u0026#34;49C1A7E1-0C79-4A89-A3D6-A37998FB86B0\u0026#34;.Sha256()) }, AllowedGrantTypes = GrantTypes.Code, RedirectUris = { \u0026#34;https://localhost:44300/signin-oidc\u0026#34; }, FrontChannelLogoutUri = \u0026#34;https://localhost:44300/signout-oidc\u0026#34;, PostLogoutRedirectUris = { \u0026#34;https://localhost:44300/signout-callback-oidc\u0026#34; }, AllowOfflineAccess = true, AllowedScopes = { \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;scope2\u0026#34; } }, }; } } The Config.cs file contains a static class called Config that defines three static properties: IdentityResources, ApiScopes, and Clients. Each property returns an array of objects representing the available identity resources, API scopes, and clients, respectively.\nThe IdentityResources property defines the available identity resources. The ApiScopes property defines the available API scopes.\nThe Clients property defines the available client applications.\nTestUsers.cs\n// Copyright (c) Duende Software. All rights reserved. // See LICENSE in the project root for license information. using Duende.IdentityServer; using Duende.IdentityServer.Test; using IdentityModel; using System.Security.Claims; using System.Text.Json; namespace Microser.IdS { public static class TestUsers { public static class Roles { public static string IdentityAdmin = \u0026#34;IdentityAdmin\u0026#34;; public static string Admin = \u0026#34;Admin\u0026#34;; public static string User = \u0026#34;User\u0026#34;; } public static List\u0026lt;TestUser\u0026gt; Users { get { var address = new { street_address = \u0026#34;One Hacker Way\u0026#34;, locality = \u0026#34;Heidelberg\u0026#34;, postal_code = \u0026#34;69118\u0026#34;, country = \u0026#34;Germany\u0026#34; }; return new List\u0026lt;TestUser\u0026gt; { new TestUser { SubjectId = \u0026#34;1\u0026#34;, Username = \u0026#34;alice\u0026#34;, Password = \u0026#34;alice\u0026#34;, Claims = { new Claim(JwtClaimTypes.Name, \u0026#34;Alice Smith\u0026#34;), new Claim(JwtClaimTypes.GivenName, \u0026#34;Alice\u0026#34;), new Claim(JwtClaimTypes.FamilyName, \u0026#34;Smith\u0026#34;), new Claim(JwtClaimTypes.Email, \u0026#34;AliceSmith@email.com\u0026#34;), new Claim(JwtClaimTypes.EmailVerified, \u0026#34;true\u0026#34;, ClaimValueTypes.Boolean), new Claim(JwtClaimTypes.WebSite, \u0026#34;http://alice.com\u0026#34;), new Claim(JwtClaimTypes.Address, JsonSerializer.Serialize(address), IdentityServerConstants.ClaimValueTypes.Json), new Claim(JwtClaimTypes.Role, Roles.IdentityAdmin), new Claim(JwtClaimTypes.Role, Roles.Admin), new Claim(JwtClaimTypes.Role, Roles.User) } }, new TestUser { SubjectId = \u0026#34;2\u0026#34;, Username = \u0026#34;bob\u0026#34;, Password = \u0026#34;bob\u0026#34;, Claims = { new Claim(JwtClaimTypes.Name, \u0026#34;Bob Smith\u0026#34;), new Claim(JwtClaimTypes.GivenName, \u0026#34;Bob\u0026#34;), new Claim(JwtClaimTypes.FamilyName, \u0026#34;Smith\u0026#34;), new Claim(JwtClaimTypes.Email, \u0026#34;BobSmith@email.com\u0026#34;), new Claim(JwtClaimTypes.EmailVerified, \u0026#34;true\u0026#34;, ClaimValueTypes.Boolean), new Claim(JwtClaimTypes.WebSite, \u0026#34;http://bob.com\u0026#34;), new Claim(JwtClaimTypes.Address, JsonSerializer.Serialize(address), IdentityServerConstants.ClaimValueTypes.Json), new Claim(JwtClaimTypes.Role, Roles.User) } } }; } } } } The TestUsers.cs file contains a static class named TestUsers that defines test users and their associated claims and roles. The class also includes a nested class named Roles that defines some role constants.\nMicroser.BlazorAppClient - Blazor Web App Project Program.cs\nusing Microser.BlazorAppClient; using Microser.BlazorAppClient.Components; using Microser.BlazorAppClient.HttpHandlers; using Microser.BlazorAppClient.Services; using Microsoft.AspNetCore.Authentication; using Microsoft.AspNetCore.Authentication.Cookies; using Microsoft.AspNetCore.Authentication.OpenIdConnect; using Microsoft.IdentityModel.Tokens; using Microsoft.Net.Http.Headers; internal class Program { private static void Main(string[] args) { var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddRazorComponents() .AddInteractiveServerComponents(); builder.Services.AddTransient\u0026lt;AuthenticationDelegatingHandler\u0026gt;(); builder.Services.AddScoped\u0026lt;IWeatherForecastApiService, WeatherForecastApiService\u0026gt;(); builder.Services.AddOIDCAuthentication(); builder.Services.AddHttpClients(); builder.Services.AddPolicies(); builder.Services.AddHttpContextAccessor(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(\u0026#34;/Error\u0026#34;, createScopeForErrors: true); // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts. app.UseHsts(); } app.UseHttpsRedirection(); app.UseAuthentication(); app.UseAuthorization(); app.UseStaticFiles(); app.UseAntiforgery(); app.MapRazorComponents\u0026lt;App\u0026gt;() .AddInteractiveServerRenderMode(); app.MapPost(\u0026#34;/account/logout\u0026#34;, async (HttpContext context) =\u0026gt; { await context.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme); await context.SignOutAsync(OpenIdConnectDefaults.AuthenticationScheme); }); app.MapGet(\u0026#34;/account/login\u0026#34;, async (string redirectUri, HttpContext context) =\u0026gt; { await context.ChallengeAsync(OpenIdConnectDefaults.AuthenticationScheme, new AuthenticationProperties { RedirectUri = redirectUri }); }); app.Run(); } } public static class StartupExtensions { public static void AddOIDCAuthentication(this IServiceCollection services) { services .AddAntiforgery(options =\u0026gt; options.Cookie.Name = \u0026#34;ClientBlazorAppAntiForgeryCookie\u0026#34;) .AddAuthentication(options =\u0026gt; { options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme; options.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme; }) .AddCookie(options =\u0026gt; { options.Cookie.Name = \u0026#34;ClientBlazorAppAuthCookie\u0026#34;; options.AccessDeniedPath = \u0026#34;/AccessDenied\u0026#34;; }) .AddOpenIdConnect(OpenIdConnectDefaults.AuthenticationScheme, options =\u0026gt; { options.Authority = \u0026#34;https://localhost:5001/\u0026#34;; options.ClientId = \u0026#34;dotnet_blazor_serverapp\u0026#34;; options.ClientSecret = \u0026#34;E8C65E41BB0E4E519D409023CF5112F4\u0026#34;; options.ResponseType = \u0026#34;code\u0026#34;; options.SaveTokens = true; options.GetClaimsFromUserInfoEndpoint = true; options.UseTokenLifetime = false; //options.SignedOutRedirectUri = \u0026#34;/\u0026#34;; options.Scope.Add(\u0026#34;openid\u0026#34;); options.Scope.Add(\u0026#34;profile\u0026#34;); options.Scope.Add(\u0026#34;address\u0026#34;); options.Scope.Add(\u0026#34;email\u0026#34;); options.Scope.Add(\u0026#34;roles\u0026#34;); options.Scope.Add(\u0026#34;microser_api_weather\u0026#34;); options.ClaimActions.MapJsonKey(\u0026#34;role\u0026#34;, \u0026#34;role\u0026#34;); //options.ClaimActions.MapUniqueJsonKey(\u0026#34;role\u0026#34;, \u0026#34;role\u0026#34;); //options.ClaimActions.MapAll(); options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;name\u0026#34;, RoleClaimType = \u0026#34;role\u0026#34; }; options.Events = new OpenIdConnectEvents { OnAccessDenied = context =\u0026gt; { context.HandleResponse(); context.Response.Redirect(\u0026#34;/\u0026#34;); return Task.CompletedTask; } }; }); } public static void AddHttpClients(this IServiceCollection services) { services.AddHttpClient(\u0026#34;WeatherForecastAPIClient\u0026#34;, client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://localhost:6001/\u0026#34;); client.DefaultRequestHeaders.Clear(); client.DefaultRequestHeaders.Add(HeaderNames.Accept, \u0026#34;application/json\u0026#34;); }) .AddHttpMessageHandler\u0026lt;AuthenticationDelegatingHandler\u0026gt;(); // added for get user info services.AddHttpClient(\u0026#34;IDPClient\u0026#34;, client =\u0026gt; { client.BaseAddress = new Uri(\u0026#34;https://localhost:5001/\u0026#34;); client.DefaultRequestHeaders.Clear(); client.DefaultRequestHeaders.Add(HeaderNames.Accept, \u0026#34;application/json\u0026#34;); }); } public static void AddPolicies(this IServiceCollection services) { services.AddAuthorization(opts =\u0026gt; { opts.AddPolicy(nameof(ProjectPolicies.UserRolePolicy), policy =\u0026gt; { foreach (var role in ProjectPolicies.UserRolePolicy.RequiredRoles) policy.RequireRole(role.RoleName); }); opts.AddPolicy(nameof(ProjectPolicies.IdentityAdminRolePolicy), policy =\u0026gt; { foreach (var role in ProjectPolicies.IdentityAdminRolePolicy.RequiredRoles) policy.RequireRole(role.RoleName); }); opts.AddPolicy(nameof(ProjectPolicies.AdminRolePolicy), policy =\u0026gt; { foreach (var role in ProjectPolicies.AdminRolePolicy.RequiredRoles) policy.RequireRole(role.RoleName); }); }); services.AddAuthorization(opts =\u0026gt; { opts.AddPolicy(nameof(ProjectPolicies.WeatherForecastCreatePolicy), policy =\u0026gt; { foreach (var claim in ProjectPolicies.WeatherForecastCreatePolicy.RequiredClaims) policy.RequireClaim(claim.Type, new[] { claim.Value }); }); opts.AddPolicy(nameof(ProjectPolicies.WeatherForecastReadPolicy), policy =\u0026gt; { foreach (var claim in ProjectPolicies.WeatherForecastReadPolicy.RequiredClaims) policy.RequireClaim(claim.Type, new[] { claim.Value }); }); opts.AddPolicy(nameof(ProjectPolicies.WeatherForecastUpdatePolicy), policy =\u0026gt; { foreach (var claim in ProjectPolicies.WeatherForecastUpdatePolicy.RequiredClaims) policy.RequireClaim(claim.Type, new[] { claim.Value }); }); opts.AddPolicy(nameof(ProjectPolicies.WeatherForecastDeletePolicy), policy =\u0026gt; { foreach (var claim in ProjectPolicies.WeatherForecastDeletePolicy.RequiredClaims) policy.RequireClaim(claim.Type, new[] { claim.Value }); }); }); } } The Program.cs contains the entry point of the application and the configuration of the HTTP request pipeline. It sets up the authentication and authorization middleware, handles static files, and defines routes for login and logout.\nThe StartupExtensions contains extension methods for configuring authentication, HTTP clients, and authorization policies. It sets up the OpenID Connect authentication scheme, configures the Identity Server endpoints, and defines the required scopes and claims.\nWeatherForecastApiService.cs\nusing Microser.BlazorAppClient.Extensions; using Microser.Core.Models; namespace Microser.BlazorAppClient.Services; public class WeatherForecastApiService : IWeatherForecastApiService { private readonly IHttpClientFactory _httpClientFactory; private readonly IHttpContextAccessor _httpContextAccessor; public WeatherForecastApiService(IHttpClientFactory httpClientFactory, IHttpContextAccessor httpContextAccessor) { _httpClientFactory = httpClientFactory ?? throw new ArgumentNullException(nameof(httpClientFactory)); _httpContextAccessor = httpContextAccessor ?? throw new ArgumentNullException(nameof(httpContextAccessor)); } public async Task\u0026lt;WeatherForecast[]?\u0026gt; GetAllAsync() { var httpClient = _httpClientFactory.CreateClient(\u0026#34;WeatherForecastAPIClient\u0026#34;); var request = new HttpRequestMessage( HttpMethod.Get, \u0026#34;/WeatherForecast\u0026#34;); var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) .ConfigureAwait(false); response.EnsureSuccessStatusCode(); //var content = await response.Content.ReadAsStringAsync(); //var weatherForecastList = JsonSerializer.Deserialize\u0026lt;List\u0026lt;WeatherForecast\u0026gt;\u0026gt;(content); var weatherForecastList = await response.ReadContentAs\u0026lt;WeatherForecast[]\u0026gt;(); return weatherForecastList; } public async Task\u0026lt;WeatherForecast?\u0026gt; GetByIdAsync(int id) { var httpClient = _httpClientFactory.CreateClient(\u0026#34;WeatherForecastAPIClient\u0026#34;); var request = new HttpRequestMessage( HttpMethod.Get, \u0026#34;/WeatherForecast/\u0026#34; + id); var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) .ConfigureAwait(false); response.EnsureSuccessStatusCode(); var item = await response.ReadContentAs\u0026lt;WeatherForecast\u0026gt;(); return item; } public async Task\u0026lt;WeatherForecast?\u0026gt; AddAsync(WeatherForecast weatherForecast) { var httpClient = _httpClientFactory.CreateClient(\u0026#34;WeatherForecastAPIClient\u0026#34;); var request = new HttpRequestMessage( HttpMethod.Post, \u0026#34;/WeatherForecast\u0026#34;) { Content = JsonContent.Create(weatherForecast) }; var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) .ConfigureAwait(false); response.EnsureSuccessStatusCode(); weatherForecast = await response.ReadContentAs\u0026lt;WeatherForecast\u0026gt;(); return weatherForecast; } public async Task\u0026lt;bool\u0026gt; DeleteByIdAsync(int id) { var httpClient = _httpClientFactory.CreateClient(\u0026#34;WeatherForecastAPIClient\u0026#34;); var request = new HttpRequestMessage( HttpMethod.Delete, \u0026#34;/WeatherForecast/\u0026#34; + id.ToString()); try { var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) .ConfigureAwait(false); response.EnsureSuccessStatusCode(); } catch (Exception) { return false; } return true; } public async Task\u0026lt;bool\u0026gt; UpdateAsync(int id, WeatherForecast weatherForecast) { var httpClient = _httpClientFactory.CreateClient(\u0026#34;WeatherForecastAPIClient\u0026#34;); var request = new HttpRequestMessage( HttpMethod.Put, \u0026#34;/WeatherForecast/\u0026#34; + weatherForecast.Id.ToString()) { Content = JsonContent.Create(weatherForecast) }; try { var response = await httpClient.SendAsync(request, HttpCompletionOption.ResponseHeadersRead) .ConfigureAwait(false); response.EnsureSuccessStatusCode(); } catch (Exception) { return false; } return true; } } The WeatherForecastApiService class in the Blazor .NET 8 Microservices Blazor Client project provides methods to interact with a weather forecast API. It allows for retrieving, adding, updating, and deleting weather forecasts using HTTP requests. By utilizing the IHttpClientFactory and IHttpContextAccessor, it ensures efficient and secure communication with the API.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/Microser\n","date":"March 15, 2024","hero":"/dotnet/2024-03-15-blazor-.net8-microservices-blazor-client-and-securing-api-with-duende-identity-server/blazor_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-03-15-blazor-.net8-microservices-blazor-client-and-securing-api-with-duende-identity-server/","summary":"Blazor .NET 8 Microservices Blazor Client and Securing API with Duende Identity Server A Blazor .NET 8 microservices client application and integrates it with Duende Identity Server for securing the API endpoints. The code demonstrates the configuration of services, authentication, authorization, and HTTP request pipeline setup.\nBlazor: Blazor is a framework for building interactive web UIs using C# instead of JavaScript. It allows developers to create web applications using .","tags":["dotnet8",".NET8","Blazor","Microservices Blazor Client and Securing API with Duende Identity Server"],"title":"Blazor .NET 8 Microservices Blazor Client and Securing API with Duende Identity Server"},{"categories":["dotnet8",".NET8","Minimal APIs Native AOT CRUD"],"contents":" Blazor .NET 8 and Minimal APIs Native AOT CRUD Let\u0026rsquo;s briefly discuss the key concepts involved in this Blazor app and Minimal APIs Native AOT CRUD implementation:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables the development of single-page applications (SPAs) with the power of .NET.\nMinimal APIs: Minimal APIs is a new feature introduced in .NET 6 that allows developers to create lightweight and minimalistic APIs without the need for traditional controllers and routes. It simplifies the API development process and reduces the amount of boilerplate code.\nNative AOT (Ahead-of-Time) Compilation: Native AOT compilation is a feature in .NET that allows the application to be compiled to machine code ahead of time, resulting in faster startup times and improved performance.\nCRUD Operations: CRUD stands for Create, Read, Update, and Delete. These are the basic operations performed on data in a database or storage system.\nBlazorAppandMinimalAPIsNativeAOTCRUD.Core Class Library Todo.cs\nnamespace BlazorAppandMinimalAPIsNativeAOTCRUD.Core.Models; public class Todo { public int Id { get; set; } public string? Title { get; set; } = string.Empty; public DateOnly? DueBy { get; set; } = null; public bool IsComplete { get; set; } = false; public override string ToString() =\u0026gt; $\u0026#34;{this.Id} {this.Title} {this.DueBy} {this.IsComplete}\u0026#34;; } This file contains the logic for our CRUD operations. It includes methods for creating a new todo item, retrieving all todo items, updating a todo item, and deleting a todo item.\nTodoDataModel.cs\nnamespace BlazorAppandMinimalAPIsNativeAOTCRUD.Core.DataModels; public record TodoDataModelRecord(int Id = 0, string? Title = \u0026#34;\u0026#34;, DateOnly? DueBy = null, bool IsComplete = false); public class TodoDataModel { public int Id { get; set; } public string? Title { get; set; } = string.Empty; public DateOnly? DueBy { get; set; } = null; public bool IsComplete { get; set; } = false; } In the TodoDataModel.cs file defines a data model for a todo item in the Blazor app and Minimal APIs Native AOT CRUD project. This file contains the data model for our application. It defines the structure of a todo item, including properties like Id, Title, DueBy, and IsCompleted.\nWebAppAPINativeAOT Minimal APIs Native AOT Project TodoService.cs\nusing BlazorAppandMinimalAPIsNativeAOTCRUD.Core.Models; using WebAppAPINativeAOT.Data; namespace WebAppAPINativeAOT.Services; public class TodoService(ILogger\u0026lt;TodoService\u0026gt; logger) { public Todo? GetById(int id) { logger.LogInformation(\u0026#34;Called GetById: {id}\u0026#34;, id); return SampleData.ToDos.FirstOrDefault(x =\u0026gt; x.Id == id); } public Todo[]? GetCompleted() { logger.LogInformation(\u0026#34;Called GetCompleted\u0026#34;); return SampleData.ToDos.Where(x =\u0026gt; x.IsComplete == true).ToArray(); } public Todo[]? GetAll() { logger.LogInformation(\u0026#34;Called GetAll\u0026#34;); return [.. SampleData.ToDos]; } public bool Add(Todo todo) { logger.LogInformation(\u0026#34;Called Add {todo}\u0026#34;, todo); try { var last = SampleData.ToDos.LastOrDefault(); todo.Id = last is not null ? last.Id + 1 : 1; SampleData.ToDos.Add(todo); } catch (Exception ex) { logger.LogError(ex, \u0026#34;Called Add Error {todo}\u0026#34;, todo); return false; } return true; } public bool Update(int id, Todo todo) { logger.LogInformation(\u0026#34;Called Update {todo}\u0026#34;, todo); try { var oTodo = SampleData.ToDos.FirstOrDefault(x =\u0026gt; x.Id == id); if (oTodo == null) return false; oTodo.Title = todo.Title; oTodo.DueBy = todo.DueBy; oTodo.IsComplete = todo.IsComplete; } catch (Exception ex) { logger.LogError(ex, \u0026#34;Called Update Error {todo}\u0026#34;, todo); return false; } return true; } public bool DeleteById(int id) { logger.LogInformation(\u0026#34;Called DeleteById {id}\u0026#34;, id); var oTodo = SampleData.ToDos.FirstOrDefault(x =\u0026gt; x.Id == id); if (oTodo == null) return false; SampleData.ToDos.Remove(oTodo); return true; } } The TodoService.cs file contains a class named TodoService that implements various methods for CRUD operations on the Todo model. Let\u0026rsquo;s take a closer look at each method:\nGetById(int id): This method retrieves a Todo object by its ID. It logs the ID of the requested Todo and returns the corresponding Todo object if found.\nGetCompleted(): This method retrieves an array of completed Todo objects. It logs the request and returns an array of Todo objects where the IsComplete property is set to true.\nGetAll(): This method retrieves an array of all Todo objects. It logs the request and returns an array containing all the Todo objects.\nAdd(Todo todo): This method adds a new Todo object to the collection. It logs the request and attempts to add the Todo object to the SampleData.ToDos collection. If successful, it assigns a unique ID to the Todo object and adds it to the collection. If an error occurs, it logs the error and returns false.\nUpdate(int id, Todo todo): This method updates an existing Todo object with the provided ID. It logs the request and attempts to find the Todo object with the specified ID. If found, it updates the Title, DueBy, and IsComplete properties of the Todo object. If an error occurs, it logs the error and returns false.\nDeleteById(int id): This method deletes a Todo object with the specified ID. It logs the request and attempts to find the Todo object with the specified ID. If found, it removes the Todo object from the SampleData.ToDos collection. If an error occurs, it returns false.\nProgram.cs\nusing BlazorAppandMinimalAPIsNativeAOTCRUD.Core.DataModels; using BlazorAppandMinimalAPIsNativeAOTCRUD.Core.Models; using System.Text.Json.Serialization; using WebAppAPINativeAOT.Data; using WebAppAPINativeAOT.Services; internal class Program { private static void Main(string[] args) { var builder = WebApplication.CreateSlimBuilder(args); builder.Services.ConfigureHttpJsonOptions(options =\u0026gt; { options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default); }); // add test data SampleData.AddTestData(); // Add services to the container. builder.Services.AddScoped\u0026lt;TodoService\u0026gt;(); var app = builder.Build(); // add endpoints app.MapTodoGroup(); app.Run(); } } [JsonSerializable(typeof(object))] [JsonSerializable(typeof(Todo[]))] [JsonSerializable(typeof(TodoDataModel[]))] internal partial class AppJsonSerializerContext : JsonSerializerContext { } public static class WebApplicationExtensions { public static void MapTodoGroup(this WebApplication app) { var todosApi = app.MapGroup(\u0026#34;/todos\u0026#34;); // get all todosApi.MapGet(\u0026#34;/\u0026#34;, (TodoService todoService) =\u0026gt; todoService.GetAll()); // get all completed todosApi.MapGet(\u0026#34;/complete\u0026#34;, (TodoService todoService) =\u0026gt; todoService.GetCompleted()); // get by id todosApi.MapGet(\u0026#34;/{id}\u0026#34;, (int id, TodoService todoService) =\u0026gt; todoService.GetById(id) is { } todo ? Results.Ok(todo) : Results.NotFound()); // add todosApi.MapPost(\u0026#34;/\u0026#34;, (Todo todo, TodoService todoService) =\u0026gt; { todoService.Add(todo); return Results.Created($\u0026#34;/{todo.Id}\u0026#34;, todo); }); // update todosApi.MapPut(\u0026#34;/{id}\u0026#34;, (int id, Todo inputTodo, TodoService todoService) =\u0026gt; { var todo = todoService.GetById(id); if (todo is null) return Results.NotFound(); todoService.Update(id, inputTodo); return Results.NoContent(); }); // delete todosApi.MapDelete(\u0026#34;/{id}\u0026#34;, (int id, TodoService todoService) =\u0026gt; { if (todoService.GetById(id) is Todo todo) { todoService.DeleteById(id); return Results.NoContent(); } return Results.NotFound(); }); } } The code is structured into two main sections: the Program and the WebApplicationExtensions.\nThe Program.cs file contains the entry point of the application and is responsible for configuring the Blazor app and defining the main logic.\nThe Main method is the entry point of the application. It creates a WebApplication builder using the WebApplication.CreateSlimBuilder method. The ConfigureHttpJsonOptions method is used to configure the JSON serialization options for the HTTP requests and responses. In this code, it inserts a custom TypeInfoResolverChain at the beginning of the default options. The SampleData.AddTestData() method is called to add some test data to the Todo list. The TodoService is registered as a scoped service in the dependency injection container. The app.MapTodoGroup() method is called to define the endpoints for the Todo API. Finally, the app.Run() method is called to start the application. The WebApplicationExtensions contains extension methods for the WebApplication class, which are used to define the endpoints for the Todo API.\nThe todosApi variable is created by calling the app.MapGroup method with the \u0026quot;/todos\u0026quot; route. The todosApi.MapGet method is used to define a GET endpoint for retrieving all the Todo items. The todosApi.MapGet method is used to define a GET endpoint for retrieving all the completed Todo items. The todosApi.MapGet method is used to define a GET endpoint for retrieving a Todo item by its ID. The todosApi.MapPost method is used to define a POST endpoint for adding a new Todo item. The todosApi.MapPut method is used to define a PUT endpoint for updating a Todo item. The todosApi.MapDelete method is used to define a DELETE endpoint for deleting a Todo item. BlazorApp Presentation Project TodoClientService.cs\nusing BlazorAppandMinimalAPIsNativeAOTCRUD.Core.DataModels; using System.Text.Json; namespace BlazorApp.Services; public class TodoClientService(IHttpClientFactory httpClientFactory) { public async Task\u0026lt;TodoDataModelRecord?\u0026gt; GetById(int id) { using var httpClient = httpClientFactory.CreateClient(\u0026#34;TodoApi\u0026#34;); var httpResponseMessage = await httpClient.GetAsync($\u0026#34;todos/{id}\u0026#34;); if (httpResponseMessage.IsSuccessStatusCode) { using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); return await JsonSerializer.DeserializeAsync\u0026lt;TodoDataModelRecord?\u0026gt;(contentStream, Program.TodoApiJsonOptions); } return null; } public async Task\u0026lt;TodoDataModelRecord[]?\u0026gt; GetCompletedAsync() { using var httpClient = httpClientFactory.CreateClient(\u0026#34;TodoApi\u0026#34;); var httpResponseMessage = await httpClient.GetAsync(\u0026#34;todos/complete\u0026#34;); if (httpResponseMessage.IsSuccessStatusCode) { using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); return await JsonSerializer.DeserializeAsync\u0026lt;TodoDataModelRecord[]\u0026gt;(contentStream, Program.TodoApiJsonOptions); } return []; } public async Task\u0026lt;TodoDataModelRecord[]?\u0026gt; GetAllAsync() { using var httpClient = httpClientFactory.CreateClient(\u0026#34;TodoApi\u0026#34;); var httpResponseMessage = await httpClient.GetAsync(\u0026#34;todos\u0026#34;); if (httpResponseMessage.IsSuccessStatusCode) { using var contentStream = await httpResponseMessage.Content.ReadAsStreamAsync(); return await JsonSerializer.DeserializeAsync\u0026lt;TodoDataModelRecord[]\u0026gt;(contentStream, Program.TodoApiJsonOptions); } return []; } public async Task\u0026lt;bool\u0026gt; AddAsync(TodoDataModel todo) { using var httpClient = httpClientFactory.CreateClient(\u0026#34;TodoApi\u0026#34;); var httpResponseMessage = await httpClient.PostAsJsonAsync(\u0026#34;todos\u0026#34;, todo, Program.TodoApiJsonOptions, default); if (httpResponseMessage.IsSuccessStatusCode) { return true; } return false; } public async Task\u0026lt;bool\u0026gt; UpdateAsync(int id, TodoDataModel todo) { using var httpClient = httpClientFactory.CreateClient(\u0026#34;TodoApi\u0026#34;); var httpResponseMessage = await httpClient.PutAsJsonAsync($\u0026#34;todos/{id}\u0026#34;, todo, Program.TodoApiJsonOptions, default); if (httpResponseMessage.IsSuccessStatusCode) { return true; } return false; } public async Task\u0026lt;bool\u0026gt; DeleteByIdAsync(int id) { using var httpClient = httpClientFactory.CreateClient(\u0026#34;TodoApi\u0026#34;); var httpResponseMessage = await httpClient.DeleteAsync($\u0026#34;todos/{id}\u0026#34;); if (httpResponseMessage.IsSuccessStatusCode) { return true; } return false; } } The TodoClientService class is a service in a Blazor app that interacts with a Todo API to perform CRUD (Create, Read, Update, Delete) operations on TodoDataModel records. It uses the HttpClientFactory to create an instance of HttpClient and makes HTTP requests to the Todo API endpoints.\nProgram.cs\nusing BlazorApp.Components; using BlazorApp.Services; using System.Text.Json; internal class Program { public const string API_URL = \u0026#34;http://localhost:5000\u0026#34;; public static readonly JsonSerializerOptions TodoApiJsonOptions = new() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }; private static void Main(string[] args) { ... builder.Services.AddHttpClient(\u0026#34;TodoApi\u0026#34;, httpClient =\u0026gt; { httpClient.BaseAddress = new Uri(API_URL); }); // Add services to the container. builder.Services.AddScoped\u0026lt;TodoClientService\u0026gt;(); builder.Services.AddRazorComponents() .AddInteractiveServerComponents(); ... } } The Program.cs file, which is responsible for configuring and running the Blazor app. Let\u0026rsquo;s break down the code structure and understand its components:\nHttpClient Configuration: This code configures an HttpClient named \u0026quot;TodoApi\u0026quot; and sets its base address to the API_URL constant.\nService Registration: This code registers the TodoClientService as a scoped service. The TodoClientService is responsible for interacting with the Todo API.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppandMinimalAPIsNativeAOTCRUD\n","date":"February 12, 2024","hero":"/dotnet/2024-02-12-blazor-.net8-and-minimal-apis-native-aot-crud/blazor_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-02-12-blazor-.net8-and-minimal-apis-native-aot-crud/","summary":"Blazor .NET 8 and Minimal APIs Native AOT CRUD Let\u0026rsquo;s briefly discuss the key concepts involved in this Blazor app and Minimal APIs Native AOT CRUD implementation:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables the development of single-page applications (SPAs) with the power of .NET.\nMinimal APIs: Minimal APIs is a new feature introduced in .","tags":["dotnet8",".NET8","Blazor","Minimal APIs Native AOT CRUD"],"title":"Blazor .NET 8 and Minimal APIs Native AOT CRUD"},{"categories":["CI/CD","Teamcity","Self-hosted"],"contents":" Setting up Teamcity Hassle-Free CI/CD Tool on Self-hosted Server TeamCity, developed by JetBrains, is a continuous integration and continuous delivery (CI/CD) platform designed to automate and streamline the software development process. It helps development teams efficiently build, test, and deploy software applications, accelerating development cycles and delivering high-quality code faster.\nStep 1 Download TeamCity\nHead to the JetBrains website: https://www.jetbrains.com/teamcity/download/ Choose the \u0026quot;Executable Windows installer bundled with Tomcat and Java\u0026quot; option. Select the desired version and click \u0026quot;Download.\u0026quot; Information\nTeamCity Professional (Free forever, even for commercial use) Step 2 Installation\nRun the downloaded .exe file. Follow the TeamCity Setup wizard instructions: Choose the TeamCity Home Directory for installation. Optionally change the default Server Port (8111) and Agent Port (9090). Select \u0026quot;Install TeamCity server and one build agent\u0026quot; option. Choose a user account for the service (with relevant permissions). Review and confirm the settings. Step 3 Start TeamCity\nAfter installation, the wizard will automatically start TeamCity. If not, open a command prompt and navigate to the TeamCity_Home\\bin directory. Run the runAll.bat start command. Configuring TeamCity Server Startup Properties;\nNavigate to the TeamCity_Home\\conf directory Open teamcity-startup.properties teamcity.data.path=TEAMCITY_DATA_PATH teamcity.server.git.executable.path=CUSTOM_GIT_PATH\\\\git.exe More Information:\nhttps://www.jetbrains.com/help/teamcity/teamcity-documentation.html\n","date":"February 11, 2024","hero":"/posts/2024-02-11-settingupteamcityhassle-freeci-cdtoolonselfhostedserver/teamcity.jpg","permalink":"https://akifmt.github.io/posts/2024-02-11-settingupteamcityhassle-freeci-cdtoolonselfhostedserver/","summary":"Setting up Teamcity Hassle-Free CI/CD Tool on Self-hosted Server TeamCity, developed by JetBrains, is a continuous integration and continuous delivery (CI/CD) platform designed to automate and streamline the software development process. It helps development teams efficiently build, test, and deploy software applications, accelerating development cycles and delivering high-quality code faster.\nStep 1 Download TeamCity\nHead to the JetBrains website: https://www.jetbrains.com/teamcity/download/ Choose the \u0026quot;Executable Windows installer bundled with Tomcat and Java\u0026quot; option.","tags":["CI/CD","Teamcity","Self-hosted"],"title":"Setting up Teamcity Hassle-Free CI/CD Tool on Self-hosted Server"},{"categories":["dotnet8",".NET8","Object Mapping with AutoMapper"],"contents":" Blazor .NET 8 Object Mapping with AutoMapper How to perform object mapping in a Blazor application using AutoMapper. Object mapping is the process of converting one object type to another, which can be useful when transferring data between different layers of an application or when displaying data in a different format.\nAutoMapper: AutoMapper is a popular object-to-object mapping library in the .NET ecosystem. It simplifies the process of mapping one object to another by automatically matching properties with similar names and types.\nMapping Profile: A mapping profile is a class that defines the mapping configuration between the source and destination objects. It specifies how properties should be mapped and can be customized to handle complex mapping scenarios.\nTo use AutoMapper in a Blazor .NET 8 application, we need to follow these steps:\nInstall the AutoMapper NuGet package. Define mapping configurations in a mapping profile class. Register the mapping profile in the application startup. Use the Mapper.Map method to perform the object mapping. Program.cs internal class Program { private static void Main(string[] args) { ... var mapperConfiguration = new MapperConfiguration(configuration =\u0026gt; { var profile = new MappingProfile(); configuration.AddProfile(profile); }); var mapper = mapperConfiguration.CreateMapper(); builder.Services.AddSingleton(mapper); ... } } public class MappingProfile : Profile { public MappingProfile() { CreateMap\u0026lt;BlogPost, BlogPostViewModel\u0026gt;().ReverseMap(); } } In the Program.cs file, we have the Main method, which is the entry point of the application. Inside the Main method, we create an instance of MapperConfiguration and configure it by adding a MappingProfile to it. This configuration sets up the mapping between the BlogPost and BlogPostViewModel classes. Finally, we create an instance of the mapper using the configured MapperConfiguration and register it as a singleton service in the Blazor application.\nThe MappingProfile class extends the Profile class provided by AutoMapper. Inside the MappingProfile class, we define the mapping between the BlogPost and BlogPostViewModel classes using the CreateMap method. This method specifies how properties should be mapped between the source and destination objects. In this example, we use the ReverseMap method to enable bidirectional mapping between the two classes.\nIn the Component We can use the Mapper.Map method to map objects between different models.\n... var vm = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(result); ... var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); ... By following the steps outlined in this article, you can easily implement object mapping in your Blazor applications using AutoMapper.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppObjectMappingwithAutoMapper\n","date":"February 9, 2024","hero":"/dotnet/2024-02-09-blazor-.net8-object-mapping-with-automapper/blazor_dotnet8_automapper.jpg","permalink":"https://akifmt.github.io/dotnet/2024-02-09-blazor-.net8-object-mapping-with-automapper/","summary":"Blazor .NET 8 Object Mapping with AutoMapper How to perform object mapping in a Blazor application using AutoMapper. Object mapping is the process of converting one object type to another, which can be useful when transferring data between different layers of an application or when displaying data in a different format.\nAutoMapper: AutoMapper is a popular object-to-object mapping library in the .NET ecosystem. It simplifies the process of mapping one object to another by automatically matching properties with similar names and types.","tags":["dotnet8",".NET8","Blazor","Object Mapping with AutoMapper"],"title":"Blazor .NET 8 Object Mapping with AutoMapper"},{"categories":["dotnet8",".NET8","Object Mapping with Mapster"],"contents":" Blazor .NET 8 Object Mapping with Mapster In a Blazor application, object mapping is a common task that involves converting data from one object type to another. This is often required when working with data transfer objects (DTOs) or when mapping data between different layers of an application. Mapster is a popular mapping library in the .NET ecosystem that provides a simple and efficient way to perform object mapping in Blazor applications.\nDTOs: Data Transfer Objects (DTOs) are objects that are used to transfer data between different layers of an application. They typically contain only the necessary properties and are used to reduce the amount of data transferred over the network.\nObject Mapping: Object mapping is the process of converting data from one object type to another. It involves copying properties from the source object to the destination object, taking into account any necessary transformations or mappings.\nMapster: Mapster is a lightweight and fast object-to-object mapper for .NET. It provides a fluent API for configuring object mappings and performs the mapping operation efficiently using compiled expressions.\nProgram.cs internal class Program { private static void Main(string[] args) { ... builder.Services.AddMapster(); ... } } The AddMapster extension method is added to the IServiceCollection in the Program.cs file. This method is responsible for configuring Mapster and registering the necessary services.\npublic static class MapsterConfiguration { public static void AddMapster(this IServiceCollection services) { var typeAdapterConfig = TypeAdapterConfig.GlobalSettings; Assembly applicationAssembly = typeof(BaseDTO\u0026lt;,\u0026gt;).Assembly; typeAdapterConfig.Scan(applicationAssembly); var mapperConfig = new Mapper(typeAdapterConfig); services.AddSingleton\u0026lt;IMapper\u0026gt;(mapperConfig); } } The MapsterConfiguration class contains the implementation of the AddMapster extension method. Inside this method, the TypeAdapterConfig is retrieved from the GlobalSettings and the application assembly is scanned for mappings.\nFinally, an instance of the Mapper class is created with the TypeAdapterConfig and registered as a singleton service in the IServiceCollection.\nBaseDTO.cs The BaseDTO class has two generic type parameters: TDTO and TEntity. These parameters represent the DTO and entity types, respectively. The class constraints ensure that TDTO and TEntity are reference types and have a default constructor.\nusing Mapster; namespace BlazorAppObjectMappingwithMapster.Data; public abstract class BaseDTO\u0026lt;TDTO, TEntity\u0026gt; : IRegister where TDTO : class, new() where TEntity : class, new() { public TEntity ToEntity() { return this.Adapt\u0026lt;TEntity\u0026gt;(); } public TEntity ToEntity(TEntity entity) { return (this as TDTO).Adapt(entity); } public static TDTO FromEntity(TEntity entity) { return entity.Adapt\u0026lt;TDTO\u0026gt;(); } private TypeAdapterConfig Config { get; set; } public virtual void AddCustomMappings() { } protected TypeAdapterSetter\u0026lt;TDTO, TEntity\u0026gt; SetCustomMappings() =\u0026gt; Config.ForType\u0026lt;TDTO, TEntity\u0026gt;(); protected TypeAdapterSetter\u0026lt;TEntity, TDTO\u0026gt; SetCustomMappingsInverse() =\u0026gt; Config.ForType\u0026lt;TEntity, TDTO\u0026gt;(); public void Register(TypeAdapterConfig config) { Config = config; AddCustomMappings(); } } ToEntity(): This method converts the current DTO instance to an entity instance using the Adapt method provided by the Mapster library.\nToEntity(TEntity entity): This overloaded method converts the current DTO instance to an entity instance and assigns the values to an existing entity object.\nFromEntity(TEntity entity): This static method converts an entity instance to a DTO instance using the Adapt method.\nAddCustomMappings(): This method can be overridden in derived classes to add custom mappings using the SetCustomMappings method.\nSetCustomMappings(): This method returns a TypeAdapterSetter object that allows for configuring custom mappings between the DTO and entity types.\nSetCustomMappingsInverse(): This method returns a TypeAdapterSetter object that allows for configuring custom mappings in the inverse direction (from entity to DTO).\nBlogPostViewModel.cs The BlogPostViewModel class is defined in the BlazorAppObjectMappingwithMapster.ViewModels namespace. It inherits from the BaseDTO\u0026lt;BlogPostViewModel, BlogPost\u0026gt; class, which suggests that it is a data transfer object (DTO) used for mapping between the view and the model.\nusing BlazorAppObjectMappingwithMapster.Data; using BlazorAppObjectMappingwithMapster.Models; using System.ComponentModel.DataAnnotations; namespace BlazorAppObjectMappingwithMapster.ViewModels; public class BlogPostViewModel : BaseDTO\u0026lt;BlogPostViewModel, BlogPost\u0026gt; { public int Id { get; set; } [Required(AllowEmptyStrings = false, ErrorMessage = \u0026#34;Title can not be empty\u0026#34;)] public string Title { get; set; } = string.Empty; [Required(AllowEmptyStrings = false, ErrorMessage = \u0026#34;Content can not be empty\u0026#34;)] public string Content { get; set; } = string.Empty; public string TitleShort { get; set; } = string.Empty; public string ContentShort { get; set; } = string.Empty; public override void AddCustomMappings() { // from BlogPostViewModel to BlogPost SetCustomMappings().Map(dst =\u0026gt; dst.Title, src =\u0026gt; src.Title); // from BlogPost to BlogPostViewModel SetCustomMappingsInverse().Map(dst =\u0026gt; dst.TitleShort, src =\u0026gt; src.Title.Substring(0, Math.Min(src.Title.Count(), 10))) .Map(dst =\u0026gt; dst.ContentShort, src =\u0026gt; src.Content.Substring(0, Math.Min(src.Content.Count(), 50))); // base.AddCustomMappings(); } } In the AddCustomMappings method, we define the custom mappings between the BlogPostViewModel and BlogPost objects.\nIndex.razor blogPosts = Mapper.Map\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;, IEnumerable\u0026lt;BlogPostViewModel\u0026gt;\u0026gt;(result); In this code, blogPosts is a variable of type IEnumerable\u0026lt;BlogPostViewModel\u0026gt;, and result is a variable of type IEnumerable\u0026lt;BlogPost\u0026gt;. We use the Mapper.Map method provided by Mapster to perform the object mapping. The method takes two parameters: the source object (result) and the destination type (IEnumerable).\nCreate.razor // option 1 // var model = blogPost.ToEntity(); // option 2 var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.AddBlogPostAsync(model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); The first option (blogPost.ToEntity()) is commented out, indicating an alternative approach to object mapping. This option suggests that there might be a custom method ToEntity() defined in the blogPost object that performs the mapping to the desired entity type.\nThe second option uses the Mapper.Map method provided by the Mapster library. It takes two parameters: the source object (blogPost) and the destination type (BlogPost). It performs the mapping operation and returns an instance of the destination type (model).\nDetails.razor // option 1 // blogPost = BlogPostViewModel.FromEntity(result); // option 2 blogPost = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(result); The first option involves using a static method FromEntity defined in the BlogPostViewModel class. This method takes a BlogPost object as a parameter and returns a BlogPostViewModel object.\nThe second option utilizes the Mapper class provided by Mapster. This class provides a convenient way to perform object mapping using a fluent syntax.\nDelete.razor // option 1 // blogPost = BlogPostViewModel.FromEntity(result); // option 2 blogPost = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(result); In first option, we are calling a static method FromEntity defined in the BlogPostViewModel class. This method is responsible for creating a new instance of BlogPostViewModel and mapping the properties from the result object to the corresponding properties in the BlogPostViewModel object.\nIn second option, we are using Mapster's Mapper class to perform the object mapping. The Map method is a generic method that takes the source object type (BlogPost) and the destination object type (BlogPostViewModel) as type arguments.\nEdit.razor protected override async Task OnInitializedAsync() { if (blogPost is null) { var result = await BlogPostService.GetbyId(id); if (result != null) { // option 1 // blogPost = BlogPostViewModel.FromEntity(result); // option 2 blogPost = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(result); } } } private async void HandleValidSubmit() { if (blogPost is null) return; // option 1 // var model = blogPost.ToEntity(); // option 2 var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.UpdateBlogPostAsync(id, model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } The OnInitializedAsync method and check if the blogPost object is null. If it is null, we retrieve the blog post from the BlogPostService using the GetById method. If the result is not null, we perform the object mapping using Mapster\u0026rsquo;s Mapper.Map method. We pass the source object result of type BlogPost and the destination type BlogPostViewModel. The mapped object is then assigned to the blogPost variable.\nThe HandleValidSubmit method that is called when the form is submitted and the data is valid. We first check if the blogPost object is null. If it is null, we return. Otherwise, we perform the object mapping using Mapster\u0026rsquo;s Mapper.Map method. We pass the source object blogPost of type BlogPostViewModel and the destination type BlogPost. The mapped object is then assigned to the model variable. We then call the UpdateBlogPostAsync method of the BlogPostService to update the blog post with the new model. If the update is successful, we navigate to the \u0026quot;/BlogPost\u0026quot; page.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppObjectMappingwithMapster\n","date":"January 24, 2024","hero":"/dotnet/2024-01-24-blazor-.net8-object-mapping-with-mapster/blazor_dotnet8_mapster.jpg","permalink":"https://akifmt.github.io/dotnet/2024-01-24-blazor-.net8-object-mapping-with-mapster/","summary":"Blazor .NET 8 Object Mapping with Mapster In a Blazor application, object mapping is a common task that involves converting data from one object type to another. This is often required when working with data transfer objects (DTOs) or when mapping data between different layers of an application. Mapster is a popular mapping library in the .NET ecosystem that provides a simple and efficient way to perform object mapping in Blazor applications.","tags":["dotnet8",".NET8","Blazor","Object Mapping with Mapster"],"title":"Blazor .NET 8 Object Mapping with Mapster"},{"categories":["dotnet8",".NET8","Migrating app from .NET 6 or .NET 7 to .NET 8"],"contents":" Blazor .NET 8 Migrating app from .NET 6 or .NET 7 to .NET 8 Migrating your Blazor app from .NET 6 or .NET 7 to .NET 8 can bring several benefits, including improved performance, enhanced features, and bug fixes. Here are the steps you can follow to migrate your app successfully.\n(Old) Request Flow Request  _Host  App  Component\n(New) Request Flow Request  App  Routes  Component\nUpdate your project file .csproj Open your Blazor app\u0026rsquo;s project file (.csproj) and change the TargetFramework to .NET 8.0. This ensures that your app targets the latest version of .NET.\n(OLD) .csproj\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;/Project\u0026gt; (NEW) .csproj\n\u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net8.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt; \u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;/Project\u0026gt; (Optional) Update NuGet packages Use the NuGet Package Manager or the .NET CLI to update the NuGet packages used in your project to their latest versions compatible with .NET 8. This ensures that you have the most up-to-date dependencies.\n(OLD) .csproj\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore\u0026#34; Version=\u0026#34;6.0.22\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;6.0.22\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;6.0.22\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;6.0.22\u0026#34;\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;6.0.16\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; (NEW) .csproj\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore\u0026#34; Version=\u0026#34;8.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.AspNetCore.Identity.EntityFrameworkCore\u0026#34; Version=\u0026#34;8.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.SqlServer\u0026#34; Version=\u0026#34;8.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.EntityFrameworkCore.Tools\u0026#34; Version=\u0026#34;8.0.0\u0026#34;\u0026gt; \u0026lt;PrivateAssets\u0026gt;all\u0026lt;/PrivateAssets\u0026gt; \u0026lt;IncludeAssets\u0026gt;runtime; build; native; contentfiles; analyzers; buildtransitive\u0026lt;/IncludeAssets\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;8.0.0\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; Update Program.cs To migrate your Blazor app to .NET 8, you need to update the Program.cs file. Specifically, you need to make changes to the services configuration and the app routing.\n(OLD) Program.cs\n... // Add services to the container. builder.Services.AddRazorPages(); builder.Services.AddServerSideBlazor(); ... app.UseRouting(); app.MapBlazorHub(); app.MapFallbackToPage(\u0026#34;/_Host\u0026#34;); ... (NEW) Program.cs\n... // Add services to the container. builder.Services.AddRazorComponents() .AddInteractiveServerComponents(); ... app.UseAntiforgery(); app.MapRazorComponents\u0026lt;App\u0026gt;() .AddInteractiveServerRenderMode(); ... In the old code, the services were added using the AddRazorPages() and AddServerSideBlazor() methods. However, in the new code, we use the AddRazorComponents() method to add the services required for Interactive Server Components.\nThe UseRouting() method is replaced with the UseAntiforgery() method, which adds anti-forgery protection to the app. This is necessary to prevent cross-site request forgery attacks.\nThe MapBlazorHub() method is replaced with the MapRazorComponents\u0026lt;App\u0026gt;() method, which maps the Blazor components to the app and sets the root component to App. Additionally, the AddInteractiveServerRenderMode() method is used to enable interactive server rendering.\nfrom _Host.cshtml to App.razor By migrating the App.razor file to the new Routes.razor file, you can ensure compatibility with the latest version of .NET and take advantage of any new features or improvements. Remember to make the necessary changes to the AppAssembly and DefaultLayout parameters, and handle not found routes if required.\nIn the old App.razor file, the routing configuration was defined. In the new Routes.razor file, the routing configuration is moved. Here\u0026rsquo;s an example of the old and new code\n(OLD) App.razor\n\u0026lt;Router AppAssembly=\u0026#34;@typeof(App).Assembly\u0026#34;\u0026gt; \u0026lt;Found Context=\u0026#34;routeData\u0026#34;\u0026gt; \u0026lt;RouteView RouteData=\u0026#34;@routeData\u0026#34; DefaultLayout=\u0026#34;@typeof(MainLayout)\u0026#34; /\u0026gt; \u0026lt;FocusOnNavigate RouteData=\u0026#34;@routeData\u0026#34; Selector=\u0026#34;h1\u0026#34; /\u0026gt; \u0026lt;/Found\u0026gt; \u0026lt;NotFound\u0026gt; \u0026lt;PageTitle\u0026gt;Not found\u0026lt;/PageTitle\u0026gt; \u0026lt;LayoutView Layout=\u0026#34;@typeof(MainLayout)\u0026#34;\u0026gt; \u0026lt;p role=\u0026#34;alert\u0026#34;\u0026gt;Sorry, there\u0026#39;s nothing at this address.\u0026lt;/p\u0026gt; \u0026lt;/LayoutView\u0026gt; \u0026lt;/NotFound\u0026gt; \u0026lt;/Router\u0026gt; (NEW) Routes.razor\n\u0026lt;Router AppAssembly=\u0026#34;typeof(Program).Assembly\u0026#34;\u0026gt; \u0026lt;Found Context=\u0026#34;routeData\u0026#34;\u0026gt; \u0026lt;RouteView RouteData=\u0026#34;routeData\u0026#34; DefaultLayout=\u0026#34;typeof(Layout.MainLayout)\u0026#34; /\u0026gt; \u0026lt;FocusOnNavigate RouteData=\u0026#34;routeData\u0026#34; Selector=\u0026#34;h1\u0026#34; /\u0026gt; \u0026lt;/Found\u0026gt; \u0026lt;/Router\u0026gt; In the old _Host.cshtml file, the Blazor component was rendered. In the new App.razor file, the rendering logic is moved. Here\u0026rsquo;s an example of the old and new code:\n(OLD) _Host.cshtml\n@page \u0026#34;/\u0026#34; @namespace BlazorApp.Pages @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers @{ Layout = \u0026#34;_Layout\u0026#34;; } \u0026lt;component type=\u0026#34;typeof(App)\u0026#34; render-mode=\u0026#34;ServerPrerendered\u0026#34; /\u0026gt; (NEW) App.razor\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;base href=\u0026#34;/\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bootstrap/bootstrap.min.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;app.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;BlazorApp4.styles.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;favicon.png\u0026#34; /\u0026gt; \u0026lt;HeadOutlet @rendermode=\u0026#34;InteractiveServer\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;Routes @rendermode=\u0026#34;InteractiveServer\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;_framework/blazor.web.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Information\nRemove @page directives Update base links: from \u0026quot;~/\u0026quot; to \u0026quot;/\u0026quot; Update render-mode to \u0026quot;\u0026lt;HeadOutlet/\u0026gt;\u0026quot; Update script name from \u0026quot;\u0026lt;script src=\u0026quot;_framework/blazor.server.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; to \u0026quot;\u0026lt;script src=\u0026quot;_framework/blazor.web.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; Add Routes \u0026quot;\u0026lt;Routes/\u0026gt;\u0026quot; (Optional) Update render-mode (global render-mode) \u0026lt;HeadOutlet @rendermode=\u0026#34;InteractiveServer\u0026#34; /\u0026gt; \u0026lt;Routes @rendermode=\u0026#34;InteractiveServer\u0026#34; /\u0026gt; (Optional) Update forms in the project Project Structure\nOLD Data Pages Properties Shared wwwroot NEW Components Layout Pages Properties wwwroot Remember to back up your code and project files before starting the migration process. This allows you to revert to the previous version if any issues arise during the migration.\nBy following these steps, you can successfully migrate your Blazor app from .NET 6 or .NET 7 to .NET 8 and take advantage of the latest features and improvements offered by the framework.\n","date":"January 20, 2024","hero":"/dotnet/2024-01-20-blazor-.net8-migrating-app-from-.net-6-or-.net-7-to-.net-8/blazor_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-01-20-blazor-.net8-migrating-app-from-.net-6-or-.net-7-to-.net-8/","summary":"Blazor .NET 8 Migrating app from .NET 6 or .NET 7 to .NET 8 Migrating your Blazor app from .NET 6 or .NET 7 to .NET 8 can bring several benefits, including improved performance, enhanced features, and bug fixes. Here are the steps you can follow to migrate your app successfully.\n(Old) Request Flow Request  _Host  App  Component\n(New) Request Flow Request  App  Routes  Component","tags":["dotnet8",".NET8","Blazor","Migrating app from .NET 6 or .NET 7 to .NET 8"],"title":"Blazor .NET 8 Migrating app from .NET 6 or .NET 7 to .NET 8"},{"categories":["dotnet8",".NET8","Blazor","Server-side Rendering","SSR"],"contents":" Blazor .NET 8 Server-side Rendering (SSR) Blazor .NET 8 offers several rendering options, including Server-side Rendering (SSR). SSR allows the initial rendering of a Blazor application to be performed on the server before being sent to the client. This approach provides benefits such as improved performance, SEO-friendliness, and better accessibility.\nIn Blazor .NET 8, there are two main ways to implement SSR: Global SSR with Prerendering and Per Page/Component SSR with Prerendering.\nEnable Global Rendering Global SSR with Prerendering involves rendering the entire application on the server and sending the pre-rendered HTML to the client. This approach is suitable for applications where the content is mostly static and doesn\u0026rsquo;t require frequent updates. It ensures that the initial page load is fast and provides a good user experience.\nApp.razor\n... \u0026lt;HeadOutlet @rendermode=\u0026#34;@InteractiveServer\u0026#34; /\u0026gt; ... \u0026lt;Routes @rendermode=\u0026#34;@InteractiveServer\u0026#34; /\u0026gt; ... In the code snippet above, we have two components: HeadOutlet and Routes. These components are responsible for rendering the head section and routing in the application, respectively. The @rendermode attribute is set to @InteractiveServer, which enables SSR and prerendering.\nEnable Global Rendering without Prerendering App.razor\n... \u0026lt;HeadOutlet @rendermode=\u0026#34;new InteractiveServerRenderMode(prerender: false)\u0026#34; /\u0026gt; ... \u0026lt;Routes @rendermode=\u0026#34;new InteractiveServerRenderMode(prerender: false)\u0026#34; /\u0026gt; ...\tTo enable global rendering without prerendering, we set the rendermode parameter of both components to an instance of InteractiveServerRenderMode with the prerender parameter set to false. This instructs the components to skip the prerendering process and perform rendering on the server dynamically.\nBy disabling prerendering, the application will be fully rendered on the server and sent to the client as HTML. The client-side JavaScript and WebAssembly code will still be loaded and executed, but the initial HTML content will be available immediately, providing a faster initial load time.\nEnable per Page/Component Rendering Per Page/Component SSR with Prerendering allows you to selectively choose which pages or components should be pre-rendered on the server. This approach is useful when you have dynamic content that needs to be updated frequently. By pre-rendering specific pages or components, you can strike a balance between performance and dynamic content updates.\nApp.razor\n... \u0026lt;HeadOutlet /\u0026gt; ... \u0026lt;Routes /\u0026gt; ... The \u0026lt;HeadOutlet /\u0026gt; component is responsible for rendering the \u0026lt;head\u0026gt; section of the HTML document. It is required for client-side rendering.\nCounter.razor\n@page \u0026#34;/counter\u0026#34; ... @rendermode InteractiveServer ... Enable per Page/Component Rendering without Prerendering Counter.razor\n@page \u0026#34;/counter\u0026#34; ... @rendermode @(new InteractiveServerRenderMode(prerender: false)) ... In the above code snippet, we have a Blazor page with the route /counter. By setting @rendermode @(new InteractiveServerRenderMode(prerender: false)), we disable prerendering for this specific page. This means that the page will be rendered on the server and sent to the client without any prerendering.\nEnable per Page/Component Rendering with StreamRendering StreamRendering attribute in Blazor, is available in Blazor with .NET 8 and allows us to optimize the rendering process by rendering components or pages individually instead of rendering the entire application.\nWeather.razor\n@page \u0026#34;/weather\u0026#34; ... @attribute [StreamRendering] ... Enabling per page/component rendering using the StreamRendering attribute in Blazor with .NET 8 can greatly improve the performance of your application. By rendering only the necessary components or pages when there is a state change, you can optimize the rendering process and provide a smoother user experience.\nEnable AUTO Rendering Blazor .NET 8 also provides an AUTO rendering option, which automatically determines the appropriate rendering mode based on the client\u0026rsquo;s capabilities. This allows the application to adapt to different scenarios, providing the best possible experience for each user. Automatic (Auto) rendering determines how to render the component at runtime.\nAutorenderpage.razor\n@page \u0026#34;/autorenderpage\u0026#34; ... @rendermode InteractiveAuto ...\tIn the code snippet above, we define a Blazor page with the @page directive, specifying the URL route for the page. The @rendermode directive is used to set the render mode to InteractiveAuto, enabling auto rendering for the page.\nRendering by the Path App.razor\n... \u0026lt;HeadOutlet @rendermode=\u0026#34;@RenderModeForPage\u0026#34; /\u0026gt; ... \u0026lt;Routes @rendermode=\u0026#34;@RenderModeForPage\u0026#34; /\u0026gt; ... @code { [CascadingParameter] private HttpContext HttpContext { get; set; } = default!; private static IComponentRenderMode InteractiveServerWithoutPrerendering = new InteractiveServerRenderMode(prerender: false); // change render mode according to Path private IComponentRenderMode? RenderModeForPage =\u0026gt; HttpContext.Request.Path.StartsWithSegments(\u0026#34;/Account\u0026#34;) ? null : InteractiveServer; } the HeadOutlet component and the Routes component are rendered based on the RenderModeForPage property. The RenderModeForPage property is determined by the current path of the HTTP request. If the path starts with \u0026ldquo;/Account\u0026rdquo;, the render mode is set to null, which means the default render mode will be used.\nInformation\nThe default render mode is Static. The default prerender mode is True. The default StreamRendering attribute parameter is True. Can not switch to a different interactive render mode in a child component. Source https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0\n","date":"January 16, 2024","hero":"/dotnet/2024-01-16-blazor-.net8-server-side-rendering-ssr/blazor_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-01-16-blazor-.net8-server-side-rendering-ssr/","summary":"Blazor .NET 8 Server-side Rendering (SSR) Blazor .NET 8 offers several rendering options, including Server-side Rendering (SSR). SSR allows the initial rendering of a Blazor application to be performed on the server before being sent to the client. This approach provides benefits such as improved performance, SEO-friendliness, and better accessibility.\nIn Blazor .NET 8, there are two main ways to implement SSR: Global SSR with Prerendering and Per Page/Component SSR with Prerendering.","tags":["dotnet8",".NET8","Blazor","Server-side Rendering","SSR"],"title":"Blazor .NET 8 Server-side Rendering (SSR)"},{"categories":["dotnet8",".NET8","Blazor","Hosting Models"],"contents":" Blazor .NET8 Hosting Models Blazor, a web framework developed by Microsoft, offers three hosting models: Blazor Server, Blazor WebAssembly, and Blazor Hybrid. Each hosting model has its own unique characteristics and use cases.\nBlazor Server With the Blazor Server hosting model, components are executed on the server from within an ASP.NET Core app. UI updates, event handling, and JavaScript calls are handled over a SignalR connection using the WebSockets protocol.\nIn the Blazor Server hosting model, the application runs on the server and the UI is rendered on the client using SignalR. The client-side UI updates are sent to the server, which then updates the UI on the client. This model provides a rich user experience with real-time updates and minimal client-side resources. It is suitable for applications that require high interactivity and real-time communication. Blazor WebAssembly The Blazor WebAssembly hosting model runs components client-side in the browser on a WebAssembly-based .NET runtime.\nIn the Blazor WebAssembly hosting model, the application is downloaded and executed on the client-side using WebAssembly. The entire application, including the UI and business logic, is executed in the client\u0026rsquo;s browser. This model provides a fully client-side experience with offline support and the ability to run in any modern browser. It is suitable for applications that require offline capabilities or need to run in a browser without a server connection. Blazor Hybrid Blazor can also be used to build native client apps using a hybrid approach. Hybrid apps are native apps that leverage web technologies for their functionality. In a Blazor Hybrid app, Razor components run directly in the native app (not on WebAssembly) along with any other .NET code and render web UI based on HTML and CSS to an embedded Web View control through a local interop channel.\nThe Blazor Hybrid hosting model combines the features of both Blazor Server and Blazor WebAssembly. The application is initially rendered on the server and then downloaded to the client-side for further execution. This model provides the benefits of both server-side and client-side rendering, offering a balance between interactivity and performance. It is suitable for applications that require a mix of real-time updates and client-side execution. Choosing Blazor Hosting Model Each hosting model has its own advantages and considerations, and the choice depends on the specific requirements of the application. Blazor .NET 8 provides developers with the flexibility to choose the most suitable hosting model for their projects.\nWith the Blazor Server hosting model, components are executed on the server from within an ASP.NET Core app. For standalone Blazor WebAssembly apps, all of the app\u0026rsquo;s components are rendered on the client with the Blazor WebAssembly hosting model. Blazor Hybrid apps include .NET MAUI, WPF, and Windows Forms framework apps. Source https://learn.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-8.0\n","date":"January 13, 2024","hero":"/dotnet/2024-01-13-blazor-.net8-hosting-models/blazor_dotnet8.jpg","permalink":"https://akifmt.github.io/dotnet/2024-01-13-blazor-.net8-hosting-models/","summary":"Blazor .NET8 Hosting Models Blazor, a web framework developed by Microsoft, offers three hosting models: Blazor Server, Blazor WebAssembly, and Blazor Hybrid. Each hosting model has its own unique characteristics and use cases.\nBlazor Server With the Blazor Server hosting model, components are executed on the server from within an ASP.NET Core app. UI updates, event handling, and JavaScript calls are handled over a SignalR connection using the WebSockets protocol.","tags":["dotnet8",".NET8","Blazor","Hosting Models"],"title":"Blazor .NET 8 Hosting Models"},{"categories":null,"contents":"Loading ","date":"January 1, 2024","hero":"/contacts/contact/contact.jpg","permalink":"https://akifmt.github.io/contacts/contact/","summary":"Loading ","tags":null,"title":"Contact"},{"categories":["Dotnet","Blazor Infinite Scrolling"],"contents":" Blazor Infinite Scrolling Blazor: Blazor is a web framework developed by Microsoft that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack web development with .NET.\nInfinite Scrolling: Infinite scrolling is a technique where new data is loaded and displayed as the user scrolls down the page. It provides a smooth and continuous browsing experience without the need for manual pagination.\nRazor Components: Razor Components is a part of Blazor that allows developers to build reusable UI components using a combination of HTML and C#. These components can be used to create dynamic and interactive web applications.\nInfiniteScrollingItemsProviderRequest.cs The InfiniteScrollingItemsProviderRequest class is defined within the BlazorAppInfiniteScrolling.Components namespace. It is a sealed class, meaning it cannot be inherited from. The class has two properties: StartIndex and CancellationToken.\nnamespace BlazorAppInfiniteScrolling.Components; public sealed class InfiniteScrollingItemsProviderRequest { public InfiniteScrollingItemsProviderRequest(int startIndex, CancellationToken cancellationToken) { StartIndex = startIndex; CancellationToken = cancellationToken; } public int StartIndex { get; } public CancellationToken CancellationToken { get; } } public delegate Task\u0026lt;IEnumerable\u0026lt;int\u0026gt;\u0026gt; ItemsProviderRequestDelegate(InfiniteScrollingItemsProviderRequest request); public delegate Task\u0026lt;IEnumerable\u0026lt;T\u0026gt;\u0026gt; ItemsProviderRequestDelegate\u0026lt;T\u0026gt;(InfiniteScrollingItemsProviderRequest request); The InfiniteScrollingItemsProviderRequest class has a constructor that takes two parameters: startIndex and cancellationToken. The startIndex parameter represents the index from which the data should be loaded, and the cancellationToken parameter is used to cancel the data loading operation if needed.\nThe class also has two properties: StartIndex and CancellationToken. The StartIndex property is a read-only property that returns the value passed in the constructor. The CancellationToken property is also read-only and returns the cancellation token passed in the constructor.\nInfiniteScrolling.razor Several classes and delegates that are essential for implementing infinite scrolling in Blazor.\n@namespace BlazorAppInfiniteScrolling.Components @typeparam T @foreach (var item in _items) { @ItemTemplate(item) } @if (_loading) { @LoadingTemplate } @if (!_enumerationCompleted) { \u0026lt;div @ref=\u0026#34;_lastItemIndicator\u0026#34; style=\u0026#34;height:1px;flex-shrink:0\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; } The InfiniteScrollingItemsProviderRequest class represents a request for fetching items for infinite scrolling. It takes the start index and a cancellation token as parameters.\nThe ItemsProviderRequestDelegate delegate defines a method signature for fetching items based on the InfiniteScrollingItemsProviderRequest. It can be used to provide a custom implementation for fetching data.\nInfiniteScrolling.razor.cs The InfiniteScrolling component is a generic component that takes a type parameter T, which represents the type of the items to be displayed. It inherits from the ComponentBase class and implements the IAsyncDisposable interface.\nusing Microsoft.AspNetCore.Components; using Microsoft.JSInterop; namespace BlazorAppInfiniteScrolling.Components; public partial class InfiniteScrolling\u0026lt;T\u0026gt; : ComponentBase, IAsyncDisposable { private List\u0026lt;T\u0026gt; _items = new(); private ElementReference _lastItemIndicator; private DotNetObjectReference\u0026lt;InfiniteScrolling\u0026lt;T\u0026gt;\u0026gt;? _currentComponentReference; private IJSObjectReference? _module; private IJSObjectReference? _instance; private bool _loading = false; private bool _enumerationCompleted = false; private CancellationTokenSource? _loadItemsCts; [Inject] private IJSRuntime? JSRuntime { get; set; } [Parameter] public ItemsProviderRequestDelegate\u0026lt;T\u0026gt;? ItemsProvider { get; set; } [Parameter] public RenderFragment\u0026lt;T\u0026gt;? ItemTemplate { get; set; } [Parameter] public RenderFragment? LoadingTemplate { get; set; } [JSInvokable] public async Task LoadMoreItems() { if (_loading) return; _loading = true; try { _loadItemsCts ??= new CancellationTokenSource(); StateHasChanged(); try { var newItems = await ItemsProvider(new InfiniteScrollingItemsProviderRequest(_items.Count, _loadItemsCts.Token)); var previousCount = _items.Count; _items.AddRange(newItems); if (_items.Count == previousCount) { _enumerationCompleted = true; } else { await _instance.InvokeVoidAsync(\u0026#34;onNewItems\u0026#34;); } } catch (OperationCanceledException oce) when (oce.CancellationToken == _loadItemsCts.Token) { } } finally { _loading = false; } StateHasChanged(); } protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { _module = await JSRuntime.InvokeAsync\u0026lt;IJSObjectReference\u0026gt;(\u0026#34;import\u0026#34;, \u0026#34;./infinite-scrolling.js\u0026#34;); _currentComponentReference = DotNetObjectReference.Create(this); _instance = await _module.InvokeAsync\u0026lt;IJSObjectReference\u0026gt;(\u0026#34;initialize\u0026#34;, _lastItemIndicator, _currentComponentReference); } } public async ValueTask DisposeAsync() { if (_loadItemsCts != null) { _loadItemsCts.Dispose(); _loadItemsCts = null; } if (_instance != null) { await _instance.InvokeVoidAsync(\u0026#34;dispose\u0026#34;); await _instance.DisposeAsync(); _instance = null; } if (_module != null) { await _module.DisposeAsync(); } _currentComponentReference?.Dispose(); } } The component has several private fields, including a list of items _items, a reference to the last item indicator _lastItemIndicator, a reference to the current component _currentComponentReference, and references to the JavaScript module _module and instance _instance. It also has boolean flags _loading and _enumerationCompleted to track the loading state and whether the enumeration of items is completed.\nThe component has several properties, including an injected IJSRuntime for JavaScript interop, a ItemsProvider delegate for providing the items, an ItemTemplate for rendering the items, and a LoadingTemplate for rendering the loading indicator.\nThe component also defines the LoadMoreItems method, which is invoked when the user scrolls to the end of the list or grid. It handles the loading of more items by calling the ItemsProvider delegate and updating the UI.\nThe OnAfterRenderAsync method is overridden to initialize the JavaScript module and instance when the component is first rendered. It imports the JavaScript module, creates a reference to the current component, and initializes the JavaScript instance with the last item indicator and the component reference.\nThe DisposeAsync method is implemented to dispose of any resources used by the component, such as cancellation tokens, JavaScript instances, and references.\ninfinite-scrolling.js The initialize function takes two parameters: lastItemIndicator and componentInstance. The lastItemIndicator is the element that indicates the last item in the list, and the componentInstance is the instance of the Blazor component.\nexport function initialize(lastItemIndicator, componentInstance) { const options = { root: findClosestScrollContainer(lastItemIndicator), rootMargin: \u0026#39;0px\u0026#39;, threshold: 0, }; const observer = new IntersectionObserver(async (entries) =\u0026gt; { for (const entry of entries) { if (entry.isIntersecting) { observer.unobserve(lastItemIndicator); await componentInstance.invokeMethodAsync(\u0026#34;LoadMoreItems\u0026#34;); } } }, options); observer.observe(lastItemIndicator); return { dispose: () =\u0026gt; dispose(observer), onNewItems: () =\u0026gt; { observer.unobserve(lastItemIndicator); observer.observe(lastItemIndicator); }, }; } function dispose(observer) { observer.disconnect(); } function findClosestScrollContainer(element) { while (element) { const style = getComputedStyle(element); if (style.overflowY !== \u0026#39;visible\u0026#39;) { return element; } element = element.parentElement; } return null; } The initialize function creates an Intersection Observer with the specified options and attaches a callback function to it. When the last item indicator element intersects with the viewport, the callback function is triggered. It then unobserves the last item indicator, and asynchronously invokes the LoadMoreItems method on the Blazor component instance.\nThe dispose function is used to disconnect the Intersection Observer when it is no longer needed. The findClosestScrollContainer function is a helper function that finds the closest scrollable container element for the given element.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppInfiniteScrolling\n","date":"October 16, 2023","hero":"/dotnet/2023-10-16-blazor-infinite-scrolling/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-10-16-blazor-infinite-scrolling/","summary":"Blazor Infinite Scrolling Blazor: Blazor is a web framework developed by Microsoft that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack web development with .NET.\nInfinite Scrolling: Infinite scrolling is a technique where new data is loaded and displayed as the user scrolls down the page. It provides a smooth and continuous browsing experience without the need for manual pagination.\nRazor Components: Razor Components is a part of Blazor that allows developers to build reusable UI components using a combination of HTML and C#.","tags":["Dotnet","Blazor Infinite Scrolling"],"title":"Blazor Infinite Scrolling"},{"categories":["Dotnet","Blazor Export Data to Word Excel PDF CSV"],"contents":" Blazor Export Data to Word, Excel, PDF, CSV We will explore how to export data to various file formats such as Word, Excel, PDF, and CSV using Blazor, a web framework for building interactive user interfaces.\nBlazor: Blazor is a web framework that allows developers to build interactive web applications using C# instead of JavaScript. It enables the creation of rich UI components and provides a seamless integration between the client and server.\nExporting Data: Exporting data refers to the process of converting data from one format to another, such as exporting data from a web application to a file format like Word, Excel, PDF, or CSV. This allows users to save or share the data in a more convenient and portable manner.\nPdfSharp: PdfSharp is a popular open-source library for creating and manipulating PDF documents in C#. It provides a comprehensive set of features for generating PDF files, including text formatting, images, tables, and more.\nFileFontResolver: The FileFontResolver class is a custom implementation of the IFontResolver interface provided by PdfSharp. It is responsible for resolving font information when exporting data to PDF. It maps font names to the corresponding font files in the application\u0026rsquo;s file system.\nProgram.cs ... // add PdfSharp FontResolver PdfSharp.Fonts.GlobalFontSettings.FontResolver = new FileFontResolver(); ... FileFontResolver.cs The FileFontResolver class implements the IFontResolver interface, which requires the implementation of two methods: GetFont and ResolveTypeface.\nusing PdfSharp.Fonts; namespace BlazorAppExport.Helpers; public class FileFontResolver : IFontResolver { public string DefaultFontName =\u0026gt; throw new NotImplementedException(); public byte[] GetFont(string faceName) { using (var ms = new MemoryStream()) { using (var fs = File.Open(faceName, FileMode.Open)) { fs.CopyTo(ms); ms.Position = 0; return ms.ToArray(); } } } public FontResolverInfo ResolveTypeface(string familyName, bool isBold, bool isItalic) { if (familyName.Equals(\u0026#34;Arial\u0026#34;, StringComparison.CurrentCultureIgnoreCase)) { if (isBold \u0026amp;\u0026amp; isItalic) { return new FontResolverInfo(\u0026#34;Fonts/arialbi.ttf\u0026#34;); } else if (isBold) { return new FontResolverInfo(\u0026#34;Fonts/arialbd.ttf\u0026#34;); } else if (isItalic) { return new FontResolverInfo(\u0026#34;Fonts/ariali.ttf\u0026#34;); } else { return new FontResolverInfo(\u0026#34;Fonts/arial.ttf\u0026#34;); } } if (familyName.Equals(\u0026#34;Times New Roman\u0026#34;, StringComparison.CurrentCultureIgnoreCase)) { if (isBold \u0026amp;\u0026amp; isItalic) { return new FontResolverInfo(\u0026#34;Fonts/timesbi.ttf\u0026#34;); } else if (isBold) { return new FontResolverInfo(\u0026#34;Fonts/timesbd.ttf\u0026#34;); } else if (isItalic) { return new FontResolverInfo(\u0026#34;Fonts/timesi.ttf\u0026#34;); } else { return new FontResolverInfo(\u0026#34;Fonts/times.ttf\u0026#34;); } } if (familyName.Equals(\u0026#34;Tahoma\u0026#34;, StringComparison.CurrentCultureIgnoreCase)) { if (isBold \u0026amp;\u0026amp; isItalic) { return new FontResolverInfo(\u0026#34;Fonts/tahoma.ttf\u0026#34;); } else if (isBold) { return new FontResolverInfo(\u0026#34;Fonts/tahomabd.ttf\u0026#34;); } else if (isItalic) { return new FontResolverInfo(\u0026#34;Fonts/tahoma.ttf\u0026#34;); } else { return new FontResolverInfo(\u0026#34;Fonts/tahoma.ttf\u0026#34;); } } if (familyName.Equals(\u0026#34;Verdana\u0026#34;, StringComparison.CurrentCultureIgnoreCase)) { if (isBold \u0026amp;\u0026amp; isItalic) { return new FontResolverInfo(\u0026#34;Fonts/verdanaz.ttf\u0026#34;); } else if (isBold) { return new FontResolverInfo(\u0026#34;Fonts/verdanab.ttf\u0026#34;); } else if (isItalic) { return new FontResolverInfo(\u0026#34;Fonts/verdanai.ttf\u0026#34;); } else { return new FontResolverInfo(\u0026#34;Fonts/verdana.ttf\u0026#34;); } } if (familyName.Equals(\u0026#34;Courier New\u0026#34;, StringComparison.CurrentCultureIgnoreCase)) { if (isBold \u0026amp;\u0026amp; isItalic) { return new FontResolverInfo(\u0026#34;Fonts/courbi.ttf\u0026#34;); } else if (isBold) { return new FontResolverInfo(\u0026#34;Fonts/courbd.ttf\u0026#34;); } else if (isItalic) { return new FontResolverInfo(\u0026#34;Fonts/couri.ttf\u0026#34;); } else { return new FontResolverInfo(\u0026#34;Fonts/cour.ttf\u0026#34;); } } return null; } } The GetFont method is responsible for retrieving the font data based on the provided faceName. It uses the File.Open method to open the font file and then copies its contents to a MemoryStream. Finally, it returns thebyte array representation of the font data.\nThe ResolveTypeface method is responsible for resolving the font information based on the provided familyName, isBold, and isItalic parameters. It checks the familyName against a set of predefined font names and returns the corresponding FontResolverInfo object.\nMigraDocDocumentHelper.cs The code provided includes a MigraDocDocumentHelper class, which contains a static method CreateDocument. This method takes two parameters: headerColumnNames and dataColumns. It also has an optional parameter dataSplitChar, which defaults to '|'.\nusing MigraDoc.DocumentObjectModel; using MigraDoc.DocumentObjectModel.Shapes.Charts; using MigraDoc.DocumentObjectModel.Tables; namespace BlazorAppExport.Data; public class MigraDocDocumentHelper { public static Document CreateDocument(List\u0026lt;string\u0026gt; headerColumnNames, List\u0026lt;string\u0026gt; dataColumns, char dataSplitChar = \u0026#39;|\u0026#39;) { //GlobalFontSettings.FontResolver = new FileFontResolver(); // Create a new MigraDoc document Document document = new Document(); document.Info.Title = \u0026#34;title\u0026#34;; document.Info.Subject = \u0026#34;subject\u0026#34;; document.Info.Author = \u0026#34;author\u0026#34;; MigraDocStylesHelper.DefineStyles(document); MigraDocCoverHelper.DefineCover(document); MigraDocTableOfContentsHelper.DefineTableOfContents(document); MigraDocContentSectionHelper.DefineContentSection(document); //MigraDocParagraphsHelper.DefineParagraphs(document); //MigraDocTablesHelper.DefineTables(document); //MigraDocChartsHelper.DefineCharts(document); MigraDocTablesExportedDataHelper.DefineTablesExportedData(document, headerColumnNames, dataColumns, dataSplitChar); return document; } } The CreateDocument method is responsible for creating a new MigraDoc document and setting its title, subject, and author. It then calls various helper methods to define the document\u0026rsquo;s styles, cover page, table of contents, content section, and exported data tables.\nThe MigraDocTablesExportedDataHelper.DefineTablesExportedData method is responsible for creating tables in the document and populating them with the provided header column names and data columns. The dataSplitChar parameter is used to split the data columns into individual values.\nExportController.cs ExportController class demonstrates how to export data to a CSV, Excel, Pdf, Word file. This method takes an IQueryable query and an optional fileName parameter. It retrieves the properties of the query\u0026rsquo;s element type and iterates over each item in the query. For each item, it retrieves the values of the properties and appends them to a StringBuilder object.\npublic FileStreamResult ToCSV(IQueryable query, string? fileName = null) { var columns = GetProperties(query.ElementType); var sb = new StringBuilder(); foreach (var item in query) { var row = new List\u0026lt;string\u0026gt;(); foreach (var column in columns) { row.Add($\u0026#34;{GetValue(item, column.Key)}\u0026#34;.Trim()); } sb.AppendLine(string.Join(\u0026#34;,\u0026#34;, row.ToArray())); } var result = new FileStreamResult(new MemoryStream(UTF8Encoding.Default.GetBytes($\u0026#34;{string.Join(\u0026#34;,\u0026#34;, columns.Select(c =\u0026gt; c.Key))}{System.Environment.NewLine}{sb.ToString()}\u0026#34;)), \u0026#34;text/csv\u0026#34;); result.FileDownloadName = (!string.IsNullOrEmpty(fileName) ? fileName : \u0026#34;Export\u0026#34;) + \u0026#34;.csv\u0026#34;; return result; } public FileStreamResult ToExcel(IQueryable query, string? fileName = null) { var columns = GetProperties(query.ElementType); var stream = new MemoryStream(); using (var document = SpreadsheetDocument.Create(stream, SpreadsheetDocumentType.Workbook)) { var workbookPart = document.AddWorkbookPart(); workbookPart.Workbook = new Workbook(); var worksheetPart = workbookPart.AddNewPart\u0026lt;WorksheetPart\u0026gt;(); worksheetPart.Worksheet = new Worksheet(); var workbookStylesPart = workbookPart.AddNewPart\u0026lt;WorkbookStylesPart\u0026gt;(); GenerateWorkbookStylesPartContent(workbookStylesPart); var sheets = workbookPart.Workbook.AppendChild(new Sheets()); var sheet = new Sheet() { Id = workbookPart.GetIdOfPart(worksheetPart), SheetId = 1, Name = \u0026#34;Sheet1\u0026#34; }; sheets.Append(sheet); workbookPart.Workbook.Save(); var sheetData = worksheetPart.Worksheet.AppendChild(new SheetData()); var headerRow = new Row(); foreach (var column in columns) { headerRow.Append(new Cell() { CellValue = new CellValue(column.Key), DataType = new EnumValue\u0026lt;CellValues\u0026gt;(CellValues.String) }); } sheetData.AppendChild(headerRow); foreach (var item in query) { var row = new Row(); foreach (var column in columns) { var value = GetValue(item, column.Key); var stringValue = $\u0026#34;{value}\u0026#34;.Trim(); var cell = new Cell(); var underlyingType = column.Value.IsGenericType \u0026amp;\u0026amp; column.Value.GetGenericTypeDefinition() == typeof(Nullable\u0026lt;\u0026gt;) ? Nullable.GetUnderlyingType(column.Value) : column.Value; var typeCode = Type.GetTypeCode(underlyingType); if (typeCode == TypeCode.DateTime) { if (!string.IsNullOrWhiteSpace(stringValue)) { cell.CellValue = new CellValue() { Text = ((DateTime)value).ToOADate().ToString(System.Globalization.CultureInfo.InvariantCulture) }; cell.DataType = new EnumValue\u0026lt;CellValues\u0026gt;(CellValues.Number); cell.StyleIndex = (UInt32Value)1U; } } else if (typeCode == TypeCode.Boolean) { cell.CellValue = new CellValue(stringValue.ToLower()); cell.DataType = new EnumValue\u0026lt;CellValues\u0026gt;(CellValues.Boolean); } else if (IsNumeric(typeCode)) { if (value != null) { stringValue = Convert.ToString(value, CultureInfo.InvariantCulture); } cell.CellValue = new CellValue(stringValue); cell.DataType = new EnumValue\u0026lt;CellValues\u0026gt;(CellValues.Number); } else { cell.CellValue = new CellValue(stringValue); cell.DataType = new EnumValue\u0026lt;CellValues\u0026gt;(CellValues.String); } row.Append(cell); } sheetData.AppendChild(row); } workbookPart.Workbook.Save(); } if (stream?.Length \u0026gt; 0) { stream.Seek(0, SeekOrigin.Begin); } var result = new FileStreamResult(stream, \u0026#34;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026#34;); result.FileDownloadName = (!string.IsNullOrEmpty(fileName) ? fileName : \u0026#34;Export\u0026#34;) + \u0026#34;.xlsx\u0026#34;; return result; } public FileStreamResult ToPdf(IQueryable query, string? fileName = null) { var columns = GetProperties(query.ElementType); List\u0026lt;string\u0026gt; headerColumns = new List\u0026lt;string\u0026gt;(); foreach (var column in columns) { headerColumns.Add(column.Key); } char seperaterChar = \u0026#39;|\u0026#39;; List\u0026lt;string\u0026gt; dataColumns = new List\u0026lt;string\u0026gt;(); foreach (var item in query) { List\u0026lt;string\u0026gt; lineData = new List\u0026lt;string\u0026gt;(); foreach (var column in columns) { lineData.Add($\u0026#34;{GetValue(item, column.Key)}\u0026#34;.Trim()); } string lineString = string.Join(seperaterChar, lineData); dataColumns.Add(lineString); } var stream = new MemoryStream(); MigraDoc.DocumentObjectModel.Document doc = MigraDocDocumentHelper.CreateDocument(headerColumns, dataColumns, seperaterChar); MigraDoc.Rendering.PdfDocumentRenderer renderer = new(); renderer.Document = doc; renderer.RenderDocument(); renderer.PdfDocument.Save(stream); if (stream?.Length \u0026gt; 0) { stream.Seek(0, SeekOrigin.Begin); } FileStreamResult? result = new FileStreamResult(stream, \u0026#34;application/pdf\u0026#34;); result.FileDownloadName = \u0026#34;Export\u0026#34; + \u0026#34;.pdf\u0026#34;; return result; } public FileStreamResult ToWord(IQueryable query, string? fileName = null) { var columns = GetProperties(query.ElementType); var sb = new StringBuilder(); // titles sb.Append(\u0026#34;\u0026lt;table border=\u0026#39;1\u0026#39; cellpadding=\u0026#39;5\u0026#39; cellspacing=\u0026#39;0\u0026#39; style=\u0026#39;border: 1px solid #ccc;font-family: Arial; font-size: 10pt;\u0026#39;\u0026gt;\u0026#34;); sb.Append(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); foreach (var column in columns) { sb.Append($\u0026#34;\u0026lt;th style=\u0026#39;background-color: #B8DBFD;border: 1px solid #ccc\u0026#39;\u0026gt;{column.Key}\u0026lt;/th\u0026gt;\u0026#34;); } sb.Append(\u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;); // rows foreach (var item in query) { sb.Append(\u0026#34;\u0026lt;tr\u0026gt;\u0026#34;); //Append data. foreach (var column in columns) { sb.Append(\u0026#34;\u0026lt;td style=\u0026#39;border: 1px solid #ccc\u0026#39;\u0026gt;\u0026#34;); sb.Append(GetValue(item, column.Key)); sb.Append(\u0026#34;\u0026lt;/td\u0026gt;\u0026#34;); } sb.Append(\u0026#34;\u0026lt;/tr\u0026gt;\u0026#34;); } sb.Append(\u0026#34;\u0026lt;/table\u0026gt;\u0026#34;); MemoryStream stream = new MemoryStream(Encoding.UTF8.GetBytes(sb.ToString())); if (stream?.Length \u0026gt; 0) { stream.Seek(0, SeekOrigin.Begin); } FileStreamResult? result = new FileStreamResult(stream, \u0026#34;application/vnd.ms-word\u0026#34;); result.FileDownloadName = (!string.IsNullOrEmpty(fileName) ? fileName : \u0026#34;Export\u0026#34;) + \u0026#34;.doc\u0026#34;; return result; } A FileStreamResult is created with the stream. The FileDownloadName property is set to \u0026quot;Export\u0026quot;. The method returns the FileStreamResult, which will prompt the user to download the exported file.\nBlogPostController.cs The BlogPostController.cs file is a partial class that extends the ExportController class. It contains several action methods that handle the export functionality for the BlogPost entity.\nusing BlazorAppExport.Services; using Microsoft.AspNetCore.Mvc; namespace BlazorAppExport.Controllers; public partial class BlogPostController : ExportController { private BlogPostService _blogPostService; public BlogPostController(BlogPostService blogPostService) { this._blogPostService = blogPostService; } [HttpGet(\u0026#34;/export/ApplicationDb/BlogPost/csv\u0026#34;)] public async Task\u0026lt;FileStreamResult\u0026gt; ExportBlogPostToCSV() { var result = await _blogPostService.GetAllAsync(); var query = result.AsQueryable(); return ToCSV(ApplyQuery(query, Request.Query)); } [HttpGet(\u0026#34;/export/ApplicationDb/BlogPost/excel\u0026#34;)] public async Task\u0026lt;FileStreamResult\u0026gt; ExportBlogPostToExcel() { var result = await _blogPostService.GetAllAsync(); var query = result.AsQueryable(); return ToExcel(ApplyQuery(query, Request.Query)); } [HttpGet(\u0026#34;/export/ApplicationDb/BlogPost/pdf\u0026#34;)] public async Task\u0026lt;FileStreamResult\u0026gt; ExportBlogPostToPdf() { var result = await _blogPostService.GetAllAsync(); var query = result.AsQueryable(); return ToPdf(ApplyQuery(query, Request.Query)); } [HttpGet(\u0026#34;/export/ApplicationDb/BlogPost/word\u0026#34;)] public async Task\u0026lt;FileStreamResult\u0026gt; ExportBlogPostToWord() { var result = await _blogPostService.GetAllAsync(); var query = result.AsQueryable(); return ToWord(ApplyQuery(query, Request.Query)); } } The constructor of the BlogPostController class takes an instance of the BlogPostService class as a parameter. This service is responsible for retrieving the data to be exported.\nThe BlogPostController class includes the following action methods:\nExportBlogPostToCSV: This method exports the BlogPost data to a CSV file format. It retrieves the data using the GetAllAsync method of the BlogPostService class and applies any query parameters passed in the request. The ToCSV method converts the data to a CSV file and returns it as a FileStreamResult.\nExportBlogPostToExcel: This method exports the BlogPost data to an Excel file format. It follows a similar process as the ExportBlogPostToCSV method but converts the data to an Excel file using the ToExcel method.\nExportBlogPostToPdf: This method exports the BlogPost data to a PDF file format. It retrieves the data and converts it to a PDF file using the ToPdf method.\nExportBlogPostToWord: This method exports the BlogPost data to a Word file format. It retrieves the data and converts it to a Word file using the ToWord method.\nExportService.cs The ExportService class has a method called Export that takes three parameters: table, type, and query. The table parameter represents the name of the table from which the data is to be exported. The type parameter represents the file format in which the data should be exported (e.g., Word, Excel, Pdf, CSV). The query parameter is an optional parameter of type IQueryCollection that represents any additional query parameters that should be included in the export URL.\nusing Microsoft.AspNetCore.Components; namespace BlazorAppExport.Services; public class ExportService { private readonly NavigationManager navigationManager; public ExportService(NavigationManager navigationManager) { this.navigationManager = navigationManager; } // Dynamic Query public void Export(string table, string type, IQueryCollection? query = null) { var url = $\u0026#34;/export/ApplicationDb/{table}/{type}\u0026#34;; if (query is not null) { string queryString = string.Join(\u0026#34;\u0026amp;\u0026#34;, query.Select(x =\u0026gt; $\u0026#34;{x.Key}={x.Value}\u0026#34;)); url += $\u0026#34;?{queryString}\u0026#34;; } navigationManager.NavigateTo(url, true); } } In this method, we construct the export URL based on the provided table and type parameters. If the query parameter is not null, we iterate over its key-value pairs and append them to the URL as query parameters. Finally, we use the navigationManager to navigate to the generated URL, which triggers the file download.\nIndex.razor Index.razor, export buttons allow the user to export all blog posts in different file formats such as Excel, CSV, PDF, and Word.\n@page \u0026#34;/BlogPost\u0026#34; \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Index\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; \u0026lt;a href=\u0026#34;/BlogPost/Create\u0026#34;\u0026gt;Create New\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;@(args =\u0026gt; Export(\u0026#34;excel\u0026#34;))\u0026#34;\u0026gt;Export All XLS\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;@(args =\u0026gt; Export(\u0026#34;csv\u0026#34;))\u0026#34;\u0026gt;Export All CSV\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;@(args =\u0026gt; Export(\u0026#34;pdf\u0026#34;))\u0026#34;\u0026gt;Export All PDF\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;@(args =\u0026gt; Export(\u0026#34;word\u0026#34;))\u0026#34;\u0026gt;Export All DOC\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;@(args =\u0026gt; ExportCustom(\u0026#34;excel\u0026#34;))\u0026#34;\u0026gt;Export Custom Items XLS\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; @if (blogPosts == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;@nameof(BlogPostViewModel.Id)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(BlogPostViewModel.Title)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(BlogPostViewModel.Content)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var blogpost in blogPosts) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@blogpost.Id\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@blogpost.Title\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@blogpost.Content\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026#34;/BlogPost/Details/@blogpost.Id\u0026#34;\u0026gt;Details\u0026lt;/a\u0026gt; | \u0026lt;a href=\u0026#34;/BlogPost/Edit/@blogpost.Id\u0026#34;\u0026gt;Edit\u0026lt;/a\u0026gt; | \u0026lt;a href=\u0026#34;/BlogPost/Delete/@blogpost.Id\u0026#34;\u0026gt;Delete\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } @code { private IEnumerable\u0026lt;BlogPostViewModel\u0026gt;? blogPosts; protected override async Task OnInitializedAsync() { if (blogPosts == null) { var result = await BlogPostService.GetAllAsync(); blogPosts = Mapper.Map\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;, IEnumerable\u0026lt;BlogPostViewModel\u0026gt;\u0026gt;(result); } } public void Export(string type) { ExportService.Export(\u0026#34;BlogPost\u0026#34;, type); } public void ExportCustom(string type) { // Dynamic Query Dictionary\u0026lt;string, Microsoft.Extensions.Primitives.StringValues\u0026gt; queryValues = new(); //queryValues.Add(\u0026#34;$expand\u0026#34;, $\u0026#34;{nameof(BlogPost.Title)},{nameof(BlogPost.Content)}\u0026#34;); queryValues.Add(\u0026#34;$filter\u0026#34;, $\u0026#34;{nameof(BlogPost.Title)}.Contains(\\\u0026#34;Introduction\\\u0026#34;)\u0026#34;); queryValues.Add(\u0026#34;$orderBy\u0026#34;, $\u0026#34;{nameof(BlogPost.Title)} desc\u0026#34;); queryValues.Add(\u0026#34;$skip\u0026#34;, \u0026#34;1\u0026#34;); queryValues.Add(\u0026#34;$top\u0026#34;, \u0026#34;2\u0026#34;); queryValues.Add(\u0026#34;$select\u0026#34;, $\u0026#34;{nameof(BlogPost.Title)},{nameof(BlogPost.Content)}\u0026#34;); IQueryCollection query = new QueryCollection(queryValues); ExportService.Export(\u0026#34;BlogPost\u0026#34;, type, query); } } Export method, is called when the user clicks on one of the export buttons. It takes a parameter, type, which represents the file format to export (e.g., \u0026ldquo;excel\u0026rdquo;, \u0026ldquo;csv\u0026rdquo;, \u0026ldquo;pdf\u0026rdquo;, \u0026ldquo;word\u0026rdquo;). The ExportService class is responsible for exporting the data to the specified file format.\nThe ExportCustom method is called when the user clicks on the \u0026ldquo;Export Custom Items XLS\u0026rdquo; button. It demonstrates how to export a custom selection of blog posts based on specific criteria. In this example, the queryValues dictionary is used to define the query parameters such as filtering, ordering, skipping, and selecting specific fields. The ExportService class is then called to export the data to the specified file format using the query parameters.\nExporting data to different file formats can greatly enhance the usability and accessibility of your Blazor application. Whether it\u0026rsquo;s generating reports, sharing data with others, or archiving information, the ability to export data in different formats is a valuable feature to have.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppExport\n","date":"September 26, 2023","hero":"/dotnet/2023-09-26-blazor-export-data-to-word-excel-pdf-csv/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-09-26-blazor-export-data-to-word-excel-pdf-csv/","summary":"Blazor Export Data to Word, Excel, PDF, CSV We will explore how to export data to various file formats such as Word, Excel, PDF, and CSV using Blazor, a web framework for building interactive user interfaces.\nBlazor: Blazor is a web framework that allows developers to build interactive web applications using C# instead of JavaScript. It enables the creation of rich UI components and provides a seamless integration between the client and server.","tags":["Dotnet","Blazor Export Data to Word Excel PDF CSV"],"title":"Blazor Export Data to Word, Excel, PDF, CSV"},{"categories":["Dotnet","Blazor External Login","Identity Provider Google Facebook Microsoft Twitter"],"contents":" Blazor External Login Identity Provider Google, Facebook, Microsoft, Twitter we will explore how to configure external login identity providers in a Blazor application using the appsettings.json file. We will specifically focus on configuring Google, Facebook, Microsoft, and Twitter as external login providers.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nAuthentication: Authentication is the process of verifying the identity of a user. Blazor provides built-in support for authentication, allowing you to authenticate users using various identity providers.\nExternal Login Identity Providers: These are third-party services that allow users to authenticate and log in to your application using their existing credentials from platforms like Google, Facebook, Microsoft, or Twitter.\nIdentity Providers: Identity providers are third-party services that handle user authentication. Examples of identity providers include Google, Facebook, Microsoft, and Twitter. These providers allow users to log in to your application using their existing accounts.\nappsettings.json: The appsettings.json file is a configuration file used in ASP.NET Core applications to store application settings. It allows you to separate configuration from code, making it easier to manage and modify settings without redeploying the application.\nappsettings.json To configure external login identity providers in a Blazor application, you need to modify the appsettings.json file. The Authentication section of the appsettings.json file contains the configuration for each identity provider.\n\u0026#34;Authentication\u0026#34;: { \u0026#34;Google\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;ClientId\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;ClientSecret\u0026#34; }, \u0026#34;Facebook\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;ClientId\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;ClientSecret\u0026#34; }, \u0026#34;Microsoft\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;ClientId\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;ClientSecret\u0026#34; }, \u0026#34;Twitter\u0026#34;: { \u0026#34;ConsumerAPIKey\u0026#34;: \u0026#34;ConsumerAPIKey\u0026#34;, \u0026#34;ConsumerSecret\u0026#34;: \u0026#34;ConsumerSecret\u0026#34; } }, Each identity provider (Google, Facebook, Microsoft, and Twitter) is represented as a nested object within the Authentication section. Each provider has its own ClientId and ClientSecret or ConsumerAPIKey and ConsumerSecret values, which are obtained from the respective identity provider\u0026rsquo;s developer console.\nProgram.cs The AddAuthentication() method is used to configure the authentication services.\n// add external logins var config = builder.Configuration; builder.Services.AddAuthentication() .AddGoogle(options =\u0026gt; { IConfigurationSection googleAuthSection = config.GetSection(\u0026#34;Authentication:Google\u0026#34;); options.ClientId = googleAuthSection[\u0026#34;ClientId\u0026#34;]; options.ClientSecret = googleAuthSection[\u0026#34;ClientSecret\u0026#34;]; }) .AddFacebook(options =\u0026gt; { IConfigurationSection facebookAuthSection = config.GetSection(\u0026#34;Authentication:Facebook\u0026#34;); options.ClientId = facebookAuthSection[\u0026#34;ClientId\u0026#34;]; options.ClientSecret = facebookAuthSection[\u0026#34;ClientSecret\u0026#34;]; options.Scope.Add(\u0026#34;email\u0026#34;); options.Scope.Add(\u0026#34;public_profile\u0026#34;); }) .AddMicrosoftAccount(microsoftOptions =\u0026gt; { IConfigurationSection microsoftAuthSection = config.GetSection(\u0026#34;Authentication:Microsoft\u0026#34;); microsoftOptions.ClientId = microsoftAuthSection[\u0026#34;ClientId\u0026#34;]; microsoftOptions.ClientSecret = microsoftAuthSection[\u0026#34;ClientSecret\u0026#34;]; }) .AddTwitter(twitterOptions =\u0026gt; { IConfigurationSection twitterAuthSection = config.GetSection(\u0026#34;Authentication:Twitter\u0026#34;); twitterOptions.ConsumerKey = twitterAuthSection[\u0026#34;ConsumerAPIKey\u0026#34;]; twitterOptions.ConsumerSecret = twitterAuthSection[\u0026#34;ConsumerSecret\u0026#34;]; twitterOptions.RetrieveUserDetails = true; }); The AddGoogle() method adds Google as an external login provider. It retrieves the client ID and client secret from the configuration file.\nThe AddFacebook() method adds Facebook as an external login provider. It also retrieves the client ID and client secret from the configuration file. Additionally, it specifies the scopes for which the application requests access.\nThe AddMicrosoftAccount() method adds Microsoft as an external login provider. It retrieves the client ID and client secret from the configuration file.\nThe AddTwitter() method adds Twitter as an external login provider. It retrieves the consumer key and consumer secret from the configuration file. It also enables the retrieval of user details.\nExternalLogin.cshtml.cs The ExternalLogin.cshtml.cs file, which handles the logic for confirming and creating user accounts using external login providers.\npublic async Task\u0026lt;IActionResult\u0026gt; OnPostConfirmationAsync(string returnUrl = null) { returnUrl = returnUrl ?? Url.Content(\u0026#34;~/\u0026#34;); // Get the information about the user from the external login provider var info = await _signInManager.GetExternalLoginInfoAsync(); if (ModelState.IsValid) { var user = CreateUser(); // fill user info (name, givenname, surname ...) FillExternalProviderUserInfo(user, info); var result = await _userManager.CreateAsync(user); if (result.Succeeded) { result = await _userManager.AddLoginAsync(user, info); if (result.Succeeded) { _logger.LogInformation(\u0026#34;User created an account using {Name} provider.\u0026#34;, info.LoginProvider); // Add User role await _userManager.AddToRoleAsync(user, \u0026#34;User\u0026#34;); var userId = await _userManager.GetUserIdAsync(user); var code = await _userManager.GenerateEmailConfirmationTokenAsync(user); code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code)); var callbackUrl = Url.Page( \u0026#34;/Account/ConfirmEmail\u0026#34;, pageHandler: null, values: new { area = \u0026#34;Identity\u0026#34;, userId = userId, code = code }, protocol: Request.Scheme); await _emailSender.SendEmailAsync(Input.Email, \u0026#34;Confirm your email\u0026#34;, $\u0026#34;Please confirm your account by \u0026lt;a href=\u0026#39;{HtmlEncoder.Default.Encode(callbackUrl)}\u0026#39;\u0026gt;clicking here\u0026lt;/a\u0026gt;.\u0026#34;); await _signInManager.SignInAsync(user, isPersistent: false, info.LoginProvider); return LocalRedirect(returnUrl); } } } ProviderDisplayName = info.ProviderDisplayName; ReturnUrl = returnUrl; return Page(); } public static class SupportedExternalLoginProviderNames { public const string GOOGLE = \u0026#34;Google\u0026#34;; public const string FACEBOOK = \u0026#34;Facebook\u0026#34;; public const string MICROSOFT = \u0026#34;Microsoft\u0026#34;; public const string TWITTER = \u0026#34;Twitter\u0026#34;; } private void FillExternalProviderUserInfo(ApplicationUser user, ExternalLoginInfo info) { if (info is null || string.IsNullOrEmpty(info.LoginProvider)) return; switch (info.LoginProvider) { case SupportedExternalLoginProviderNames.GOOGLE: Claim gname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == ClaimTypes.Name); if (gname is not null) user.Name = gname.Value; Claim ggivenName = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == ClaimTypes.GivenName); if (ggivenName is not null) user.GivenName = ggivenName.Value; Claim gsurname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == ClaimTypes.Surname); if (gsurname is not null) user.Surname = gsurname.Value; break; case SupportedExternalLoginProviderNames.FACEBOOK: Claim fname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;urn:facebook:name\u0026#34;); if (fname is not null) user.Name = fname.Value; Claim fgivenName = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;urn:facebook:first_name\u0026#34;); if (fgivenName is not null) user.Name = fgivenName.Value; Claim fsurname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;urn:facebook:last_name\u0026#34;); if (fsurname is not null) user.Name = fsurname.Value; break; case SupportedExternalLoginProviderNames.MICROSOFT: Claim mname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;displayName\u0026#34;); if (mname is not null) user.Name = mname.Value; Claim mgivenName = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;first_name\u0026#34;); if (mgivenName is not null) user.GivenName = mgivenName.Value; Claim msurname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;last_name\u0026#34;); if (msurname is not null) user.Surname = msurname.Value; break; case SupportedExternalLoginProviderNames.TWITTER: Claim tname = info.Principal.Claims.FirstOrDefault(c =\u0026gt; c.Type == \u0026#34;screen_name\u0026#34;); if (tname is not null) user.Name = tname.Value; break; default: break; } } Configuring external login identity providers in a Blazor application is essential to provide users with the option to authenticate using their existing credentials from popular platforms like Google, Facebook, Microsoft, or Twitter. By using the appsettings.json file, you can easily configure these providers by specifying the required client IDs and client secrets.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppExternalLogin\n","date":"September 21, 2023","hero":"/dotnet/2023-09-21-blazor-external-login-identity-provider/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-09-21-blazor-external-login-identity-provider/","summary":"Blazor External Login Identity Provider Google, Facebook, Microsoft, Twitter we will explore how to configure external login identity providers in a Blazor application using the appsettings.json file. We will specifically focus on configuring Google, Facebook, Microsoft, and Twitter as external login providers.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nAuthentication: Authentication is the process of verifying the identity of a user.","tags":["Dotnet","Blazor External Login","Identity Provider Google Facebook Microsoft Twitter"],"title":"Blazor External Login Identity Provider Google, Facebook, Microsoft, Twitter"},{"categories":["Dotnet","Blazor Radzen Loading on Page"],"contents":" Blazor Radzen Loading on Page Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nRadzen: Radzen is a set of UI components for Blazor that provides ready-to-use components for building responsive and user-friendly web applications.\nLoading Indicator: A loading indicator is a visual element that indicates the progress of an ongoing operation, such as data loading or processing.\nProgressBarCircular: ProgressBarCircular is a Radzen component that displays a circular progress bar. It can be customized to show the current step number and percentage.\nLoadingIndicatorOptions.cs LoadingIndicatorOptions class is a C# code that defines the options for a loading indicator component in a Blazor application. This code provides a way to customize the behavior and appearance of the loading indicator.\nnamespace BlazorAppRadzenLoading.Components; public class LoadingIndicatorOptions { public LoadingIndicatorOptions( bool startAfterRender = true, bool showStepNumbers = false, bool showPercentage = true, int currentStep = 0, int totalSteps = 1) { StartAfterRender = startAfterRender; ShowStepNumbers = showStepNumbers; ShowPercentage = showPercentage; CurrentStep = currentStep; TotalSteps = totalSteps; } public Action? UpdateAction { get; set; } private bool startAfterRender; public bool StartAfterRender { get =\u0026gt; startAfterRender; set { startAfterRender = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private bool showStepNumbers; public bool ShowStepNumbers { get =\u0026gt; showStepNumbers; set { showStepNumbers = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private bool showPercentage; public bool ShowPercentage { get =\u0026gt; showPercentage; set { showPercentage = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private int currentStep; public int CurrentStep { get =\u0026gt; currentStep; set { currentStep = value; CurrentPercent = (int)(((float)currentStep / (float)totalSteps) * 100); if (UpdateAction is not null) UpdateAction.Invoke(); } } private int currentPercent; public int CurrentPercent { get =\u0026gt; currentPercent; set { currentPercent = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } private int totalSteps = 1; public int TotalSteps { get =\u0026gt; totalSteps; set { totalSteps = value; if (UpdateAction is not null) UpdateAction.Invoke(); } } } LoadingIndicatorOptions class: This class represents the options for the loading indicator. It contains properties and methods to control various aspects of the loading indicator, such as when to start rendering, whether to show step numbers or percentage, the current step, and the total number of steps.\nConstructor: The LoadingIndicatorOptions class has a constructor that initializes the properties of the class. It takes several optional parameters that allow you to customize the initial state of the loading indicator.\nProperties:\nStartAfterRender: A boolean property that determines whether the loading indicator should start rendering after the component has finished rendering.\nShowStepNumbers: A boolean property that determines whether to show step numbers in the loading indicator.\nShowPercentage: A boolean property that determines whether to show the percentage of completion in the loading indicator.\nCurrentStep: An integer property that represents the current step of the loading process.\nTotalSteps: An integer property that represents the total number of steps in the loading process.\nUpdateAction: An optional action delegate that is invoked whenever a property is updated. This allows you to perform additional actions when the loading indicator options change.\nProperty Setters: The properties of the LoadingIndicatorOptions class have custom setters that update the corresponding property value and invoke the UpdateAction delegate if it is not null. This ensures that any changes to the options trigger a refresh of the loading indicator.\nLoadingIndicatorRenderFragment.razor It consists of a RadzenStack component that contains a RadzenProgressBarCircular and a RadzenText component. The RadzenProgressBarCircular is used to display the loading progress, while the RadzenText component shows a loading message.\n\u0026lt;RadzenStack Orientation=\u0026#34;Orientation.Vertical\u0026#34; AlignItems=\u0026#34;AlignItems.Center\u0026#34; JustifyContent=\u0026#34;JustifyContent.Center\u0026#34; Wrap=\u0026#34;FlexWrap.Wrap\u0026#34; Class=\u0026#34;rz-m-12\u0026#34; Gap=\u0026#34;2rem\u0026#34;\u0026gt; \u0026lt;RadzenProgressBarCircular ShowValue=\u0026#34;true\u0026#34; Mode=\u0026#34;ProgressBarMode.Indeterminate\u0026#34; Size=\u0026#34;ProgressBarCircularSize.Large\u0026#34;\u0026gt; \u0026lt;Template\u0026gt; @if (Option.ShowStepNumbers) { @($\u0026#34;{Option.CurrentStep} / {Option.TotalSteps}\u0026#34;) } @if (Option.ShowPercentage) { @($\u0026#34;{Option.CurrentPercent}%\u0026#34;) } \u0026lt;/Template\u0026gt; \u0026lt;/RadzenProgressBarCircular\u0026gt; \u0026lt;RadzenText TextStyle=\u0026#34;TextStyle.H6\u0026#34;\u0026gt;Loading, please wait...\u0026lt;/RadzenText\u0026gt; \u0026lt;/RadzenStack\u0026gt; @code { [Parameter] public LoadingIndicatorOptions Option { get; set; } protected override void OnInitialized() { Option.UpdateAction = StateHasChanged; } } LoadingIndicator.razor @inject DialogService DialogService @code { [Parameter, EditorRequired] public EventCallback DoLoadDataCallback { get; set; } [Parameter, EditorRequired] public LoadingIndicatorOptions Option { get; set; } private CancellationTokenSource? cts; protected async override Task OnAfterRenderAsync(bool firstRender) { if (firstRender) if (Option.StartAfterRender) await this.Run(); } public async Task Run() { await this.ShowLoadingDialog(); await DoLoadDataCallback.InvokeAsync(); Option.CurrentStep = Option.TotalSteps; await this.HideDialog(); } private async Task ShowLoadingDialog() { cts = new CancellationTokenSource(); _ = InvokeAsync(async () =\u0026gt; await LoadingDialog()); await Task.Run(() =\u0026gt; CheckForHide(), cts.Token); } private async Task HideDialog() { if (cts is not null) cts.Cancel(); await InvokeAsync(StateHasChanged); } private async void CheckForHide() { if (cts is null) return; while (!cts.IsCancellationRequested) await Task.Delay(500); await InvokeAsync(() =\u0026gt; DialogService.Close()); } private async Task LoadingDialog() { await DialogService.OpenAsync\u0026lt;LoadingIndicatorRenderFragment\u0026gt;(\u0026#34;\u0026#34;, new Dictionary\u0026lt;string, object\u0026gt; { { \u0026#34;Option\u0026#34;, Option } }, new DialogOptions() { ShowTitle = false, Style = \u0026#34;min-height:auto;min-width:auto;width:auto\u0026#34;, CloseDialogOnEsc = false }); } } Dependency Injection: The @inject directive is used to inject the DialogService into the component. This service is provided by Radzen and allows us to interact with the dialog components.\nComponent Parameters: The component defines two parameters: DoLoadDataCallback and Option. These parameters are used to pass the necessary data and options to the component.\nLifecycle Method: The OnAfterRenderAsync method is overridden to execute code after the component has been rendered. In this method, we check if it\u0026rsquo;s the first render and if the StartAfterRender option is enabled. If so, we call the Run method.\nRun Method: The Run method is responsible for displaying the loading dialog, invoking the DoLoadDataCallback method to load the data, updating the current step, and hiding the dialog.\nShowLoadingDialog Method: This method creates a new CancellationTokenSource and invokes the LoadingDialog method asynchronously. It also starts a background task to check for cancellation and hide the dialog.\nHideDialog Method: This method cancels the CancellationTokenSource and updates the component's state to trigger a re-render.\nCheckForHide Method: This method continuously checks if the cancellation token has been requested and hides the dialog when it\u0026rsquo;s canceled.\nLoadingDialog Method: This method opens the loading indicator dialog using the DialogService. It passes the Option parameter and customizes the dialog options.\nPagewithLoading.razor Blazor page with a loading indicator component and some UI elements. It fetches data from the GitHub API and updates the page content accordingly.\n@page \u0026#34;/pagewithloading\u0026#34; @using System.Text.Json.Serialization; @using BlazorAppRadzenLoading.Models; @inject DialogService DialogService \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;!-- LOADING COMPONENT --\u0026gt; \u0026lt;BlazorAppRadzenLoading.Components.LoadingIndicator DoLoadDataCallback=\u0026#34;LoadDataAsync\u0026#34; Option=\u0026#34;options\u0026#34; /\u0026gt; \u0026lt;RadzenContent Container=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;assessment\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H1\u0026#34; style=\u0026#34;display: inline-block\u0026#34; Text=\u0026#34;Dashboard\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H2\u0026#34; Text=\u0026#34;Stats\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;badge\u0026#34; style=\u0026#34;color: #68d5c8; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Organization\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.Name\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #68d5c8; font-size: 16px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;functions\u0026#34; style=\u0026#34;color: #f9777f; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Total Repos\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.TotalPublicRepos.ToString()\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #f9777f; font-size: 24px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;thumb_up\u0026#34; style=\u0026#34;color: #ff6d41; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Total Followers\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.TotalFollowers.ToString()\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #ff6d41; font-size: 24px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-3 col-lg-6\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4 col-4\u0026#34;\u0026gt; \u0026lt;RadzenIcon Icon=\u0026#34;thumbs_up_down\u0026#34; style=\u0026#34;color: #479cc8; font-size: 48px; height: 64px; width: 100%\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-8 col-8\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H4\u0026#34; style=\u0026#34;margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;Total Followings\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #88989b; font-size: 12px; margin-bottom: 0px; text-align: right\u0026#34; /\u0026gt; \u0026lt;RadzenHeading Text=\u0026#34;@organization?.TotalFollowings.ToString()\u0026#34; Size=\u0026#34;H4\u0026#34; style=\u0026#34;color: #479cc8; font-size: 24px; margin-bottom: 0px; margin-top: 13px; text-align: right\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H2\u0026#34; Text=\u0026#34;Repo Stats (aspnetcore)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-lg-6 col-xl-4\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;RadzenChart ColorScheme=\u0026#34;ColorScheme.Pastel\u0026#34;\u0026gt; \u0026lt;RadzenColumnSeries Title=\u0026#34;Issues by Label\u0026#34; CategoryProperty=\u0026#34;@(nameof(IssueGroupbyLabel.LabelName))\u0026#34; TItem=\u0026#34;IssueGroupbyLabel\u0026#34; Data=\u0026#34;@issueGroupsbyLabel\u0026#34; ValueProperty=\u0026#34;@(nameof(IssueGroupbyLabel.Count))\u0026#34; /\u0026gt; \u0026lt;/RadzenChart\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-lg-6 col-xl-4\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;RadzenChart ColorScheme=\u0026#34;ColorScheme.Pastel\u0026#34;\u0026gt; @if (issueGroupsbyLabelandCreatedAt is not null) { @foreach (var key in issueGroupsbyLabelandCreatedAt.Keys) { IEnumerable\u0026lt;IssueGroupbyLabel\u0026gt; list = issueGroupsbyLabelandCreatedAt[key].AsEnumerable(); \u0026lt;RadzenLineSeries Title=\u0026#34;@key\u0026#34; CategoryProperty=\u0026#34;@(nameof(IssueGroupbyLabel.CreatedAtString))\u0026#34; TItem=\u0026#34;IssueGroupbyLabel\u0026#34; Data=\u0026#34;@list\u0026#34; ValueProperty=\u0026#34;@(nameof(IssueGroupbyLabel.Count))\u0026#34; /\u0026gt; } } \u0026lt;/RadzenChart\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-lg-6 col-xl-4\u0026#34;\u0026gt; \u0026lt;RadzenCard style=\u0026#34;margin-bottom: 16px\u0026#34;\u0026gt; \u0026lt;RadzenChart ColorScheme=\u0026#34;ColorScheme.Pastel\u0026#34;\u0026gt; \u0026lt;RadzenBarSeries Title=\u0026#34;Issues by Date\u0026#34; CategoryProperty=\u0026#34;@(nameof(IssueGroup.CreatedAtString))\u0026#34; TItem=\u0026#34;IssueGroup\u0026#34; Data=\u0026#34;@issueGroupsCreatedAt\u0026#34; ValueProperty=\u0026#34;@(nameof(IssueGroup.Count))\u0026#34; /\u0026gt; \u0026lt;/RadzenChart\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12\u0026#34;\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H2\u0026#34; Text=\u0026#34;Repositories\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-6\u0026#34;\u0026gt; \u0026lt;RadzenCard\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H3\u0026#34; Text=\u0026#34;Last Updated Repos\u0026#34; /\u0026gt; \u0026lt;RadzenDataGrid Data=\u0026#34;@reposLastUpdated\u0026#34; TItem=\u0026#34;Repo\u0026#34; AllowFiltering=\u0026#34;false\u0026#34; AllowColumnResize=\u0026#34;true\u0026#34; AllowAlternatingRows=\u0026#34;false\u0026#34; AllowSorting=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Columns\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Repo\u0026#34; Property=\u0026#34;@nameof(Repo.Name)\u0026#34; Title=\u0026#34;@nameof(Repo.Name)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Repo\u0026#34; Property=\u0026#34;@nameof(Repo.UpdatedAt)\u0026#34; Title=\u0026#34;@nameof(Repo.UpdatedAt)\u0026#34; /\u0026gt; \u0026lt;/Columns\u0026gt; \u0026lt;/RadzenDataGrid\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-md-12 col-xl-6\u0026#34;\u0026gt; \u0026lt;RadzenCard\u0026gt; \u0026lt;RadzenHeading Size=\u0026#34;H3\u0026#34; Text=\u0026#34;Last Issues (aspnetcore)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGrid Data=\u0026#34;@issuesLastUpdated\u0026#34; TItem=\u0026#34;Issue\u0026#34; AllowFiltering=\u0026#34;false\u0026#34; AllowColumnResize=\u0026#34;true\u0026#34; AllowAlternatingRows=\u0026#34;false\u0026#34; AllowSorting=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Columns\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Issue\u0026#34; Property=\u0026#34;@nameof(Issue.Title)\u0026#34; Title=\u0026#34;@nameof(Issue.Title)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Issue\u0026#34; Property=\u0026#34;@nameof(Issue.State)\u0026#34; Title=\u0026#34;@nameof(Issue.State)\u0026#34; /\u0026gt; \u0026lt;RadzenDataGridColumn TItem=\u0026#34;Issue\u0026#34; Property=\u0026#34;@nameof(Issue.UpdatedAt)\u0026#34; Title=\u0026#34;@nameof(Issue.UpdatedAt)\u0026#34; /\u0026gt; \u0026lt;/Columns\u0026gt; \u0026lt;/RadzenDataGrid\u0026gt; \u0026lt;/RadzenCard\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/RadzenContent\u0026gt; @code { BlazorAppRadzenLoading.Components.LoadingIndicatorOptions options = new(true, false, true, 0, 6); Organization? organization; IEnumerable\u0026lt;Repo\u0026gt;? reposLastUpdated; IEnumerable\u0026lt;IssueGroupbyLabel\u0026gt;? issueGroupsbyLabel; Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt;? issueGroupsbyLabelandCreatedAt; IEnumerable\u0026lt;Issue\u0026gt;? issuesLastUpdated; IEnumerable\u0026lt;IssueGroup\u0026gt;? issueGroupsCreatedAt; private async Task LoadDataAsync() { //Thread.Sleep(5000); // testing organization = await GetOrganization(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 1; // property updates loading component //Thread.Sleep(5000); // testing issueGroupsbyLabel = await GetIssueGroupsbyLabel(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 2; // property updates loading component //Thread.Sleep(5000); // testing issueGroupsbyLabelandCreatedAt = await GetIssueGroupsbyLabelandCreatedAt(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 3; // property updates loading component //Thread.Sleep(5000); // testing issueGroupsCreatedAt = await GetIssueGroupsCreatedAt(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 4; // property updates loading component //Thread.Sleep(5000); // testing reposLastUpdated = await GetReposLastUpdated(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 5; // property updates loading component //Thread.Sleep(5000); // testing issuesLastUpdated = await GetIssuesLastUpdated(); await InvokeAsync(StateHasChanged); // update this page options.CurrentStep = 6; // property updates loading component } private async Task\u0026lt;Organization\u0026gt; GetOrganization() { using var request = new HttpRequestMessage(HttpMethod.Get, \u0026#34;https://api.github.com/orgs/dotnet\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;Organization\u0026gt;(); if (result is not null) { return result; } } return new(); } private async Task\u0026lt;IEnumerable\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt; GetIssueGroupsbyLabel() { List\u0026lt;IssueGroupbyLabel\u0026gt; res = new List\u0026lt;IssueGroupbyLabel\u0026gt;(); using var request = new HttpRequestMessage(HttpMethod.Get, $\u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=100\u0026amp;sort=created\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); using var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null \u0026amp;\u0026amp; result.Count() \u0026gt; 0) { foreach (var item in result) { foreach (var label in item.Labels) { var cont = res.FirstOrDefault(x =\u0026gt; x.LabelName == label.Name); if (cont is null) { cont = new IssueGroupbyLabel { LabelName = label.Name, Count = 1 }; res.Add(cont); } else { cont.Count++; } } } res = res.OrderByDescending(x =\u0026gt; x.Count).Take(10).ToList(); } } return res; } private async Task\u0026lt;Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt;\u0026gt; GetIssueGroupsbyLabelandCreatedAt() { Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt; dict = new Dictionary\u0026lt;string, List\u0026lt;IssueGroupbyLabel\u0026gt;\u0026gt;(); using var request = new HttpRequestMessage(HttpMethod.Get, $\u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=100\u0026amp;sort=created\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); using var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null \u0026amp;\u0026amp; result.Count() \u0026gt; 0) { foreach (var item in result) { foreach (var label in item.Labels) { if (!dict.ContainsKey(label.Name)) dict.Add(label.Name, new List\u0026lt;IssueGroupbyLabel\u0026gt;()); var contain = dict[label.Name].FirstOrDefault(x =\u0026gt; x.LabelName == label.Name \u0026amp;\u0026amp; x.CreatedAt.Date == item.CreatedAt.Date); if (contain is not null) { contain.Count++; } else { dict[label.Name].Add(new IssueGroupbyLabel { LabelName = label.Name, CreatedAt = item.CreatedAt.Date, Count = 1 }); } } } dict = dict.OrderByDescending(x =\u0026gt; x.Value.Count).Take(5).ToDictionary(x =\u0026gt; x.Key, x =\u0026gt; x.Value); } } return dict; } private async Task\u0026lt;IEnumerable\u0026lt;IssueGroup\u0026gt;\u0026gt; GetIssueGroupsCreatedAt() { using var request = new HttpRequestMessage(HttpMethod.Get, $\u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=100\u0026amp;sort=created\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); using var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null \u0026amp;\u0026amp; result.Count() \u0026gt; 0) { return result.GroupBy(x =\u0026gt; new DateTime(x.CreatedAt.Year, x.CreatedAt.Month, x.CreatedAt.Day), x =\u0026gt; x, (key, g) =\u0026gt; new IssueGroup { CreatedAt = key, Count = g.Count() }) .Take(10); } } return new List\u0026lt;IssueGroup\u0026gt;(); } private async Task\u0026lt;IEnumerable\u0026lt;Repo\u0026gt;\u0026gt; GetReposLastUpdated() { using var request = new HttpRequestMessage(HttpMethod.Get, \u0026#34;https://api.github.com/orgs/dotnet/repos?per_page=10\u0026amp;sort=updated\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Repo\u0026gt;\u0026gt;(); if (result is not null) { return result; } } return new List\u0026lt;Repo\u0026gt;(); } private async Task\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt; GetIssuesLastUpdated() { using var request = new HttpRequestMessage(HttpMethod.Get, \u0026#34;https://api.github.com/repos/dotnet/aspnetcore/issues?per_page=10\u0026amp;sort=updated\u0026amp;order=desc\u0026#34;); using HttpClient client = new HttpClient(); client.DefaultRequestHeaders.UserAgent.ParseAdd(\u0026#34;dotnetcoding\u0026#34;); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { var result = await response.Content.ReadFromJsonAsync\u0026lt;IEnumerable\u0026lt;Issue\u0026gt;\u0026gt;(); if (result is not null) { return result; } } return new List\u0026lt;Issue\u0026gt;(); } } Loading indicator component in the Blazor page. It specifies a callback method LoadDataAsync to be executed when the loading indicator is triggered. It also passes an options object to customize the loading indicator\u0026rsquo;s behavior.\nPage with Loading Indicator is a Blazor page that demonstrates the use of a loading indicator component to show the progress of data fetching. It fetches organization data from the GitHub API and updates the page content accordingly. This code can be customized and extended to fetch and display other data as well.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenLoading\n","date":"September 10, 2023","hero":"/dotnet/2023-09-10-blazor-radzen-loading-on-page/blazor_radzen_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-09-10-blazor-radzen-loading-on-page/","summary":"Blazor Radzen Loading on Page Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nRadzen: Radzen is a set of UI components for Blazor that provides ready-to-use components for building responsive and user-friendly web applications.\nLoading Indicator: A loading indicator is a visual element that indicates the progress of an ongoing operation, such as data loading or processing.","tags":["Dotnet","Blazor Radzen Loading on Page"],"title":"Blazor Radzen Loading on Page"},{"categories":["Dotnet","Blazor Send Email with MailKit"],"contents":" Blazor Send Email with MailKit How to send emails using MailKit in a Blazor application. MailKit is a cross-platform .NET library that provides a simple and efficient way to send and receive emails. We will create a class called EmailConfiguration to store the email server configuration settings.\nMailKit: MailKit is an open-source .NET library that provides a high-level API for sending and receiving emails using various protocols such as SMTP, POP3, and IMAP.\nSMTP: Simple Mail Transfer Protocol (SMTP) is a standard protocol used for sending emails over the internet. It is responsible for transferring the email from the sender\u0026rsquo;s mail server to the recipient\u0026rsquo;s mail server.\nBlazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code that runs on the client-side in the browser.\nethereal.email: https://ethereal.email/ is a service that allows developers to test email functionality in web applications by providing temporary email addresses and capturing the sent emails for inspection on their website. It is a useful tool for ensuring the proper functioning of email features without the need for real email accounts.\nEmailConfiguration.cs A class called EmailConfiguration that represents the email server configuration settings. It has the following properties:\nnamespace BlazorAppSendEmailwithMailKit.Data; public class EmailConfiguration { public string Host { get; set; } = string.Empty; public int Port { get; set; } public string Username { get; set; } = string.Empty; public string Password { get; set; } = string.Empty; public string From { get; set; } = string.Empty; public string Name { get; set; } = string.Empty; public bool EnableSSL { get; set; } } Host: The hostname or IP address of the email server.\nPort: The port number to connect to the email server.\nUsername: The username to authenticate with the email server.\nPassword: The password to authenticate with the email server.\nFrom: The email address from which the email will be sent.\nName: The name associated with the email address.\nEnableSSL: A boolean value indicating whether to use SSL/TLS encryption for the connection.\nEmailMessage.cs EmailMessage class is defined within the BlazorAppSendEmailwithMailKit.Data namespace. It contains three properties: Email, Subject, and Message.\nusing System.ComponentModel.DataAnnotations; namespace BlazorAppSendEmailwithMailKit.Data; public class EmailMessage { [EmailAddress] public string Email { get; set; } = string.Empty; [Required] public string Subject { get; set; } = string.Empty; [Required] public string Message { get; set; } = string.Empty; } IEmailSender.cs We define an interface called IEmailSender with a single method SendEmailAsync. This method takes three parameters: email (the recipient's email address), subject (the subject of the email), and htmlMessage (the HTML content of the email).\nnamespace BlazorAppSendEmailwithMailKit.Data; public interface IEmailSender { Task SendEmailAsync(string email, string subject, string htmlMessage); } This interface will serve as the contract for sending emails.\nEmailSenderMailKit.cs The EmailSenderMailKit class implements the IEmailSender interface, which requires the implementation of the SendEmailAsync method. This method takes the recipient's email address, subject, and HTML message as parameters.\nusing MailKit.Net.Smtp; using Microsoft.Extensions.Options; using MimeKit; using MimeKit.Text; namespace BlazorAppSendEmailwithMailKit.Data; public class EmailSenderMailKit : IEmailSender { private readonly EmailConfiguration _emailConfiguration; public EmailSenderMailKit(IOptions\u0026lt;EmailConfiguration\u0026gt; emailConfiguration) { this._emailConfiguration = emailConfiguration.Value; } public Task SendEmailAsync(string email, string subject, string htmlMessage) { return Execute(email, subject, htmlMessage); } private async Task Execute(string to, string subject, string htmlMessage) { string host = _emailConfiguration.Host; int port = _emailConfiguration.Port; string username = _emailConfiguration.Username; string password = _emailConfiguration.Password; string from = _emailConfiguration.From; string name = _emailConfiguration.Name; bool enableSsl = _emailConfiguration.EnableSSL; var email = new MimeMessage(); var sender = MailboxAddress.Parse(from); if (!string.IsNullOrEmpty(name)) sender.Name = name; email.Sender = sender; email.From.Add(sender); email.To.Add(MailboxAddress.Parse(to)); email.Subject = subject; email.Body = new TextPart(TextFormat.Html) { Text = htmlMessage }; using (var smtp = new SmtpClient()) { smtp.Timeout = 10000; // 10secs try { await smtp.ConnectAsync(host, port, enableSsl); if (!string.IsNullOrEmpty(username)) smtp.Authenticate(username, password); await smtp.SendAsync(email); await smtp.DisconnectAsync(true); } catch (Exception ex) { throw; } } } } The EmailSenderMailKit class also has a constructor that accepts an instance of IOptions\u0026lt;EmailConfiguration\u0026gt;. This allows us to retrieve the email server configuration settings from the appsettings.json file or any other configuration source.\nInside the Execute method, we retrieve the email server configuration settings from the _emailConfiguration object. We then create a new MimeMessage object and set the sender, recipient, subject, and body of the email.\nNext, we create an instance of SmtpClient and set its timeout to 10 seconds. We then connect to the email server using the ConnectAsync method, authenticate if a username and password are provided, send the email using the SendAsync method, and finally disconnect from the server using the DisconnectAsync method.\nappsettings.json appsettings.json file is a configuration file used in ASP.NET Core applications to store application settings. It follows a JSON format and can be used to store various settings, including email configuration.\n{ \u0026#34;Email\u0026#34;: { \u0026#34;Host\u0026#34;: \u0026#34;HOST_ADDRESS\u0026#34;, \u0026#34;Port\u0026#34;: 587, \u0026#34;Username\u0026#34;: \u0026#34;USERNAME\u0026#34;, \u0026#34;Password\u0026#34;: \u0026#34;PASSWORD\u0026#34;, \u0026#34;From\u0026#34;: \u0026#34;FROM_EMAIL\u0026#34;, \u0026#34;Name\u0026#34;: \u0026#34;FROM_NAME\u0026#34;, \u0026#34;EnableSSL\u0026#34;: true }, \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } Email: This section contains the email configuration settings such as the host address, port number, username, password, from email address, from name, and whether to enable SSL.\nProgram.cs In the program.cs file sets up the email sending functionality using MailKit in a Blazor application. Let\u0026rsquo;s break down the code and understand its structure:\n// Add services to the container. builder.Services.AddTransient\u0026lt;IEmailSender, EmailSenderMailKit\u0026gt;(); builder.Services.Configure\u0026lt;EmailConfiguration\u0026gt;(options =\u0026gt; { builder.Configuration.GetSection(\u0026#34;Email\u0026#34;).Bind(options); }); The builder.Services.AddTransient\u0026lt;IEmailSender, EmailSenderMailKit\u0026gt;() line registers the EmailSenderMailKit class as the implementation for the IEmailSender interface. This allows us to inject the IEmailSender interface wherever we need to send emails.\nThe builder.Services.Configure\u0026lt;EmailConfiguration\u0026gt;(options =\u0026gt; { ... }) line configures the EmailConfiguration class by binding the configuration settings from the appsettings.json file. This allows us to retrieve the email configuration settings easily.\nSendEmail.razor Blazor component named SendEmail.razor. It allows users to enter an email address, subject, and message, and then sends the email using the IEmailSender service.\n@page \u0026#34;/sendemail\u0026#34; @using BlazorAppSendEmailwithMailKit.Data @inject IEmailSender EmailSender \u0026lt;PageTitle\u0026gt;Send Email\u0026lt;/PageTitle\u0026gt; @if (emailMessage is null) { \u0026lt;p\u0026gt;Loading...\u0026lt;/p\u0026gt; } else { \u0026lt;EditForm Model=@emailMessage OnValidSubmit=@ValidFormSubmitted\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;p\u0026gt;Send Email\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;email\u0026#34;\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=emailMessage.Email class=\u0026#34;form-control\u0026#34; id=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; emailMessage.Email\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;subject\u0026#34;\u0026gt;Subject\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=emailMessage.Subject class=\u0026#34;form-control\u0026#34; id=\u0026#34;subject\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; emailMessage.Subject\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;message\u0026#34;\u0026gt;Message\u0026lt;/label\u0026gt; \u0026lt;InputTextArea @bind-Value=emailMessage.Message class=\u0026#34;form-control\u0026#34; id=\u0026#34;message\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;() =\u0026gt; emailMessage.Message\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; value=\u0026#34;Send\u0026#34; /\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;result\u0026#34;\u0026gt;Result:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=@result readonly class=\u0026#34;form-control\u0026#34; id=\u0026#34;result\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } @code { private string result = string.Empty; private EmailMessage? emailMessage; protected override void OnInitialized() { emailMessage = new(); } private async Task ValidFormSubmitted() { if (emailMessage is null) return; try { result = \u0026#34;sending...\u0026#34;; await EmailSender.SendEmailAsync(emailMessage.Email, emailMessage.Subject, emailMessage.Message); result = \u0026#34;success\u0026#34;; } catch (Exception ex) { result = ex.Message; } } } The code is structured as follows:\nPage Directive: The @page directive specifies the URL route for the component.\nUsing Directive: The @using directive imports the necessary namespaces for the component.\nDependency Injection: The @inject directive injects the IEmailSender service into the component.\nPageTitle: The PageTitle component sets the page title.\nConditional Rendering: The code uses conditional rendering to display a loading message while the email message is being loaded, and the email form once the message is loaded.\nEditForm: The EditForm component wraps the email form and handles form submission and validation.\nDataAnnotationsValidator: The DataAnnotationsValidator component performs validation based on data annotations applied to the EmailMessage model.\nValidationSummary: The ValidationSummary component displays a summary of validation errors.\nForm Fields: The code defines form fields for email, subject, and message using Blazor's InputText and InputTextArea components. It also includes validation messages for each field.\nSubmit Button: The code includes a submit button that triggers the ValidFormSubmitted method when clicked.\nResult Display: The code displays the result of the email sending operation.\nCode Block: The @code block contains the C# code for the component. It initializes the result variable, handles form submission, and sends the email using the EmailSender service.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppSendEmailwithMailKit\n","date":"September 3, 2023","hero":"/dotnet/2023-09-03-blazor-send-email-with-mailkit/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-09-03-blazor-send-email-with-mailkit/","summary":"Blazor Send Email with MailKit How to send emails using MailKit in a Blazor application. MailKit is a cross-platform .NET library that provides a simple and efficient way to send and receive emails. We will create a class called EmailConfiguration to store the email server configuration settings.\nMailKit: MailKit is an open-source .NET library that provides a high-level API for sending and receiving emails using various protocols such as SMTP, POP3, and IMAP.","tags":["Dotnet","Blazor Send Email with MailKit"],"title":"Blazor Send Email with MailKit"},{"categories":["Dotnet","Blazor Redis as Backplane"],"contents":" Blazor Redis as Backplane (with Master and Slave) Blazor: Blazor is a web framework developed by Microsoft that allows developers to build interactive web applications using C# instead of JavaScript. It enables the creation of single-page applications (SPAs) that run entirely in the browser.\nRedis: Redis is an open-source, in-memory data structure store that can be used as a database, cache, and message broker. It provides high-performance data storage and retrieval, making it suitable for use in applications that require fast and scalable data access.\nRedis as Backplane: In the context of a web application, a backplane is a communication channel that allows multiple instances of the application to synchronize and share data. Redis can be used as a backplane to enable real-time communication and data sharing between different instances of a Blazor application.\nServiceStack.Redis: ServiceStack.Redis is a high-performance, feature-rich Redis client library for .NET. It provides a simple and intuitive API for interacting with Redis servers and supports advanced features such as connection pooling, pipelining, and pub/sub.\nStackExchange.Redis: StackExchange.Redis is another popular Redis client library for .NET. It is widely used and offers a high-performance, low-level API for interacting with Redis servers. It supports advanced features such as distributed locks, Lua scripting, and Redis Cluster.\nPrerequisites Redis Server Files and Master-Slave Configurations: https://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppwithRedis/RedisServerFiles\nDownload and Run RUN_SERVERS.bat\nif not exist \u0026#34;Redis-x64-3.0.504_master\u0026#34; ( mkdir \u0026#34;Redis-x64-3.0.504_master\u0026#34; tar -xf Redis-x64-3.0.504.zip -C \u0026#34;Redis-x64-3.0.504_master\u0026#34; ) if not exist \u0026#34;Redis-x64-3.0.504_slave\u0026#34; ( mkdir \u0026#34;Redis-x64-3.0.504_slave\u0026#34; tar -xf Redis-x64-3.0.504.zip -C \u0026#34;Redis-x64-3.0.504_slave\u0026#34; ) start \u0026#34;Start RedisMaster\u0026#34; Redis-x64-3.0.504_master\\redis-server.exe redis.windows.master.conf start \u0026#34;Start RedisSlave\u0026#34; Redis-x64-3.0.504_slave\\redis-server.exe redis.windows.slave.conf Now, Redis Master-Slave Servers are ready. MASTER 127.0.0.1:6379 slave 127.0.0.1:6380 ConfigurationManager.cs The ConfigurationManager class is defined as a static class, meaning it cannot be instantiated. It contains a single static property called AppSetting, which represents the application\u0026rsquo;s configuration settings.\nThe AppSetting property is of type IConfiguration, which is an interface that provides access to configuration settings. This property is read-only, meaning it can only be accessed but not modified.\nThe class also has a static constructor, denoted by the static ConfigurationManager() syntax. This constructor is automatically called when the class is accessed for the first time and is used to initialize the AppSetting property.\nnamespace BlazorAppwithRedis; public static class ConfigurationManager { public static IConfiguration AppSetting { get; } static ConfigurationManager() { AppSetting = new ConfigurationBuilder().SetBasePath(Directory.GetCurrentDirectory()).AddJsonFile(\u0026#34;appsettings.json\u0026#34;).Build(); } } ConnectionHelper.cs The ConnectionHelper class is declared as a public class. Three private static fields are defined to store the Redis clients and manager: _clientsManager, _redisClientMaster, and _redisClientSlave.\nA static constructor is defined to initialize the Redis connection. It is executed only once when the class is first accessed. Inside the static constructor, the Redis clients manager is initialized with the Redis server URLs obtained from the configuration. The Redis client instances for master and slave are obtained from the clients manager. The lazy connection is initialized using a lambda expression that creates a connection string from the Redis server URLs and connects to the Redis server using ConnectionMultiplexer.\nThe lazyConnection field is declared as a Lazy\u0026lt;ConnectionMultiplexer\u0026gt; to ensure lazy initialization of the Redis connection. A public static property Connection is defined to provide access to the Redis connection. The Connection property returns the value of the lazyConnection field. A public static method GetServers() is defined to get the Redis servers from the connection.\nusing ServiceStack.Redis; using StackExchange.Redis; namespace BlazorAppwithRedis; public class ConnectionHelper { private static readonly IRedisClientsManager _clientsManager; private static readonly IRedisClient _redisClientMaster; private static readonly IRedisClient _redisClientSlave; static ConnectionHelper() { _clientsManager = new PooledRedisClientManager(ConfigurationManager.AppSetting[\u0026#34;RedisURLMaster\u0026#34;], ConfigurationManager.AppSetting[\u0026#34;RedisURLSlave\u0026#34;]); _redisClientMaster = _clientsManager.GetClient(); _redisClientSlave = _clientsManager.GetReadOnlyClient(); ConnectionHelper.lazyConnection = new Lazy\u0026lt;ConnectionMultiplexer\u0026gt;(() =\u0026gt; { string urls = $\u0026#34;{ConfigurationManager.AppSetting[\u0026#34;RedisURLMaster\u0026#34;]},{ConfigurationManager.AppSetting[\u0026#34;RedisURLSlave\u0026#34;]},allowAdmin=true\u0026#34;; return ConnectionMultiplexer.Connect(urls); }); } private static Lazy\u0026lt;ConnectionMultiplexer\u0026gt; lazyConnection; public static ConnectionMultiplexer Connection { get { return lazyConnection.Value; } } public static IEnumerable\u0026lt;IServer\u0026gt; GetServers() { return Connection.GetServers(); } } ICacheService.cs ICacheService in the BlazorAppwithRedis.Cache namespace. This interface defines a set of methods that can be used to interact with a cache service.\nGetConnectionState(): This method returns the connection state of the cache service. It returns a tuple containing the connection state (ConnectionStates) and a message (string) indicating the current state of the connection.\nGetTTL(string key): This method returns the time-to-live (TTL) of a cached item specified by the key. The TTL represents the remaining time until the item expires and is automatically removed from the cache. It returns a TimeSpan object representing the remaining time.\nGetDataMaster(string key): This method retrieves data from the cache using the key. It returns the cached data of type T if it exists, or null if the data is not found.\nGetDataSlave(string key): This method retrieves data from a slave cache using the key. It is similar to GetDataMaster, but it retrieves data from a read-only replica of the cache.\nSetDataMaster(string key, T value, DateTimeOffset expirationTime): This method sets data in the cache using the key, value, and expirationTime. It stores the data in the master cache and specifies the expiration time for the data.\nRemoveDataMaster(string key): This method removes data from the cache using the key. It deletes the data from the master cache.\nnamespace BlazorAppwithRedis.Cache; public interface ICacheService { (ConnectionStates ConnectionState, string Message) GetConnectionState(); TimeSpan? GetTTL(string key); T? GetDataMaster\u0026lt;T\u0026gt;(string key); T? GetDataSlave\u0026lt;T\u0026gt;(string key); bool? SetDataMaster\u0026lt;T\u0026gt;(string key, T value, DateTimeOffset expirationTime); object? RemoveDataMaster(string key); } CacheService.cs It implements the ICacheService interface, which defines the contract for interacting with the cache.\nprivate IDatabase? _db: A private field that holds the reference to the Redis database. private ConnectionStates _connectionState: An enumeration that represents the current connection state of the cache service. private string _currentConnectionStatusMessage: A string that stores the current connection status message.\nThe class also has a constructor that initializes the cache service by establishing a connection to Redis. If the connection is successful, the connection state is set to Connected, and the current connection status message is set to \u0026ldquo;Connected.\u0026rdquo; If an exception occurs during the connection process, the connection state is set to NoConnection, and the current connection status message is set to the error message.\nusing StackExchange.Redis; using System.Text.Json; namespace BlazorAppwithRedis.Cache; public enum ConnectionStates { Unknown = 0, Connected = 1, NoConnection = 2, } public class CacheService : ICacheService { private IDatabase? _db; private ConnectionStates _connectionState = ConnectionStates.Unknown; private string _currentConnectionStatusMessage; public CacheService() { try { _db = ConnectionHelper.Connection.GetDatabase(0); _connectionState = ConnectionStates.Connected; _currentConnectionStatusMessage = \u0026#34;Connected.\u0026#34;; } catch (Exception ex) { _connectionState = ConnectionStates.NoConnection; string errorMessage = ex.Message; var innerEx = ex.InnerException; while (innerEx != null) { errorMessage += Environment.NewLine + innerEx.Message; innerEx = innerEx.InnerException; } _currentConnectionStatusMessage = errorMessage; } } public (ConnectionStates ConnectionState, string Message) GetConnectionState() =\u0026gt; (_connectionState, _currentConnectionStatusMessage); public TimeSpan? GetTTL(string key) { if (_connectionState != ConnectionStates.Connected) return null; var value = _db.KeyTimeToLive(key, CommandFlags.PreferMaster); if (value != null) { return value; } return default; } public T? GetDataMaster\u0026lt;T\u0026gt;(string key) { if (_connectionState != ConnectionStates.Connected) return default; var value = _db.StringGet(key, CommandFlags.PreferMaster); if (!string.IsNullOrEmpty(value)) { return JsonSerializer.Deserialize\u0026lt;T\u0026gt;(value!); } return default; } public T? GetDataSlave\u0026lt;T\u0026gt;(string key) { if (_connectionState != ConnectionStates.Connected) return default; var value = _db.StringGet(key, CommandFlags.PreferReplica); if (!string.IsNullOrEmpty(value)) { return JsonSerializer.Deserialize\u0026lt;T\u0026gt;(value!); } return default; } public bool? SetDataMaster\u0026lt;T\u0026gt;(string key, T value, DateTimeOffset expirationTime) { if (_connectionState != ConnectionStates.Connected) return default; TimeSpan expiryTime = expirationTime.DateTime.Subtract(DateTime.Now); var isSet = _db.StringSet(key, JsonSerializer.Serialize(value), expiryTime, flags: CommandFlags.PreferMaster); return isSet; } public object? RemoveDataMaster(string key) { if (_connectionState != ConnectionStates.Connected) return null; bool _isKeyExist = _db.KeyExists(key); if (_isKeyExist == true) { return _db.KeyDelete(key, CommandFlags.PreferMaster); } return false; } } GetConnectionState(): Returns the current connection state and status message of the cache service.\nGetTTL(string key): Retrieves the time-to-live (TTL) of a cache key, which represents the remaining time until the key expires.\nGetDataMaster(string key): Retrieves data from the cache using the specified key, preferring the master node in a Redis cluster.\nGetDataSlave(string key): Retrieves data from the cache using the specified key, preferring a replica node in a Redis cluster.\nSetDataMaster(string key, T value, DateTimeOffset expirationTime): Stores data in the cache using the specified key, with an optional expiration time.\nRemoveDataMaster(string key): Removes data from the cache using the specified key, preferring the master node in a Redis cluster.\nappsettings.json { \u0026#34;RedisURLMaster\u0026#34;: \u0026#34;127.0.0.1:6379\u0026#34;, \u0026#34;RedisURLSlave\u0026#34;: \u0026#34;127.0.0.1:6380\u0026#34;, \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } The above code snippet shows two key settings related to Redis: RedisURLMaster and RedisURLSlave. These settings define the URLs of the Redis instances that will be used as the master and slave nodes in a Redis cluster.\nBlogPostService.cs BlogPostService class is structured as follows:\nIt imports the necessary namespaces for the cache, data, and models. It defines the class and its dependencies, including the ApplicationDbContext and ICacheService. It initializes the class with the required dependencies through the constructor. It provides methods for retrieving, creating, updating, and deleting blog posts. It includes a private method for setting the blog post data in the cache.\nusing BlazorAppwithRedis.Cache; using BlazorAppwithRedis.Data; using BlazorAppwithRedis.Models; using Microsoft.EntityFrameworkCore; namespace BlazorAppwithRedis.Services; public class BlogPostService { private readonly ApplicationDbContext _context; private readonly ICacheService _cacheService; private static object _lock = new object(); public BlogPostService(ApplicationDbContext context, ICacheService cacheService) { _context = context; _cacheService = cacheService; } public async Task\u0026lt;(BlogPost? Data, string From)\u0026gt; GetbyIdAsync(int id) { BlogPost? filteredData; var data = _cacheService.GetDataSlave\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt;(\u0026#34;blogpost\u0026#34;); if (data is not null) { filteredData = data.Where(x =\u0026gt; x.Id == id).FirstOrDefault(); return (Data: filteredData, From: \u0026#34;cache\u0026#34;); } data = await SetBlogPostData(); filteredData = data.Where(x =\u0026gt; x.Id == id).FirstOrDefault(); return (Data: filteredData, From: \u0026#34;database\u0026#34;); } public async Task\u0026lt;(IEnumerable\u0026lt;BlogPost\u0026gt; Data, string From)\u0026gt; GetAllAsync() { var data = _cacheService.GetDataSlave\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt;(\u0026#34;blogpost\u0026#34;); if (data is not null) return (Data: data, From: \u0026#34;cache\u0026#34;); data = await SetBlogPostData(); return (Data: data, From: \u0026#34;database\u0026#34;); } public async Task\u0026lt;bool\u0026gt; AddBlogPostAsync(BlogPost blogPost) { try { var result = await _context.BlogPosts.AddAsync(blogPost); await _context.SaveChangesAsync(); _cacheService.RemoveDataMaster(\u0026#34;blogpost\u0026#34;); await SetBlogPostData(); } catch (Exception ex) { return false; } return true; } public async Task\u0026lt;bool\u0026gt; UpdateBlogPostAsync(int id, BlogPost blogPost) { try { var oldBlogPost = await _context.BlogPosts.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); if (oldBlogPost == null) return false; oldBlogPost.Title = blogPost.Title; oldBlogPost.Content = blogPost.Content; await _context.SaveChangesAsync(); _cacheService.RemoveDataMaster(\u0026#34;blogpost\u0026#34;); await SetBlogPostData(); } catch (Exception ex) { return false; } return true; } public async Task\u0026lt;bool\u0026gt; DeletebyIdAsync(int id) { try { var blogPost = await _context.BlogPosts.FirstOrDefaultAsync(x =\u0026gt; x.Id == id); if (blogPost is null) return false; _context.BlogPosts.Remove(blogPost); await _context.SaveChangesAsync(); _cacheService.RemoveDataMaster(\u0026#34;blogpost\u0026#34;); await SetBlogPostData(); } catch (Exception ex) { return false; } return true; } private async Task\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt; SetBlogPostData() { var expirationTime = DateTimeOffset.Now.AddMinutes(5.0); var data = await _context.BlogPosts.ToListAsync(); lock (_lock) { _cacheService.SetDataMaster\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;\u0026gt;(\u0026#34;blogpost\u0026#34;, data, expirationTime); } return data; } } Source Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppwithRedis\n","date":"August 30, 2023","hero":"/dotnet/2023-08-30-blazor-redis-as-backplane/blazor_dotnet_redis.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-30-blazor-redis-as-backplane/","summary":"Blazor Redis as Backplane (with Master and Slave) Blazor: Blazor is a web framework developed by Microsoft that allows developers to build interactive web applications using C# instead of JavaScript. It enables the creation of single-page applications (SPAs) that run entirely in the browser.\nRedis: Redis is an open-source, in-memory data structure store that can be used as a database, cache, and message broker. It provides high-performance data storage and retrieval, making it suitable for use in applications that require fast and scalable data access.","tags":["Dotnet","Blazor Redis as Backplane"],"title":"Blazor Redis as Backplane"},{"categories":["Dotnet","Blazor Resize and Upload Images"],"contents":" Blazor Resize and Upload Images Upload and save images in a Blazor application using C#. We will cover the process of uploading an image, resizing it if necessary, generating a random file name, and saving it to the server\u0026rsquo;s wwwroot directory.\nInputFile: The InputFile component in Blazor allows users to select files from their local system. It triggers an event when the file selection changes.\nFile Size Limit: We can set a maximum file size limit to restrict the size of the uploaded image. In our example, we have set the limit to 800KB.\nImage Resizing: We can resize the uploaded image to a specific width and height if needed. In our code, we have commented out the image resizing logic, but you can uncomment it and modify it according to your requirements.\nRandom File Name: To avoid naming conflicts, we generate a random file name for the uploaded image. We use the Guid.NewGuid().ToString(\u0026quot;N\u0026quot;) method to generate a unique identifier and combine it with the file extension.\nSaving to wwwroot: We save the uploaded image to the wwwroot directory of the Blazor application. This allows us to access the image using a relative path in the application.\nCreate.razor Blazor component that handles the creation of a blog post. It includes an EditForm component that binds to a BlogPostViewModel object.\nHTML Markup: The HTML markup defines the form elements for creating a blog post. It includes an InputFile component for selecting the image, a preview section to display the selected image, and a submit button.\nCode-behind: The code-behind section contains the C# logic for handling the image upload and saving process. It includes event handlers for the OnChange event of the InputFile component and the submit button\u0026rsquo;s OnValidSubmit event.\n@page \u0026#34;/BlogPost/Create\u0026#34; \u0026lt;PageTitle\u0026gt;Create\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Create\u0026lt;/h1\u0026gt; \u0026lt;h4\u0026gt;BlogPost\u0026lt;/h4\u0026gt; \u0026lt;hr /\u0026gt; @if (blogPost == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-4\u0026#34;\u0026gt; \u0026lt;EditForm Model=\u0026#34;@blogPost\u0026#34; OnValidSubmit=\u0026#34;@HandleValidSubmit\u0026#34; Context=\u0026#34;createBlogPost\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;Preview\u0026lt;/label\u0026gt; @if (blogPost is not null \u0026amp;\u0026amp; !string.IsNullOrEmpty(blogPost.PostImage)) { \u0026lt;div class=\u0026#34;form-control\u0026#34;\u0026gt; @*\u0026lt;img src=\u0026#34;data:@selectedImage.ContentType;base64,@selectedImage.Base64data\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt;*@ \u0026lt;img src=\u0026#34;/images/@blogPost.PostImage\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.PostImage)\u0026lt;/label\u0026gt; \u0026lt;InputFile OnChange=\u0026#34;OnChange\u0026#34; id=\u0026#34;upload\u0026#34; class=\u0026#34;form-control\u0026#34; accept=\u0026#34;image/png, image/jpeg\u0026#34; /\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPost.PostImage\u0026#34; readonly class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;p class=\u0026#34;text-muted mb-0\u0026#34;\u0026gt;Allowed JPG, GIF or PNG. Max size of 800K (1024x1024 pixels)\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Title)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPost.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPost.Title)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Content)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPost.Content\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPost.Content)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Create\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;a href=\u0026#34;/BlogPost\u0026#34;\u0026gt;Back to List\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; } @code { private BlogPostViewModel? blogPost; protected override void OnInitialized() { blogPost = new(); } async Task OnChange(InputFileChangeEventArgs e) { if (blogPost is null) return; var files = e.GetMultipleFiles(); if (files.Count \u0026gt; 0) { var file = files[0]; if (file.Size \u0026gt; (1024 * 800)) // MAX FILE SIZE: \u0026lt; 800KB return; // resize image //var resizedFile = await file.RequestImageFileAsync(file.ContentType, 1024, 1024); // resize the image file var resizedFile = file; //generate random imagename string imagename = Guid.NewGuid().ToString(\u0026#34;N\u0026#34;) + Path.GetExtension(file.Name); // save image to directory string imagePath = Path.Combine(System.Environment.CurrentDirectory, \u0026#34;wwwroot\u0026#34;, \u0026#34;images\u0026#34;); string imageFullName = Path.Combine(imagePath, imagename); await using FileStream fs = new(imageFullName, FileMode.Create); await resizedFile.OpenReadStream().CopyToAsync(fs); //await File.WriteAllBytesAsync(imageFullName, selectedImage.Data); blogPost.PostImage = imagename; StateHasChanged(); } } private async void HandleValidSubmit() { if (blogPost is null) return; var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.AddBlogPostAsync(model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } } We explored how to upload and save images in a Blazor application using C#. We covered the key concepts of image uploading, resizing, generating random file names, and saving images to the wwwroot directory. By following the code examples provided, you can implement image uploading functionality in your own Blazor projects.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppResizeUploadImages\n","date":"August 25, 2023","hero":"/dotnet/2023-08-25-blazor-resize-and-upload-images/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-25-blazor-resize-and-upload-images/","summary":"Blazor Resize and Upload Images Upload and save images in a Blazor application using C#. We will cover the process of uploading an image, resizing it if necessary, generating a random file name, and saving it to the server\u0026rsquo;s wwwroot directory.\nInputFile: The InputFile component in Blazor allows users to select files from their local system. It triggers an event when the file selection changes.\nFile Size Limit: We can set a maximum file size limit to restrict the size of the uploaded image.","tags":["Dotnet","Blazor Resize and Upload Images"],"title":"Blazor Resize and Upload Images"},{"categories":["Dotnet","Blazor Scheduling with Quartz.NET"],"contents":" Blazor Scheduling with Quartz.NET Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nQuartz.NET: Quartz.NET is a popular open-source job scheduling library for .NET applications. It provides a flexible and powerful way to schedule and execute jobs at specified intervals.\nScheduling: Scheduling refers to the process of defining when and how often a job or task should be executed. In this code, we use Quartz.NET to schedule jobs to be executed at specific times or intervals.\nJobs: In the context of this application, a job refers to a specific task or action that needs to be executed at a scheduled time or interval. Jobs can be created, paused, resumed, and deleted.\nTriggers: Triggers are used to define when and how often a job should be executed. They specify the schedule, start time, end time, and other parameters for a job.\nJob Class: A job class in Quartz.NET represents a unit of work that needs to be executed by the scheduler. It implements the IJob interface and defines the logic to be executed when the job is triggered.\nAddRandomBlogPostJob.cs The AddRandomBlogPostJob class is defined in the BlazorAppQuartzNETScheduler.Jobs namespace. It implements the IJob interface provided by Quartz.NET. The class is marked with the [DisallowConcurrentExecution] attribute, which ensures that the job will not be executed concurrently.\nusing BlazorAppQuartzNETScheduler.Data; using BlazorAppQuartzNETScheduler.Models; using BlazorAppQuartzNETScheduler.Services; using Quartz; namespace BlazorAppQuartzNETScheduler.Jobs; [DisallowConcurrentExecution] public class AddRandomBlogPostJob : IJob { private readonly ILogger\u0026lt;AddRandomBlogPostJob\u0026gt; _logger; private readonly BlogPostService _blogPostService; public AddRandomBlogPostJob(ILogger\u0026lt;AddRandomBlogPostJob\u0026gt; logger, BlogPostService blogPostService) { _logger = logger; _blogPostService = blogPostService; } public async Task Execute(IJobExecutionContext context) { BlogPost model = SeedData.GetRandomPost(); await _blogPostService.AddBlogPostAsync(model); } } The class has two dependencies injected through its constructor: ILogger\u0026lt;AddRandomBlogPostJob\u0026gt; and BlogPostService. The ILogger is used for logging purposes, while the BlogPostService is a service responsible for adding blog posts to the application.\nThe Execute method is the main entry point for the job execution. It is called by the Quartz.NET scheduler when the job is triggered. Inside the Execute method, a random blog post model is obtained using the SeedData.GetRandomPost() method. Then, the AddBlogPostAsync method of the BlogPostService is called to add the blog post to the application.\nProgram.cs Setting up the Quartz database:\nstring quartzConnectionString = builder.Configuration.GetConnectionString(\u0026#34;QuartzConnectionString\u0026#34;); SqliteConnectionStringBuilder quartzSqliteConnectionStringBuilder = new SqliteConnectionStringBuilder( quartzConnectionString); CheckandCreateQuartzDatabase(quartzSqliteConnectionStringBuilder).GetAwaiter().GetResult(); We retrieve the connection string for the Quartz database from the application\u0026rsquo;s configuration. We then create a SqliteConnectionStringBuilder object using the connection string and pass it to the CheckandCreateQuartzDatabase method to check and create the Quartz database if necessary.\nAdding Quartz services:\nbuilder.Services.AddDbContext\u0026lt;QuartzDbContext\u0026gt;(options =\u0026gt; { options.UseSqlite(quartzConnectionString); }); builder.Services.AddQuartz(q =\u0026gt; { q.UsePersistentStore(per =\u0026gt; { per.UseSQLite(quartzSqliteConnectionStringBuilder.ConnectionString); per.UseJsonSerializer(); }); q.UseMicrosoftDependencyInjectionJobFactory(); }); builder.Services.AddQuartzHostedService(opt =\u0026gt; { opt.WaitForJobsToComplete = true; }); We add the necessary Quartz services to the application's service collection. We configure the Quartz database context using the SQLite connection string, enable persistent storage for Quartz jobs using SQLite, and specify the job factory to use Microsoft Dependency Injection. We also configure the Quartz hosted service to wait for jobs to complete before shutting down.\nChecking and creating jobs:\npublic static async Task CheckandCreateJobs(this IServiceCollection services) { using (IServiceScope tmp = services.BuildServiceProvider().CreateScope()) { await using var _context = tmp.ServiceProvider.GetRequiredService\u0026lt;ApplicationDbContext\u0026gt;(); var seedData = tmp.ServiceProvider.GetRequiredService\u0026lt;SeedData\u0026gt;(); await seedData.CheckandCreateJobsData(); } } This code defines an extension method CheckandCreateJobs for the IServiceCollection interface. It creates a new scope using the application\u0026rsquo;s service provider and retrieves the necessary services (ApplicationDbContext and SeedData). It then calls the CheckandCreateJobsData method to check and create the necessary jobs.\nQuartz.NET Models Quartz.NET provides various models and classes to represent different entities involved in scheduling, such as triggers, jobs, and schedulers. These models help in configuring and managing the scheduling process.\nnamespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzBlobTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public byte[]? BlobData { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzCalendar { public string SchedName { get; set; } = null!; public string CalendarName { get; set; } = null!; public byte[] Calendar { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzCronTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string CronExpression { get; set; } = null!; public string? TimeZoneId { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzFiredTrigger { public string SchedName { get; set; } = null!; public string EntryId { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string InstanceName { get; set; } = null!; public long FiredTime { get; set; } public long SchedTime { get; set; } public long Priority { get; set; } public string State { get; set; } = null!; public string? JobName { get; set; } public string? JobGroup { get; set; } public byte[]? IsNonconcurrent { get; set; } public byte[]? RequestsRecovery { get; set; } } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzJobDetail { public QrtzJobDetail() { QrtzTriggers = new HashSet\u0026lt;QrtzTrigger\u0026gt;(); } public string SchedName { get; set; } = null!; public string JobName { get; set; } = null!; public string JobGroup { get; set; } = null!; public string? Description { get; set; } public string JobClassName { get; set; } = null!; public byte[] IsDurable { get; set; } = null!; public byte[] IsNonconcurrent { get; set; } = null!; public byte[] IsUpdateData { get; set; } = null!; public byte[] RequestsRecovery { get; set; } = null!; public byte[]? JobData { get; set; } public virtual ICollection\u0026lt;QrtzTrigger\u0026gt; QrtzTriggers { get; set; } } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzLock { public string SchedName { get; set; } = null!; public string LockName { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzPausedTriggerGrp { public string SchedName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzSchedulerState { public string SchedName { get; set; } = null!; public string InstanceName { get; set; } = null!; public long LastCheckinTime { get; set; } public long CheckinInterval { get; set; } } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzSimpleTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public long RepeatCount { get; set; } public long RepeatInterval { get; set; } public long TimesTriggered { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzSimpropTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string? StrProp1 { get; set; } public string? StrProp2 { get; set; } public string? StrProp3 { get; set; } public long? IntProp1 { get; set; } public long? IntProp2 { get; set; } public long? LongProp1 { get; set; } public long? LongProp2 { get; set; } public byte[]? DecProp1 { get; set; } public byte[]? DecProp2 { get; set; } public byte[]? BoolProp1 { get; set; } public byte[]? BoolProp2 { get; set; } public string? TimeZoneId { get; set; } public virtual QrtzTrigger QrtzTrigger { get; set; } = null!; } namespace BlazorAppQuartzNETScheduler.Models.Quartz; public partial class QrtzTrigger { public string SchedName { get; set; } = null!; public string TriggerName { get; set; } = null!; public string TriggerGroup { get; set; } = null!; public string JobName { get; set; } = null!; public string JobGroup { get; set; } = null!; public string? Description { get; set; } public long? NextFireTime { get; set; } public long? PrevFireTime { get; set; } public long? Priority { get; set; } public string TriggerState { get; set; } = null!; public string TriggerType { get; set; } = null!; public long StartTime { get; set; } public long? EndTime { get; set; } public string? CalendarName { get; set; } public long? MisfireInstr { get; set; } public byte[]? JobData { get; set; } public virtual QrtzJobDetail QrtzJobDetail { get; set; } = null!; public virtual QrtzBlobTrigger? QrtzBlobTrigger { get; set; } public virtual QrtzCronTrigger? QrtzCronTrigger { get; set; } public virtual QrtzSimpleTrigger? QrtzSimpleTrigger { get; set; } public virtual QrtzSimpropTrigger? QrtzSimpropTrigger { get; set; } } QuartzDbContext.cs The QuartzDbContext class is defined in the BlazorAppQuartzNETScheduler.Data namespace. It extends the DbContext class and overrides the OnModelCreating method to configure the database schema.\nThe class includes properties for each of the Quartz.NET entities, such as QrtzBlobTrigger, QrtzCalendar, QrtzCronTrigger, etc. These properties represent database tables and are used to query and manipulate data related to Quartz.NET scheduling.\nusing BlazorAppQuartzNETScheduler.Models.Quartz; using Microsoft.EntityFrameworkCore; namespace BlazorAppQuartzNETScheduler.Data; public partial class QuartzDbContext : DbContext { public QuartzDbContext(DbContextOptions\u0026lt;QuartzDbContext\u0026gt; options) : base(options) { } public virtual DbSet\u0026lt;QrtzBlobTrigger\u0026gt; QrtzBlobTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzCalendar\u0026gt; QrtzCalendars { get; set; } = null!; public virtual DbSet\u0026lt;QrtzCronTrigger\u0026gt; QrtzCronTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzFiredTrigger\u0026gt; QrtzFiredTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzJobDetail\u0026gt; QrtzJobDetails { get; set; } = null!; public virtual DbSet\u0026lt;QrtzLock\u0026gt; QrtzLocks { get; set; } = null!; public virtual DbSet\u0026lt;QrtzPausedTriggerGrp\u0026gt; QrtzPausedTriggerGrps { get; set; } = null!; public virtual DbSet\u0026lt;QrtzSchedulerState\u0026gt; QrtzSchedulerStates { get; set; } = null!; public virtual DbSet\u0026lt;QrtzSimpleTrigger\u0026gt; QrtzSimpleTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzSimpropTrigger\u0026gt; QrtzSimpropTriggers { get; set; } = null!; public virtual DbSet\u0026lt;QrtzTrigger\u0026gt; QrtzTriggers { get; set; } = null!; } the QuartzDbContext class is defined with a constructor that accepts DbContextOptions\u0026lt;QuartzDbContext\u0026gt; as a parameter. This allows the class to be configured with the necessary options for connecting to the database.\nThe class includes properties for each of the Quartz.NET entities, such as QrtzBlobTriggers, QrtzCalendars, etc. These properties are used to query and manipulate data related to Quartz.NET scheduling.\nThe OnModelCreating method is overridden to configure the database schema using the ModelBuilder object. In this example, the configuration for the QrtzBlobTrigger entity is provided, including the table name, column mappings, and foreign key relationship.\nJobs.razor the Jobs page component demonstrates how to display a list of jobs and their trigger states, as well as how to pause or resume all jobs. With this application, users can easily schedule and manage their jobs with ease and efficiency.\n@page \u0026#34;/Jobs\u0026#34; @using BlazorAppQuartzNETScheduler.Models.Quartz @using BlazorAppQuartzNETScheduler.Data @using Microsoft.EntityFrameworkCore; @using Quartz; @inject QuartzDbContext QuartzDbContext @inject ISchedulerFactory SchedulerFactory @inject NavigationManager NavigationManager \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Index\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-primary\u0026#34; @onclick=\u0026#34;() =\u0026gt; ResumeAllJobs()\u0026#34;\u0026gt;Resume All Jobs\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @onclick=\u0026#34;() =\u0026gt; PauseAllJobs()\u0026#34;\u0026gt;Pause All Jobs\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; @if (jobs == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;@nameof(QrtzJobDetail.JobName)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(QrtzJobDetail.JobGroup)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;TriggerState\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var job in jobs) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@job.JobName\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@job.JobGroup\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; @foreach (var trigger in job.QrtzTriggers) { \u0026lt;p\u0026gt; TriggerState: @($\u0026#34;{trigger.TriggerState}\u0026#34;) \u0026lt;/p\u0026gt; } \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } @code { private IEnumerable\u0026lt;QrtzJobDetail\u0026gt;? jobs; private IScheduler? scheduler; protected override async Task OnInitializedAsync() { if (jobs is null) await LoadData(); scheduler = await SchedulerFactory.GetScheduler(); } private async Task LoadData() { jobs = await QuartzDbContext.QrtzJobDetails.Include(x =\u0026gt; x.QrtzTriggers).ToListAsync(); } async void ResumeAllJobs() { await scheduler.ResumeAll(); NavigationManager.NavigateTo(\u0026#34;/Jobs\u0026#34;, true); } async void PauseAllJobs() { await scheduler.PauseAll(); NavigationManager.NavigateTo(\u0026#34;/Jobs\u0026#34;, true); } } Source Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppQuartzNETScheduler\n","date":"August 18, 2023","hero":"/dotnet/2023-08-18-blazor-scheduling-with-quartz.net/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-18-blazor-scheduling-with-quartz.net/","summary":"Blazor Scheduling with Quartz.NET Blazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET.\nQuartz.NET: Quartz.NET is a popular open-source job scheduling library for .NET applications. It provides a flexible and powerful way to schedule and execute jobs at specified intervals.\nScheduling: Scheduling refers to the process of defining when and how often a job or task should be executed.","tags":["Dotnet","Blazor Scheduling with Quartz.NET"],"title":"Blazor Scheduling with Quartz.NET"},{"categories":["Dotnet","Blazor Serilog Logging to Console File and Database"],"contents":" Blazor Serilog Logging to Console, File and Database Warning\nThis post is about .NET 6. .NET 8 version is in the link below:\nLink: Blazor Radzen .NET 8 Serilog Logging to Console, File and Database Logging: Logging is the process of recording events, messages, or exceptions that occur during the execution of an application. It helps developers understand the behavior of the application, diagnose issues, and track its performance. Logging is an essential aspect of software development and plays a crucial role in maintaining and troubleshooting applications.\nSerilog: Serilog is a popular logging library for .NET applications. It provides a flexible and extensible logging framework that allows developers to capture and store log events for debugging, monitoring, and analysis purposes. Serilog supports various logging sinks, including console logging, file logging, and database logging.\nConsole Logging: Console logging is a type of logging where log messages are displayed in the console window. It is useful during development and debugging.\nFile Logging: File logging is a type of logging where log messages are written to a file. It helps in storing log data for future analysis and troubleshooting.\nSQLite Database Logging: SQLite database logging is a type of logging where log messages are stored in an SQLite database. It provides a structured way to store and query log data.\nLog.cs The provided code defines a Log model class within the BlazorAppSerilogLogging.Models namespace. The Log class has the following properties:\nnamespace BlazorAppSerilogLogging.Models; public class Log { public int id { get; set; } public DateTime Timestamp { get; set; } public string Level { get; set; } = string.Empty; public string Exception { get; set; } = string.Empty; public string RenderedMessage { get; set; } = string.Empty; public string Properties { get; set; } = string.Empty; } id: An integer property that represents the unique identifier of the log entry.\nTimestamp: A DateTime property that stores the timestamp when the log entry was created.\nLevel: A string property that indicates the log level of the entry (e.g., Information, Warning, Error).\nException: A string property that holds the exception details, if any, associated with the log entry.\nRenderedMessage: A string property that contains the formatted log message.\nProperties: A string property that stores additional properties or metadata related to the log entry.\nApplicationLoggerDbContext.cs The ApplicationLoggerDbContext class is a C# code that represents the database context for logging in a Blazor application using Serilog. It is responsible for managing the connection to the database and providing access to the Logs table.\nusing BlazorAppSerilogLogging.Models; using Microsoft.EntityFrameworkCore; namespace BlazorAppSerilogLogging.Data; public class ApplicationLoggerDbContext : DbContext { public ApplicationLoggerDbContext(DbContextOptions\u0026lt;ApplicationLoggerDbContext\u0026gt; options) : base(options) { } public DbSet\u0026lt;Log\u0026gt; Logs =\u0026gt; Set\u0026lt;Log\u0026gt;(); protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); } } The ApplicationLoggerDbContext class is defined within the BlazorAppSerilogLogging.Data namespace. It extends the DbContext class provided by Entity Framework Core.\nThe class has a constructor that takes an instance of DbContextOptions\u0026lt;ApplicationLoggerDbContext\u0026gt; as a parameter. This allows the class to configure the database connection options.\nThe class also defines a property called Logs of type DbSet\u0026lt;Log\u0026gt;. This property represents the Logs table in the database and allows you to query and manipulate log data.\nThe OnModelCreating method is overridden but left empty in this code example. This method is used to configure the database model and define relationships between entities.\nLoggerService.cs The LoggerService class is defined within the BlazorAppSerilogLogging.Data namespace. It implements several methods for logging operations and interacts with the ApplicationLoggerDbContext class.\nusing BlazorAppSerilogLogging.Models; using Microsoft.EntityFrameworkCore; namespace BlazorAppSerilogLogging.Data; public class LoggerService { private readonly ILogger\u0026lt;LoggerService\u0026gt; _logger; private readonly ApplicationLoggerDbContext _loggerDbContext; public LoggerService(ILogger\u0026lt;LoggerService\u0026gt; logger, ApplicationLoggerDbContext loggerDbContext) { _logger = logger; _loggerDbContext = loggerDbContext; } public async Task\u0026lt;IEnumerable\u0026lt;Log\u0026gt;\u0026gt; GetLogsAsync() { _logger.LogInformation($\u0026#34;Called GetLogsAsync\u0026#34;); return await _loggerDbContext.Logs.OrderByDescending(x =\u0026gt; x.Timestamp).ToListAsync(); } public async Task\u0026lt;Log?\u0026gt; GetLogAsync(int id) { _logger.LogInformation($\u0026#34;Called GetLogAsync\u0026#34;, id); return await _loggerDbContext.Logs.FirstOrDefaultAsync(x =\u0026gt; x.id == id); } public async Task\u0026lt;bool?\u0026gt; DeleteLogsAsync() { _logger.LogInformation($\u0026#34;Called DeleteLogsAsync\u0026#34;); var all = await _loggerDbContext.Logs.ToListAsync(); _loggerDbContext.Logs.RemoveRange(all); ; await _loggerDbContext.SaveChangesAsync(); _logger.LogInformation($\u0026#34;Deleted All Logs.\u0026#34;); return true; } } The class has the following members:\n_logger: An instance of the ILogger\u0026lt;LoggerService\u0026gt; interface, which is used for logging messages.\n_loggerDbContext: An instance of the ApplicationLoggerDbContext class, which represents the database context for logging.\nThe constructor of the LoggerService class takes in an ILogger\u0026lt;LoggerService\u0026gt; instance and an ApplicationLoggerDbContext instance as parameters. These dependencies are injected into the class using dependency injection.\nIndex.razor Index.razor is a Blazor component that displays logs retrieved from a logging service. It allows users to view and delete logs. The logs are fetched asynchronously and displayed in a table format.\n@page \u0026#34;/Logs\u0026#34; @using AutoMapper @using BlazorAppSerilogLogging.Data; @using BlazorAppSerilogLogging.Models; @using BlazorAppSerilogLogging.Services; @using BlazorAppSerilogLogging.ViewModels; @inject IMapper Mapper @inject NavigationManager NavigationManager @inject LoggerService LoggerService \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Index\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; \u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @onclick=\u0026#34;() =\u0026gt; DeleteAllLogs()\u0026#34;\u0026gt;Delete All Logs\u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; @if (logs == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;table class=\u0026#34;table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.id)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Timestamp)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Level)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Exception)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.RenderedMessage)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;@nameof(LogViewModel.Properties)\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; @foreach (var log in logs) { \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;@log.id\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.Timestamp\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span class=\u0026#34;text-@Helpers.LogEventLevelHelper.GetBootstrapUIClass(log.Level)\u0026#34;\u0026gt; @log.Level \u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.Exception\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.RenderedMessage\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;@log.Properties\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; } \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; } @code { private IEnumerable\u0026lt;LogViewModel\u0026gt;? logs; protected override async Task OnInitializedAsync() { if (logs == null) { var result = await LoggerService.GetLogsAsync(); logs = Mapper.Map\u0026lt;IEnumerable\u0026lt;Log\u0026gt;, IEnumerable\u0026lt;LogViewModel\u0026gt;\u0026gt;(result); } } private async void DeleteAllLogs() { await LoggerService.DeleteLogsAsync(); } } This code block is executed when the component is initialized. It calls the GetLogsAsync method of the LoggerService to fetch the logs asynchronously. The retrieved logs are then mapped to LogViewModel objects using AutoMapper. The logs variable is assigned the mapped logs.\nProgram.cs builder.Host.UseSerilog((ctx, lc) =\u0026gt; lc .MinimumLevel.Information() //.WriteTo.Console(new JsonFormatter(), restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.Console(restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.Seq(\u0026#34;http://localhost:5001\u0026#34;, restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Information) .WriteTo.File(serilogFileLoggerFilePath, restrictedToMinimumLevel: Serilog.Events.LogEventLevel.Verbose, rollingInterval: RollingInterval.Hour, encoding: System.Text.Encoding.UTF8) .WriteTo.SQLite(sqliteDbFilePath, tableName: \u0026#34;Logs\u0026#34;, restrictedToMinimumLevel: builder.Environment.IsDevelopment() ? Serilog.Events.LogEventLevel.Information : Serilog.Events.LogEventLevel.Warning, storeTimestampInUtc: false, batchSize: builder.Environment.IsDevelopment() ? (uint)1 : (uint)100, retentionPeriod: new TimeSpan(0, 1, 0, 0, 0), maxDatabaseSize: 10) ); Retrieves the connection string for the SQLite logger from the configuration file and modifies it to include the current directory path.\nConfigures Serilog with various log sinks, including console logging, Seq logging, file logging, and SQLite database logging. It sets the minimum log level based on the application environment.\nRegisters the ApplicationLoggerDbContext and ApplicationDbContext services in the dependency injection container. It configures the ApplicationLoggerDbContext to use the SQLite logger connection string and the ApplicationDbContext to use an in-memory database.\nWe discussed the key concepts of logging, console logging, file logging, and SQLite database logging. We also examined the code structure and provided code examples to illustrate the configuration process. By understanding this code, developers can effectively set up logging in their Blazor applications using Serilog.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppSerilogLogging\n","date":"August 15, 2023","hero":"/dotnet/2023-08-15-blazor-serilog-logging/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-15-blazor-serilog-logging/","summary":"Blazor Serilog Logging to Console, File and Database Warning\nThis post is about .NET 6. .NET 8 version is in the link below:\nLink: Blazor Radzen .NET 8 Serilog Logging to Console, File and Database Logging: Logging is the process of recording events, messages, or exceptions that occur during the execution of an application. It helps developers understand the behavior of the application, diagnose issues, and track its performance. Logging is an essential aspect of software development and plays a crucial role in maintaining and troubleshooting applications.","tags":["Dotnet","Blazor Serilog Logging to Console File and Database"],"title":"Blazor Serilog Logging to Console, File and Database"},{"categories":["Dotnet","Implementing Google reCAPTCHA v2"],"contents":" Blazor Implementing Google reCAPTCHA v2 How to implement Google reCAPTCHA v2 in a Blazor application using C#. Google reCAPTCHA is a free service provided by Google that helps protect websites from spam and abuse. It uses advanced risk analysis techniques to distinguish between humans and bots.\nSite Key: A unique key provided by Google when you register your website to use reCAPTCHA. It is used to identify your website when making API requests.\nSecret Key: A unique key provided by Google when you register your website to use reCAPTCHA. It is used to authenticate your server-side API requests.\nreCAPTCHA Response: The response generated by the reCAPTCHA widget when a user completes the reCAPTCHA challenge. This response is sent to the server for verification.\nVerification Response: The response received from the Google reCAPTCHA API after verifying the reCAPTCHA response. It contains information about the success of the verification and any error codes, if applicable.\nGooglereCAPTCHAv3Service.cs GooglereCAPTCHAv2Service class is responsible for verifying the reCAPTCHA response using the Google reCAPTCHA API. Let\u0026rsquo;s break down the code structure:\nnamespace BlazorAppreCAPTCHAv2.Data; public class GooglereCAPTCHAv2Service { public async Task\u0026lt;(bool Success, string[]? ErrorCodes)\u0026gt; Post(string reCAPTCHAResponse) { var url = \u0026#34;https://www.google.com/recaptcha/api/siteverify\u0026#34;; var content = new FormUrlEncodedContent(new Dictionary\u0026lt;string, string\u0026gt; { {\u0026#34;secret\u0026#34;, GooglereCAPTCHAv2Settings.SecretKey}, {\u0026#34;response\u0026#34;, reCAPTCHAResponse} }); GooglereCAPTCHAv2Response? verificationResponse; using (HttpClient httpClient = new HttpClient()) { try { var response = await httpClient.PostAsync(url, content); response.EnsureSuccessStatusCode(); verificationResponse = await response.Content.ReadFromJsonAsync\u0026lt;GooglereCAPTCHAv2Response\u0026gt;(); } catch (Exception) { throw; } } if (verificationResponse is null || !verificationResponse.Success) return (false, verificationResponse?.ErrorCodes.Select(err =\u0026gt; err.Replace(\u0026#39;-\u0026#39;, \u0026#39; \u0026#39;)).ToArray()); return (Success: true, ErrorCodes: null); } } The Post method takes the reCAPTCHA response as input and returns a tuple containing a boolean value indicating the success of the verification and an array of error codes, if any.\nThe url variable stores the URL of the Google reCAPTCHA API endpoint.\nThe content variable is created using the FormUrlEncodedContent class, which represents key-value pairs encoded in the application/x-www-form-urlencoded format. It contains the secret key (your server-side secret key) and the response key (the reCAPTCHA response).\nThe verificationResponse variable is used to store the response received from the Google reCAPTCHA API after verifying the reCAPTCHA response.\nThe HttpClient class is used to send an HTTP POST request to the Google reCAPTCHA API endpoint. The PostAsync method is called with the URL and content as parameters.\nThe response.EnsureSuccessStatusCode() method ensures that the HTTP response is successful (status code 200).\nThe response.Content.ReadFromJsonAsync\u0026lt;GooglereCAPTCHAv2Response\u0026gt;() method reads the response content and deserializes it into an instance of the GooglereCAPTCHAv2Response class.\nIf the verification response is null or the verification was not successful, the method returns a tuple with the success value set to false and the error codes extracted from the verification response.\nIf the verification was successful, the method returns a tuple with the success value set to true and the error codes set to null.\nGooglereCAPTCHAv2Settings.cs To implement Google reCAPTCHA v2 in Blazor, we need to create a class called GooglereCAPTCHAv2Settings in the BlazorAppreCAPTCHAv2.Data namespace. This class will contain the site key and secret key provided by Google reCAPTCHA.\nnamespace BlazorAppreCAPTCHAv2.Data; public class GooglereCAPTCHAv2Settings { public const string SiteKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv2_SITEKEY\u0026#34;; public const string SecretKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv2_SECRETKEY\u0026#34;; } GooglereCAPTCHAv2Response.cs GooglereCAPTCHAv2Response.cs file represents a C# class that models the response received from the Google reCAPTCHA API. Let\u0026rsquo;s break down the code structure:\nusing System.Text.Json.Serialization; namespace BlazorAppreCAPTCHAv2.Data; public class GooglereCAPTCHAv2Response { public bool Success { get; set; } // timestamp of the challenge load (ISO format yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ssZZ) [JsonPropertyName(\u0026#34;challenge_ts\u0026#34;)] public DateTimeOffset ChallengeTimestamp { get; set; } // the hostname of the site where the reCAPTCHA was solved public string Hostname { get; set; } [JsonPropertyName(\u0026#34;error-codes\u0026#34;)] public string[] ErrorCodes { get; set; } = new string[0]; } The GooglereCAPTCHAv2Response class has the following properties:\nSuccess: A boolean property indicating whether the reCAPTCHA challenge was successfully completed by the user.\nChallengeTimestamp: A DateTimeOffset property representing the timestamp of the challenge load in ISO format.\nHostname: A string property representing the hostname of the site where the reCAPTCHA was solved.\nErrorCodes: An array of strings representing any error codes returned by the reCAPTCHA API. This property is initialized with an empty array by default.\nscript.js a JavaScript module that provides functions for initializing and rendering the reCAPTCHA widget, as well as getting the user\u0026rsquo;s response.\nvar My; (function (My) { var reCAPTCHA; (function (reCAPTCHA) { let scriptLoaded = null; function waitScriptLoaded(resolve) { if (typeof (grecaptcha) !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; typeof (grecaptcha.render) !== \u0026#39;undefined\u0026#39;) resolve(); else setTimeout(() =\u0026gt; waitScriptLoaded(resolve), 100); } function init() { const scripts = Array.from(document.getElementsByTagName(\u0026#39;script\u0026#39;)); if (!scripts.some(s =\u0026gt; (s.src || \u0026#39;\u0026#39;).startsWith(\u0026#39;https://www.google.com/recaptcha/api.js\u0026#39;))) { const script = document.createElement(\u0026#39;script\u0026#39;); script.src = \u0026#39;https://www.google.com/recaptcha/api.js?render=explicit\u0026#39;; script.async = true; script.defer = true; document.head.appendChild(script); } if (scriptLoaded === null) scriptLoaded = new Promise(waitScriptLoaded); return scriptLoaded; } reCAPTCHA.init = init; function render(dotNetObj, selector, siteKey) { return grecaptcha.render(selector, { \u0026#39;sitekey\u0026#39;: siteKey, \u0026#39;callback\u0026#39;: (response) =\u0026gt; { dotNetObj.invokeMethodAsync(\u0026#39;CallbackOnSuccess\u0026#39;, response); }, \u0026#39;expired-callback\u0026#39;: () =\u0026gt; { dotNetObj.invokeMethodAsync(\u0026#39;CallbackOnExpired\u0026#39;); } }); } reCAPTCHA.render = render; function getResponse(widgetId) { return grecaptcha.getResponse(widgetId); } reCAPTCHA.getResponse = getResponse; })(reCAPTCHA = My.reCAPTCHA || (My.reCAPTCHA = {})); })(My || (My = {})); waitScriptLoaded: This function checks if the reCAPTCHA script has been loaded. If not, it waits for it to be loaded before resolving the promise.\ninit: This function initializes the reCAPTCHA script by adding it to the HTML document if it hasn\u0026rsquo;t been added already. It returns a promise that resolves when the script has been loaded.\nrender: This function renders the reCAPTCHA widget using the provided dotNetObj, selector, and siteKey. It also handles the callback functions for success and expiration.\ngetResponse: This function gets the user\u0026rsquo;s response from the reCAPTCHA widget using the provided widgetId.\nReCAPTCHAv2Component.razor It is responsible for rendering the reCAPTCHA widget and handling the user\u0026rsquo;s response. Let\u0026rsquo;s break down the code structure:\n@using System.ComponentModel @inject IJSRuntime JS \u0026lt;span\u0026gt;@loadMessage\u0026lt;/span\u0026gt; \u0026lt;div id=\u0026#34;@UniqueId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; @code { [Parameter] public string SiteKey { get; set; } [Parameter] public EventCallback\u0026lt;string\u0026gt; OnSuccess { get; set; } [Parameter] public EventCallback OnExpired { get; set; } private bool isLoadedScript = false; private string loadMessage = \u0026#34;Loading...\u0026#34;; private string UniqueId = Guid.NewGuid().ToString(); private int WidgetId; protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { try { var timeoutTimeSpan = new TimeSpan(0, 0, 5); // 5 secs var ress = await JS.InvokeAsync\u0026lt;object\u0026gt;(\u0026#34;My.reCAPTCHA.init\u0026#34;, timeout: timeoutTimeSpan); this.WidgetId = await JS.InvokeAsync\u0026lt;int\u0026gt;(\u0026#34;My.reCAPTCHA.render\u0026#34;, timeout: timeoutTimeSpan, DotNetObjectReference.Create(this), UniqueId, SiteKey); isLoadedScript = true; loadMessage = \u0026#34;\u0026#34;; } catch (Exception ex) { loadMessage = \u0026#34;Error on Load Captcha.\u0026#34;; isLoadedScript = false; } StateHasChanged(); } } [JSInvokable, EditorBrowsable(EditorBrowsableState.Never)] public void CallbackOnSuccess(string response) { if (OnSuccess.HasDelegate) { OnSuccess.InvokeAsync(response); } } [JSInvokable, EditorBrowsable(EditorBrowsableState.Never)] public void CallbackOnExpired() { if (OnExpired.HasDelegate) { OnExpired.InvokeAsync(null); } } public ValueTask\u0026lt;string\u0026gt; GetResponseAsync() { return JS.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;My.reCAPTCHA.getResponse\u0026#34;, WidgetId); } } @using System.ComponentModel and @inject IJSRuntime JS: These directives import the necessary namespaces and inject the JavaScript runtime service into the component.\n@code block: This block contains the C# code for the component.\nSiteKey property: This property is used to pass the site key value to the component. The site key is required to initialize the reCAPTCHA widget.\nOnSuccess and OnExpired event callbacks: These event callbacks are used to handle the success and expiration events of the reCAPTCHA widget.\nUniqueId field: This field stores a unique identifier generated using the Guid.NewGuid().ToString() method. It is used to identify the reCAPTCHA widget on the web page.\nOnAfterRenderAsync method: This method is called after the component has been rendered on the web page. It initializes the reCAPTCHA widget by invoking JavaScript functions and sets the isLoadedScript and loadMessage variables based on the success or failure of the initialization.\nCallbackOnSuccess and CallbackOnExpired methods: These methods are invoked by the reCAPTCHA widget\u0026rsquo;s JavaScript API when the user successfully completes the challenge or when the challenge expires. They invoke the respective event callbacks (OnSuccess and OnExpired) if they are subscribed to.\nGetResponseAsync method: This method is used to retrieve the user\u0026rsquo;s response from the reCAPTCHA widget. It invokes a JavaScript function to get the response and returns it as a ValueTask\u0026lt;string\u0026gt;.\nReCAPTCHAv2.razor @page \u0026#34;/ReCAPTCHAv2\u0026#34; @using BlazorAppreCAPTCHAv2.Data; @using BlazorAppreCAPTCHAv2.ViewModels; @using BlazorAppreCAPTCHAv2.Components; @inject IJSRuntime JSRuntime @inject GooglereCAPTCHAv2Service GooglereCAPTCHAv2Service \u0026lt;PageTitle\u0026gt;reCAPTCHAv2\u0026lt;/PageTitle\u0026gt; \u0026lt;EditForm Model=\u0026#34;@blogPostViewModel\u0026#34; OnValidSubmit=\u0026#34;HandleValidSubmit\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Title)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Title)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Content)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Content\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Content)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;mt-3\u0026#34;\u0026gt; \u0026lt;ReCAPTCHAv2Component @ref=\u0026#34;reCAPTCHAv2Component\u0026#34; SiteKey=\u0026#34;@GooglereCAPTCHAv2Settings.SiteKey\u0026#34; OnSuccess=\u0026#34;OnSuccess\u0026#34; OnExpired=\u0026#34;OnExpired\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Send\u0026#34; disabled=\u0026#34;@DisablePostButton\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label text-primary\u0026#34;\u0026gt;\u0026lt;strong\u0026gt; Result: @resultMessage \u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; @code { BlogPostViewModel? blogPostViewModel; private ReCAPTCHAv2Component? reCAPTCHAv2Component; private bool ValidReCAPTCHA = false; private bool DisablePostButton =\u0026gt; !ValidReCAPTCHA; private void OnSuccess() =\u0026gt; ValidReCAPTCHA = true; private void OnExpired() =\u0026gt; ValidReCAPTCHA = false; private string resultMessage = \u0026#34;\u0026#34;; protected override void OnInitialized() { blogPostViewModel = new(); } private async Task HandleValidSubmit() { // verify ReCAPTCHAv2 bool verifiedResult = await CheckReCAPTCHA(); if (!verifiedResult) return; // verified actions resultMessage = \u0026#34;Success...\u0026#34;; StateHasChanged(); } private async Task\u0026lt;bool\u0026gt; CheckReCAPTCHA() { bool serverVerified = false; if (ValidReCAPTCHA) { var response = await reCAPTCHAv2Component.GetResponseAsync(); try { StateHasChanged(); var result = await GooglereCAPTCHAv2Service.Post(response); if (result.Success) { serverVerified = true; } else { await JSRuntime.InvokeAsync\u0026lt;object\u0026gt;(\u0026#34;alert\u0026#34;, string.Join(\u0026#34;, \u0026#34;, result.ErrorCodes)); serverVerified = false; StateHasChanged(); } } catch (HttpRequestException e) { await JSRuntime.InvokeAsync\u0026lt;object\u0026gt;(\u0026#34;alert\u0026#34;, e.Message); serverVerified = false; StateHasChanged(); } } return serverVerified; } } The OnSuccess method is called when the user successfully completes the reCAPTCHA challenge. It sets the ValidReCAPTCHA flag to true.\nThe OnExpired method is called when the reCAPTCHA challenge expires. It sets the ValidReCAPTCHA flag to false.\nThe HandleValidSubmit method is called when the form is submitted and passes the validation. It first verifies the reCAPTCHA response by calling the CheckReCAPTCHA method. If the verification fails, the method returns. Otherwise, it performs the desired actions and updates the resultMessage variable.\nThe CheckReCAPTCHA method checks if the reCAPTCHA response is valid. If it is, it retrieves the response token from the reCAPTCHA component and sends it to the Google reCAPTCHA service for verification. If the verification is successful, the serverVerified flag is set to true. Otherwise, an alert is displayed with the error codes returned by the service.\nWe have learned how to implement Google reCAPTCHA v2 in a Blazor application. By following the code examples and understanding the key concepts, you can enhance the security of your forms and protect your website from spam and abuse. Remember to obtain a site key from Google reCAPTCHA and replace the placeholder in the code with your actual site key. Happy coding!\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppreCAPTCHAv2\n","date":"August 13, 2023","hero":"/dotnet/2023-08-13-blazor-implementing-google-recaptcha-v2/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-13-blazor-implementing-google-recaptcha-v2/","summary":"Blazor Implementing Google reCAPTCHA v2 How to implement Google reCAPTCHA v2 in a Blazor application using C#. Google reCAPTCHA is a free service provided by Google that helps protect websites from spam and abuse. It uses advanced risk analysis techniques to distinguish between humans and bots.\nSite Key: A unique key provided by Google when you register your website to use reCAPTCHA. It is used to identify your website when making API requests.","tags":["Dotnet","Implementing Google reCAPTCHA v2"],"title":"Blazor Implementing Google reCAPTCHA v2"},{"categories":["Dotnet","Implementing Google reCAPTCHA v3"],"contents":" Blazor Implementing Google reCAPTCHA v3 Google reCAPTCHA v3 in a Blazor application. Google reCAPTCHA is a service that helps protect websites from spam and abuse by verifying that the user is a human and not a bot. reCAPTCHA v3 is the latest version of this service and provides a seamless user experience without requiring any user interaction.\nSite Key: A unique identifier for your website, obtained from the reCAPTCHA admin console. This key is used to identify your website when making API requests to Google\u0026rsquo;s reCAPTCHA service.\nSecret Key: A secret key associated with your site key, also obtained from the reCAPTCHA admin console. This key is used to authenticate your API requests to Google\u0026rsquo;s reCAPTCHA service.\nToken: A token generated by the reCAPTCHA JavaScript API, which is sent to the server for verification. This token contains information about the user\u0026rsquo;s interaction with your website and is used to determine the likelihood of the user being a bot.\nScore: reCAPTCHA v3 returns a score between 0.0 and 1.0, indicating the likelihood that the user is a bot. A score closer to 1.0 indicates a higher likelihood of being a human.\nGooglereCAPTCHAv3Service.cs GooglereCAPTCHAv3Service class demonstrates how to verify a reCAPTCHA token using the Google reCAPTCHA v3 API. Let\u0026rsquo;s break down the code structure:\nNamespace: The code is placed inside the BlazorAppreCAPTCHAv3.Data namespace.\nClass: The GooglereCAPTCHAv3Service class contains a single method Verify that takes a reCAPTCHA token as input and returns a GooglereCAPTCHAv3Response object.\nHttpClient: The code uses the HttpClient class to send an HTTP POST request to the reCAPTCHA API endpoint.\nFormUrlEncodedContent: The reCAPTCHA API requires the secret and response parameters to be sent as form data. The code creates a FormUrlEncodedContent object and adds these parameters to it.\nPostAsync: The code sends the HTTP POST request to the reCAPTCHA API endpoint with the form data.\nReadAsStringAsync: The code reads the response from the API as a string.\nJsonSerializer: The code deserializes the JSON response string into a GooglereCAPTCHAv3Response object using the JsonSerializer class.\nException Handling: The code catches any exceptions that occur during the API request and rethrows them.\nReturn Statement: The code returns the GooglereCAPTCHAv3Response object.\nusing System.Text.Json; namespace BlazorAppreCAPTCHAv3.Data; public class GooglereCAPTCHAv3Service { public virtual async Task\u0026lt;GooglereCAPTCHAv3Response?\u0026gt; Verify(string token) { GooglereCAPTCHAv3Response? reCaptchaResponse; using (var httpClient = new HttpClient()) { var content = new FormUrlEncodedContent(new[] { new KeyValuePair\u0026lt;string, string\u0026gt;(\u0026#34;secret\u0026#34;, GooglereCAPTCHAv3Settings.SecretKey), new KeyValuePair\u0026lt;string, string\u0026gt;(\u0026#34;response\u0026#34;, token) }); try { var response = await httpClient.PostAsync($\u0026#34;https://www.google.com/recaptcha/api/siteverify\u0026#34;, content); var jsonString = await response.Content.ReadAsStringAsync(); reCaptchaResponse = JsonSerializer.Deserialize\u0026lt;GooglereCAPTCHAv3Response\u0026gt;(jsonString); } catch (Exception) { throw; } return reCaptchaResponse; } } } GooglereCAPTCHAv3Settings.cs To implement Google reCAPTCHA v3 in a Blazor application, we need to create a class that holds the reCAPTCHA settings. In this example, we have a class called GooglereCAPTCHAv3Settings in the BlazorAppreCAPTCHAv3.Data namespace.\nIn the GooglereCAPTCHAv3Settings class, we have two constant fields: SiteKey and SecretKey. These fields hold the site key and secret key provided by Google reCAPTCHA. You need to replace the placeholders with your actual site key and secret key.\nnamespace BlazorAppreCAPTCHAv3.Data; public class GooglereCAPTCHAv3Settings { public const string SiteKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv3_SITEKEY\u0026#34;; public const string SecretKey = \u0026#34;YOUR_GOOGLE_reCAPTCHAv3_SECRETKEY\u0026#34;; } GooglereCAPTCHAv3Response.cs A model class GooglereCAPTCHAv3Response that represents the response received from the reCAPTCHA API. It has properties like success, score, action, challenge_ts, and hostname. These properties will be populated with the relevant data returned by the reCAPTCHA service.\nnamespace BlazorAppreCAPTCHAv3.Data; public class GooglereCAPTCHAv3Response { public bool success { get; set; } public double score { get; set; } public string action { get; set; } public DateTime challenge_ts { get; set; } public string hostname { get; set; } } _Layout.cshtml \u0026lt;script src=@($\u0026#34;https://www.google.com/recaptcha/api.js?render={BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; runCaptcha = function (actionName) { return new Promise((resolve, reject) =\u0026gt; { grecaptcha.ready(function () { grecaptcha.execute(\u0026#39;@($\u0026#34;{BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026#39;, { action: \u0026#39;submit\u0026#39; }).then(function (token) { resolve(token); }); }); }); }; \u0026lt;/script\u0026gt; Let\u0026rsquo;s break down the code and understand its functionality:\n\u0026lt;script src=@($\u0026#34;https://www.google.com/recaptcha/api.js?render={BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026gt;\u0026lt;/script\u0026gt; This line of code includes the reCAPTCHA API script from Google\u0026rsquo;s servers. It dynamically generates the URL based on the SiteKey value provided in the GooglereCAPTCHAv3Settings class.\n\u0026lt;script\u0026gt; runCaptcha = function (actionName) { return new Promise((resolve, reject) =\u0026gt; { grecaptcha.ready(function () { grecaptcha.execute(\u0026#39;@($\u0026#34;{BlazorAppreCAPTCHAv3.Data.GooglereCAPTCHAv3Settings.SiteKey}\u0026#34;)\u0026#39;, { action: \u0026#39;submit\u0026#39; }).then(function (token) { resolve(token); }); }); }); }; \u0026lt;/script\u0026gt; This script defines a function called runCaptcha that can be used to execute the reCAPTCHA verification process. It takes an actionName parameter, which represents the specific action you want to protect. Inside the function, it uses the grecaptcha object provided by the reCAPTCHA API to execute the verification process. Once the verification is successful, it resolves the promise with the generated token.\nReCAPTCHAv3.razor @page \u0026#34;/ReCAPTCHAv3\u0026#34; @using BlazorAppreCAPTCHAv3.Data; @using BlazorAppreCAPTCHAv3.ViewModels; @inject IJSRuntime JSRuntime @inject GooglereCAPTCHAv3Service GooglereCAPTCHAv3Service \u0026lt;PageTitle\u0026gt;reCAPTCHAv3\u0026lt;/PageTitle\u0026gt; \u0026lt;EditForm Model=\u0026#34;@blogPostViewModel\u0026#34; OnValidSubmit=\u0026#34;HandleValidSubmit\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Title)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Title)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@nameof(BlogPostViewModel.Content)\u0026lt;/label\u0026gt; \u0026lt;InputText @bind-Value=\u0026#34;blogPostViewModel.Content\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;ValidationMessage For=\u0026#34;@(() =\u0026gt; blogPostViewModel.Content)\u0026#34; class=\u0026#34;text-danger\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;submitBtn\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; \u0026lt;div class=\u0026#34;form-group mt-3\u0026#34;\u0026gt; @if (googlereCAPTCHAv3Response != null) { \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;Result\u0026lt;/strong\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;Status\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; value=\u0026#34;@googlereCAPTCHAv3Response.success.ToString()\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;Score\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;form-control\u0026#34; value=\u0026#34;@googlereCAPTCHAv3Response.score\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;reCAPTCHA token\u0026lt;/label\u0026gt; \u0026lt;textarea rows=\u0026#34;4\u0026#34; cols=\u0026#34;50\u0026#34; readonly class=\u0026#34;form-control\u0026#34;\u0026gt; @token \u0026lt;/textarea\u0026gt; \u0026lt;/div\u0026gt; @code { BlogPostViewModel blogPostViewModel = new BlogPostViewModel(); string token = \u0026#34;\u0026#34;; GooglereCAPTCHAv3Response? googlereCAPTCHAv3Response; private async Task HandleValidSubmit() { googlereCAPTCHAv3Response = await GooglereCAPTCHAv3Service.Verify(token); StateHasChanged(); } protected override async void OnAfterRender(bool firstRender) { if (firstRender) { token = await JSRuntime.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;runCaptcha\u0026#34;); StateHasChanged(); } } } In the ReCAPTCHAv3.razor page:\nHandleValidSubmit(): This method is called when the form is submitted and the validation is successful. It calls the Verify() method of the GooglereCAPTCHAv3Service to verify the reCAPTCHA token and assigns the response to the googlereCAPTCHAv3Response object. The StateHasChanged() method is called to update the UI.\nOnAfterRender(): This method is called after the component has been rendered. It checks if it is the first render and then calls the runCaptcha JavaScript function using the JSRuntime service to generate the reCAPTCHA token. The StateHasChanged() method is called to update the UI.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppreCAPTCHAv3\n","date":"August 11, 2023","hero":"/dotnet/2023-08-11-blazor-implementing-google-recaptcha-v3/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-11-blazor-implementing-google-recaptcha-v3/","summary":"Blazor Implementing Google reCAPTCHA v3 Google reCAPTCHA v3 in a Blazor application. Google reCAPTCHA is a service that helps protect websites from spam and abuse by verifying that the user is a human and not a bot. reCAPTCHA v3 is the latest version of this service and provides a seamless user experience without requiring any user interaction.\nSite Key: A unique identifier for your website, obtained from the reCAPTCHA admin console.","tags":["Dotnet","Implementing Google reCAPTCHA v3"],"title":"Blazor Implementing Google reCAPTCHA v3"},{"categories":["Dotnet","Blazor Radzen Globalization and Localization"],"contents":" Blazor Radzen Globalization and Localization The concept of globalization and localization in Blazor, a popular framework for building web applications. We will specifically focus on how to implement globalization and localization using Radzen, a set of UI components for Blazor. We will explore the code provided and understand its functionality.\nGlobalization: Globalization refers to the process of designing and developing applications that can be adapted to various cultures and languages. It involves making your application culturally aware and providing support for different languages, date formats, number formats, and more.\nLocalization: Localization is the process of adapting an application to a specific culture or locale. It involves translating the user interface, date formats, number formats, and other elements of the application to match the preferences of a particular culture or language.\nCulture: A culture represents a specific set of conventions, such as language, date format, and number format, associated with a particular region or group of people.\nCulturePicker.razor The CulturePicker component is a partial class that extends the ComponentBase class provided by Blazor. It contains several injected services and properties for language, currency, and dropdown data. The OnInitialized method is overridden to set the initial values for language and currency based on the current culture settings. The ChangeCulture method is called when the user selects a new language or currency, and it updates the culture settings and redirects the user to the appropriate page.\n@inject Microsoft.Extensions.Localization.IStringLocalizer\u0026lt;CulturePicker\u0026gt; L @*\u0026lt;RadzenDropDown @bind-Value=\u0026#34;@culture\u0026#34; TValue=\u0026#34;string\u0026#34; Data=\u0026#34;@(cultureDrowDownData)\u0026#34; TextProperty=\u0026#34;Text\u0026#34; ValueProperty=\u0026#34;Value\u0026#34; Change=\u0026#34;@ChangeCulture\u0026#34; /\u0026gt; *@ \u0026lt;RadzenText Text=\u0026#34;Language\u0026#34; class=\u0026#34;rz-my-1 rz-mx-2\u0026#34; /\u0026gt; \u0026lt;RadzenDropDown @bind-Value=\u0026#34;@language\u0026#34; TValue=\u0026#34;string\u0026#34; Data=\u0026#34;@(languageDrowDownData)\u0026#34; TextProperty=\u0026#34;Text\u0026#34; ValueProperty=\u0026#34;Value\u0026#34; Change=\u0026#34;@ChangeCulture\u0026#34; /\u0026gt; \u0026lt;RadzenText Text=\u0026#34;Currency\u0026#34; class=\u0026#34;rz-my-1 rz-ml-4 rz-mr-2\u0026#34; /\u0026gt; \u0026lt;RadzenDropDown @bind-Value=\u0026#34;@currency\u0026#34; TValue=\u0026#34;string\u0026#34; Data=\u0026#34;@(currencyDrowDownData)\u0026#34; TextProperty=\u0026#34;Text\u0026#34; ValueProperty=\u0026#34;Value\u0026#34; Change=\u0026#34;@ChangeCulture\u0026#34; class=\u0026#34;rz-mr-2\u0026#34; /\u0026gt; The code begins with an @inject directive, which is used to inject an instance of the IStringLocalizer interface into the CulturePicker component. The IStringLocalizer interface provides a way to retrieve localized strings for the current culture.\nNext, we have a commented out code block that represents a RadzenDropDown component. This component is used to display a dropdown list of cultures, allowing the user to select their preferred language. The @bind-Value directive is used to bind the selected value to the culture variable. The TValue parameter specifies the type of the selected value, which in this case is a string. The Data parameter provides the data source for the dropdown list, and the TextProperty and ValueProperty parameters specify the properties of the data source that should be used for displaying the text and storing the selected value, respectively. The Change parameter specifies the event handler that should be called when the selected value changes.\nAfter the commented out code block, we have two RadzenText components. These components are used to display labels for the dropdown lists. The Text parameter specifies the text to be displayed, and the class parameter is used to apply CSS classes for styling.\nFinally, we have two more RadzenDropDown components. These components are similar to the commented out code block, but they are used to display dropdown lists for selecting the preferred language and currency. The @bind-Value directive is used to bind the selected values to the language and currency variables, respectively. The class parameter is used to apply CSS classes for styling.\nCulturePicker.razor.cs Initializing language and currency:\nprotected override void OnInitialized() { language = CultureInfo.CurrentCulture.TwoLetterISOLanguageName; currency = CultureInfo.CurrentCulture.Name.ReplaceFirst(quot;{CultureInfo.CurrentCulture.TwoLetterISOLanguageName}-\u0026#34;, \u0026#34;\u0026#34;); } Changing the culture:\nprotected void ChangeCulture() { var redirect = new Uri(NavigationManager.Uri).GetComponents(UriComponents.PathAndQuery | UriComponents.Fragment, UriFormat.UriEscaped); string culture = quot;{language}-{currency}\u0026#34;; var query = quot;?culture={Uri.EscapeDataString(culture)}\u0026amp;redirectUri={redirect}\u0026#34;; NavigationManager.NavigateTo(\u0026#34;Culture/SetCulture\u0026#34; + query, forceLoad: true); } CultureController.cs The CultureController.cs file is a C# code file that contains a controller class responsible for handling culture-related operations in a Blazor application. It provides a method called SetCulture that allows the user to set the culture of the application and redirect to a specified URI.\nThe CultureController.cs file is a partial class that extends the Controller class provided by the Microsoft.AspNetCore.Mvc namespace. It is decorated with the [Route] attribute, which specifies the route prefix for the controller\u0026rsquo;s actions.\nThe controller contains a single action method called SetCulture, which takes two parameters: culture and redirectUri. The culture parameter represents the desired culture to be set, and the redirectUri parameter represents the URI to which the user should be redirected after setting the culture.\nusing Microsoft.AspNetCore.Localization; using Microsoft.AspNetCore.Mvc; namespace BlazorAppRadzenGlobalizationLocalization.Controllers { [Route(\u0026#34;Culture/[action]\u0026#34;)] public partial class CultureController : Controller { public IActionResult SetCulture(string culture, string redirectUri) { if (culture != null) { Response.Cookies.Append( CookieRequestCultureProvider.DefaultCookieName, CookieRequestCultureProvider.MakeCookieValue(new RequestCulture(culture))); } return LocalRedirect(redirectUri); } } } In this code, we import the necessary namespaces Microsoft.AspNetCore.Localization and Microsoft.AspNetCore.Mvc to access the required classes and methods.\nThe CultureController class is defined as a partial class and inherits from the Controller class provided by the Microsoft.AspNetCore.Mvc namespace.\nThe [Route] attribute is used to specify the route prefix for the controller\u0026rsquo;s actions. In this case, the route prefix is set to \u0026ldquo;Culture/[action]\u0026rdquo;. This means that the SetCulture action can be accessed using the URL \u0026quot;/Culture/SetCulture\u0026quot;.\nThe SetCulture action method takes two parameters: culture and redirectUri. The culture parameter represents the desired culture to be set, and the redirectUri parameter represents the URI to which the user should be redirected after setting the culture.\nInside the SetCulture method, there is a conditional statement that checks if the culture parameter is not null. If it is not null, it means that a valid culture value has been provided.\nThe Response.Cookies.Append method is then called to add a cookie to the response. This cookie is used to store the selected culture value. The CookieRequestCultureProvider.DefaultCookieName property is used to specify the name of the cookie, and the CookieRequestCultureProvider.MakeCookieValue method is used to convert the culture value into a string representation that can be stored in the cookie.\nFinally, the LocalRedirect method is called to redirect the user to the specified redirectUri after setting the culture.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenGlobalizationLocalization\n","date":"August 9, 2023","hero":"/dotnet/2023-08-09-blazor-radzen-globalization-and-localization/blazor_radzen_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-09-blazor-radzen-globalization-and-localization/","summary":"Blazor Radzen Globalization and Localization The concept of globalization and localization in Blazor, a popular framework for building web applications. We will specifically focus on how to implement globalization and localization using Radzen, a set of UI components for Blazor. We will explore the code provided and understand its functionality.\nGlobalization: Globalization refers to the process of designing and developing applications that can be adapted to various cultures and languages.","tags":["Dotnet","Blazor Radzen Globalization and Localization"],"title":"Blazor Radzen Globalization and Localization"},{"categories":["Dotnet","Blazor Using NPM Packages"],"contents":" Blazor Using NPM Packages Create a new folder named npm_packages in your Blazor project.\nOpen the npm_packages folder directory via command prompt and run the following command to initialize NPM in the application:\nnpm init -y This will create a new package.json file in the npm_packages directory.\nInstall the webpack and webpack-cli packages as development dependencies by running the following command: npm install webpack webpack-cli --save-dev Modify the scripts section of the package.json file to add the following build script: \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack ./src/index.js --output-path ../wwwroot/js --output-filename index.bundle.js\u0026#34; }, This build script will use webpack to bundle the JavaScript files in the src folder into a single file called index.bundle.js in the wwwroot/js folder.\nInstall the NPM package that you want to use in your Blazor application. For example, to install the chart.js package, run the following command: npm i chart.js Build your Blazor application by running the following command: npm run build This will run the webpack build script that you defined in the package.json file.\nModify the csproj file to add a pre-build step that will run the npm build script. This will ensure that the NPM packages are installed and bundled before your Blazor application is built. To do this, add the following code to the PreBuild target in the csproj file: \u0026lt;Target Name=\u0026#34;PreBuild\u0026#34; BeforeTargets=\u0026#34;PreBuildEvent\u0026#34;\u0026gt; \u0026lt;Exec Command=\u0026#34;npm install\u0026#34; WorkingDirectory=\u0026#34;npm_packages\u0026#34; /\u0026gt; \u0026lt;Exec Command=\u0026#34;npm run build\u0026#34; WorkingDirectory=\u0026#34;npm_packages\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt; Edit the _Layout.cshtml file and add the following code to the head section: \u0026lt;script src=\u0026#34;~/js/index.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; This will load the index.bundle.js file that was created by the webpack build script.\nRun your Blazor application and the NPM package that you installed should be available to use in your Blazor code. Source Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppNPMPackages\n","date":"August 7, 2023","hero":"/dotnet/2023-08-07-blazor-using-npm-packages/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-07-blazor-using-npm-packages/","summary":"Blazor Using NPM Packages Create a new folder named npm_packages in your Blazor project.\nOpen the npm_packages folder directory via command prompt and run the following command to initialize NPM in the application:\nnpm init -y This will create a new package.json file in the npm_packages directory.\nInstall the webpack and webpack-cli packages as development dependencies by running the following command: npm install webpack webpack-cli --save-dev Modify the scripts section of the package.","tags":["Dotnet","Blazor Using NPM Packages"],"title":"Blazor Using NPM Packages"},{"categories":["Dotnet","Blazor Generic Components"],"contents":" Blazor Generic Components We will explore a Blazor generic component that can be used for performing CRUD (Create, Read, Update, Delete) operations on a list of items. This component is designed to provide a reusable and efficient solution for displaying and managing data in a Blazor application.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET, providing a seamless development experience.\nGeneric Components: Generic components in Blazor allow us to create reusable UI components that can work with different types of data. By using generics, we can create components that are flexible and adaptable to various scenarios.\nTModel: The TModel type parameter represents the model class that the component will work with. It must inherit from the BaseModel class.\nTViewModel: The TViewModel type parameter represents the view model class that the component will use to display the data. It must inherit from the BaseViewModel class and have a parameterless constructor.\nIService: The IService\u0026lt;TModel\u0026gt; interface represents a service that provides CRUD (Create, Read, Update, Delete) operations for the TModel class. It is injected into the component to retrieve the data.\nIMapper: The IMapper interface is used for object-to-object mapping. It is injected into the component to map the TModel objects to TViewModel objects.\nNavigationManager: The NavigationManager class provides methods for navigating within a Blazor application. It is injected into the component to handle navigation to different pages.\nLet\u0026rsquo;s break down the code structure:\nNamespace and Using Statements: The code starts with the declaration of the namespace and the necessary using statements.\nType Parameters: The component uses two type parameters, TModel and TViewModel, which represent the model and view model types, respectively. These parameters allow the component to work with different types of data.\nConditional Rendering: The code uses conditional rendering to display a loading message if the listViewModel is null. Otherwise, it renders a table to display the list of items.\nTable Structure: The table structure is defined using HTML markup. The table headers are dynamically generated based on the properties of the TViewModel type. The nameof function is used to get the name of the Id property from the BaseViewModel class, and the GetProperties method is used to iterate over the properties of the TViewModel type.\nData Binding: The table rows are generated using a foreach loop that iterates over the listViewModel collection. The GetProperty and GetValue methods are used to retrieve the values of the properties dynamically. The ToString method is called to convert the values to strings.\nCRUD Links: Each table row includes links for performing CRUD operations on the corresponding item. The NavigateLinkItemDetails, NavigateLinkItemEdit, and NavigateLinkItemDelete properties are used to generate the URLs for the respective operations. The Replace method is used to replace the placeholder {{{id}}} with the actual item ID.\nList Posts (List.razor, List.razor.cs) Let\u0026rsquo;s take a closer look at the code provided in the List\u0026lt;TModel, TViewModel\u0026gt; component:\npublic partial class List\u0026lt;TModel, TViewModel\u0026gt; : ComponentBase where TModel : BaseModel where TViewModel : BaseViewModel, new() { [Parameter, EditorRequired] public string? NavigateLinkItemDetails { get; set; } [Parameter, EditorRequired] public string? NavigateLinkItemEdit { get; set; } [Parameter, EditorRequired] public string? NavigateLinkItemDelete { get; set; } [Inject] private IService\u0026lt;TModel\u0026gt;? _service { get; set; } [Inject] private IMapper? Mapper { get; set; } [Inject] private NavigationManager? NavigationManager { get; set; } private IEnumerable\u0026lt;TViewModel\u0026gt;? listViewModel; protected override async Task OnInitializedAsync() { if (_service == null || Mapper == null) return; var model = await _service.GetAllAsync(); if (model == null) return; listViewModel = Mapper.Map\u0026lt;IEnumerable\u0026lt;TModel\u0026gt;, IEnumerable\u0026lt;TViewModel\u0026gt;\u0026gt;(model); } } In this code, we define the List\u0026lt;TModel, TViewModel\u0026gt; component as a partial class that inherits from ComponentBase. The component has the following members:\nParameters: The component has three parameters: NavigateLinkItemDetails, NavigateLinkItemEdit, and NavigateLinkItemDelete. These parameters are used to specify the navigation links for item details, item edit, and item delete actions.\nInjected Services: The component injects three services: IService\u0026lt;TModel\u0026gt;, IMapper, and NavigationManager. These services are used to retrieve data, map objects, and handle navigation, respectively.\nlistViewModel: This private property holds the list of view models that will be displayed in the component.\nOnInitializedAsync: This method is an overridden method from the ComponentBase class. It is called when the component is initialized. In this method, we check if the injected services are available. If they are, we retrieve the data using the _service and map it to the view models using the Mapper. The resulting view models are assigned to the listViewModel property.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.List TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; NavigateLinkItemDetails=\u0026#34;/BlogPost/Details/{{{id}}}\u0026#34; NavigateLinkItemEdit=\u0026#34;/BlogPost/Edit/{{{id}}}\u0026#34; NavigateLinkItemDelete=\u0026#34;/BlogPost/Delete/{{{id}}}\u0026#34; /\u0026gt; Create Post (Create.razor, Create.razor.cs) @namespace BlazorAppGenericComponents.Components @typeparam TModel @typeparam TViewModel @if (viewModel == null) { \u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Loading...\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt; } else { \u0026lt;EditForm Context=\u0026#34;editFormComponent\u0026#34; OnValidSubmit=\u0026#34;@HandleValidSubmit\u0026#34; Model=\u0026#34;@viewModel\u0026#34;\u0026gt; @foreach (var property in typeof(TViewModel).GetProperties()) { @if (property.Name != \u0026#34;Id\u0026#34;) { \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;control-label\u0026#34;\u0026gt;@property.Name\u0026lt;/label\u0026gt; \u0026lt;input @onchange=\u0026#39;((e) =\u0026gt; HandleValueChanged(e, property.Name))\u0026#39; type=\u0026#34;text\u0026#34; value=\u0026#34;@property.GetValue(viewModel)?.ToString()\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; } } \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Create\u0026#34; class=\u0026#34;btn btn-primary\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/EditForm\u0026gt; } In this code snippet, the component checks if the viewModel is null. If it is null, it displays a loading message. Otherwise, it renders an EditForm component with the viewModel as the model.\nInside the EditForm component, a loop iterates over the properties of the TViewModel type. For each property, a form group is created with a label and an input field. The label displays the name of the property, and the input field is bound to the corresponding property value in the viewModel.\nThe HandleValueChanged method is called whenever the value of an input field changes. It updates the corresponding property value in the viewModel.\nFinally, a submit button is displayed to create the entity.\nThe component has two generic type parameters: TModel and TViewModel. TModel represents the model class for the database entity, while TViewModel represents the view model class for the form.\nThe component has the following properties and dependencies:\nNavigateLinkAfterSubmit: A string parameter that specifies the URL to navigate to after the form is submitted. _service: An instance of the IService\u0026lt;TModel\u0026gt; interface, which is responsible for interacting with the database. Mapper: An instance of the IMapper interface, which is used to map the view model to the model. NavigationManager: An instance of the NavigationManager class, which is used to navigate to the specified URL. The component also has a private field called \u0026ldquo;viewModel\u0026rdquo; of type TViewModel, which represents the current state of the form.\nOnInitialized: This method is called when the component is initialized. It creates a new instance of the view model and assigns it to the \u0026ldquo;viewModel\u0026rdquo; field.\nHandleValidSubmit: This method is called when the form is submitted and passes validation. It maps the view model to the model using the IMapper interface. Then, it calls the AddAsync method of the _service instance to add the model to the database. If the operation is successful, it navigates to the specified URL using the NavigationManager.\nHandleValueChanged: This method is called when the value of an input field in the form changes. It updates the corresponding property of the view model with the new value.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Create TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; NavigateLinkAfterSubmit=\u0026#34;/BlogPost\u0026#34; /\u0026gt; Details Post (Details.razor, Details.razor.cs) \u0026lt;dl class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BaseViewModel.Id) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @typeof(TViewModel).GetProperty(nameof(BaseViewModel.Id))?.GetValue(viewModel)?.ToString() \u0026lt;/dd\u0026gt; @foreach (var property in typeof(TViewModel).GetProperties()) { if (property.Name != nameof(BaseViewModel.Id)) { \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @property.Name \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @property.GetValue(viewModel)?.ToString() \u0026lt;/dd\u0026gt; } } \u0026lt;/dl\u0026gt; The component has the following properties and dependencies:\nId: An optional parameter that represents the ID of the model for which the details are to be displayed.\n_service: An injected dependency of type IService\u0026lt;TModel\u0026gt;, which is responsible for retrieving the model data.\nMapper: An injected dependency of type IMapper, which is used to map the model to the view model.\nNavigationManager: An injected dependency of type NavigationManager, which is used for navigation within the application.\nviewModel: A private property of type TViewModel, which holds the view model instance.\nThe OnInitializedAsync method is overridden to fetch the model data and map it to the view model. If the Id is null or any of the dependencies are null, the method returns early. Otherwise, it calls the _service.GetbyId method to retrieve the model with the specified ID. If the model is found, it uses the Mapper to map the model to the view model and assigns it to the viewModel property.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Details TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; Id=\u0026#34;@id\u0026#34; /\u0026gt; Edit Post (Edit.razor, Edit.razor.cs) Let\u0026rsquo;s break down the code structure:\nNamespace and Using Statements: The code starts with the declaration of the namespace and the necessary using statements.\nType Parameters: The component is defined with two type parameters, TModel and TViewModel. These parameters allow the component to work with different models and view models.\nConditional Rendering: The code uses a conditional rendering statement to check if the viewModel is null. If it is null, it displays a loading message. Otherwise, it renders the form for editing the model.\nEditForm Component: The EditForm component is a built-in Blazor component that provides form validation and submission functionality. It is used to wrap the form elements.\nProperty Loop: Inside the EditForm component, a loop is used to iterate over the properties of the TViewModel type. The loop excludes the Id property, as it is usually an identifier and not editable.\nForm Group: For each property, a form group is created with a label and an input field. The onchange event is wired to a method called HandleValueChanged, which handles the value change of the input field.\nSubmit Button: Finally, a submit button is added to the form for saving the changes.\nBlazor generic component named Edit\u0026lt;TModel, TViewModel\u0026gt;. Let\u0026rsquo;s break down its structure:\nNamespace and Dependencies: The component is defined within the BlazorAppGenericComponents.Components namespace. It has dependencies on AutoMapper, BlazorAppGenericComponents.Models, BlazorAppGenericComponents.Services, BlazorAppGenericComponents.ViewModels, and Microsoft.AspNetCore.Components.\nComponent Declaration: The component is declared as a partial class that inherits from ComponentBase. It has two generic type parameters, TModel and TViewModel, which represent the model and view model types, respectively.\nComponent Parameters: The component has two parameters defined using the [Parameter] attribute. The Id parameter is of type int? and represents the identifier of the model to be edited. The NavigateLinkAfterSubmit parameter is of type string? and represents the URL to navigate to after a successful submit.\nDependency Injection: The component injects dependencies for IService\u0026lt;TModel\u0026gt;, IMapper, and NavigationManager using the [Inject] attribute.\nViewModel Initialization: The OnInitializedAsync method is overridden to initialize the view model based on the provided Id parameter. It retrieves the model from the service using the GetbyId method and maps it to the view model using AutoMapper.\nForm Submission: The HandleValidSubmit method is called when the form is submitted. It maps the view model back to the model using AutoMapper and calls the UpdateAsync method of the service to update the model. If the update is successful, it navigates to the specified URL using the NavigationManager.\nValue Change Handling: The HandleValueChanged method is called when the value of an input field changes. It updates the corresponding property of the view model based on the changed value.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Edit TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; Id=\u0026#34;@id\u0026#34; NavigateLinkAfterSubmit=\u0026#34;/BlogPost\u0026#34; /\u0026gt; Delete Post (Delete.razor, Delete.razor.cs) The code starts with the @namespace directive, which specifies the namespace of the component. It is followed by the @using directive, which imports the necessary namespaces for the component.\nNext, the component declares two type parameters, TModel and TViewModel, using the @typeparam directive. These type parameters represent the model and view model types that will be used with the component.\nThe code then checks if the viewModel variable is null. If it is null, it displays a loading message. Otherwise, it generates the details view for the view model.\nInside the dl element, the code displays the value of the Id property of the view model using the @nameof directive and the GetValue method. It then iterates over the properties of the view model using a foreach loop.\nFor each property, it checks if the property name is not equal to \u0026ldquo;Id\u0026rdquo;. If it is not equal, it displays the property name and its value using the @property.Name and @property.GetValue directives.\nFinally, the code displays a \u0026ldquo;Delete\u0026rdquo; button and attaches an onclick event handler to it.\nThe component has the following properties:\nId: An optional parameter that represents the ID of the record to be deleted.\nNavigateLinkAfterDelete: An optional parameter that specifies the URL to navigate to after the record is deleted.\nThe component also injects the following dependencies:\nIMapper: An object mapper that maps the model to the view model.\nNavigationManager: A service that provides navigation functionality.\nThe component has an OnInitializedAsync method that is called when the component is initialized. It retrieves the record with the specified ID from the service and maps it to the view model using the mapper.\nThe component also has a DeleteButtonClick method that is called when the delete button is clicked. It calls the service\u0026rsquo;s DeletebyIdAsync method to delete the record with the specified ID. If the deletion is successful, it navigates to the specified URL using the NavigationManager.\nUsing the Component:\n\u0026lt;BlazorAppGenericComponents.Components.Delete TModel=\u0026#34;BlogPost\u0026#34; TViewModel=\u0026#34;BlogPostViewModel\u0026#34; Id=\u0026#34;@id\u0026#34; NavigateLinkAfterDelete=\u0026#34;/BlogPost\u0026#34; /\u0026gt; Source Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppGenericComponents\n","date":"August 5, 2023","hero":"/dotnet/2023-08-05-blazor-generic-components/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-05-blazor-generic-components/","summary":"Blazor Generic Components We will explore a Blazor generic component that can be used for performing CRUD (Create, Read, Update, Delete) operations on a list of items. This component is designed to provide a reusable and efficient solution for displaying and managing data in a Blazor application.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .","tags":["Dotnet","Blazor Generic Components"],"title":"Blazor Generic Components"},{"categories":["Dotnet","Blazor Expose a Feed as RSS"],"contents":" Blazor Expose a Feed as RSS In this example, we will explore how to expose a feed as RSS using C# and the Blazor framework. We will create a controller that generates an RSS feed based on mock data.\nRSS (Really Simple Syndication): RSS is a web feed format used to publish frequently updated content, such as blog posts, news headlines, or podcasts. It allows users to subscribe to a website\u0026rsquo;s content and receive updates in a standardized format.\nSyndicationFeed: The SyndicationFeed class represents an RSS or Atom feed. It contains properties like title, description, author, categories, and a collection of SyndicationItem objects.\nSyndicationItem: The SyndicationItem class represents an individual item in an RSS or Atom feed. It contains properties like title, content, author, categories, and a link to the full article.\nRss20FeedFormatter: The Rss20FeedFormatter class is used to format a SyndicationFeed object as an RSS 2.0 feed.\nRSSController.cs RSSController inherits from ControllerBase. It exposes a single GET endpoint (/api/RSS) that returns an RSS feed.\nThe controller has a constructor that takes a MockData object as a parameter. This object is used to retrieve mock blog post data.\n[Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class RSSController : ControllerBase { private readonly MockData _mockData; public RSSController(MockData mockData) { _mockData = mockData; } [HttpGet] public IActionResult Get() { var output = new MemoryStream(); string xml; var Feeds = _mockData.GetAllBlogPosts(); List\u0026lt;SyndicationItem\u0026gt; items = new List\u0026lt;SyndicationItem\u0026gt;(); var feed = new SyndicationFeed(\u0026#34;RSS Feed Title\u0026#34;, \u0026#34;Feed Description\u0026#34;, new Uri(\u0026#34;https://localhost:5001/posts\u0026#34;)); // Set feed properties feed.ImageUrl = new Uri(\u0026#34;https://picsum.photos/600/400\u0026#34;); feed.Authors.Add(new SyndicationPerson(\u0026#34;asd@asd.com\u0026#34;, \u0026#34;asdname\u0026#34;, \u0026#34;https://picsum.photos/600/600\u0026#34;)); feed.BaseUri = new Uri(\u0026#34;https://localhost:5001\u0026#34;); feed.Categories.Add(new SyndicationCategory(\u0026#34;Feed Category 1 Base\u0026#34;)); feed.LastUpdatedTime = DateTime.Now; feed.Language = \u0026#34;Lang1\u0026#34;; feed.Copyright = new TextSyndicationContent(\u0026#34;Copy1\u0026#34;); // Create SyndicationItems for each blog post foreach (var post in Feeds) { var solutionfeed = new SyndicationItem(post.Title, post.Content, new Uri(quot;https://localhost:5001/postsingle/{post.Id}\u0026#34;), post.Id.ToString(), DateTime.Now); solutionfeed.Authors.Add(new SyndicationPerson(\u0026#34;post@user.com\u0026#34;, \u0026#34;postuser\u0026#34;, \u0026#34;https://picsum.photos/600/600\u0026#34;)); solutionfeed.BaseUri = new Uri(\u0026#34;https://localhost:5001/posts\u0026#34;); solutionfeed.Categories.Add(new SyndicationCategory(\u0026#34;Feed Category 1 feed\u0026#34;)); solutionfeed.Contributors.Add(new SyndicationPerson(\u0026#34;postCont@user.com\u0026#34;, \u0026#34;postcontuser\u0026#34;, \u0026#34;https://picsum.photos/600/600\u0026#34;)); solutionfeed.Copyright = new TextSyndicationContent(\u0026#34;feed copy\u0026#34;); solutionfeed.ElementExtensions.Add(new XElement(\u0026#34;enclosure\u0026#34;, new XAttribute(\u0026#34;type\u0026#34;, \u0026#34;\u0026#34;), new XAttribute(\u0026#34;url\u0026#34;, \u0026#34;https://picsum.photos/600/400\u0026#34;), new XAttribute(\u0026#34;width\u0026#34;, 200), new XAttribute(\u0026#34;height\u0026#34;, 200)).CreateReader()); solutionfeed.PublishDate = DateTime.Now; solutionfeed.Summary = new TextSyndicationContent(post.Content.Substring(0, 5)); items.Add(solutionfeed); } // Set the items collection of the feed feed.Items = items; // Create an Rss20FeedFormatter and write the feed to a MemoryStream var formatter = new Rss20FeedFormatter(feed); var xws = new XmlWriterSettings { Encoding = Encoding.UTF8 }; using (var xmlWriter = XmlWriter.Create(output, xws)) { formatter.WriteTo(xmlWriter); xmlWriter.Flush(); } // Read the generated XML from the MemoryStream using (var sr = new StreamReader(output)) { output.Position = 0; xml = sr.ReadToEnd(); sr.Close(); } // Return the XML as a ContentResult with the appropriate content type ContentResult result = Content(xml, \u0026#34;application/xml\u0026#34;, Encoding.UTF8); return result; } } The Get method is responsible for generating the RSS feed. Here\u0026rsquo;s a breakdown of the code:\nCreate a MemoryStream and a string variable to store the generated XML. Retrieve the mock blog post data using the MockData object. Create an empty list of SyndicationItem objects and a SyndicationFeed object. Set the properties of the feed, such as title, description, image URL, authors, categories, and last updated time. Iterate over each blog post and create a SyndicationItem for it. Set the properties of the item, such as title, content, link, author, categories, contributors, enclosure, publish date, and summary. Add the item to the list of items. Set the Items property of the feed to the list of items. Create an Rss20FeedFormatter and write the feed to the MemoryStream using an XmlWriter. Read the generated XML from the MemoryStream into the xml variable. Create a ContentResult with the XML as the content and the appropriate content type. Return the ContentResult. Source Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRSSFeed\n","date":"August 2, 2023","hero":"/dotnet/2023-08-02-blazor-rssfeed/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-08-02-blazor-rssfeed/","summary":"Blazor Expose a Feed as RSS In this example, we will explore how to expose a feed as RSS using C# and the Blazor framework. We will create a controller that generates an RSS feed based on mock data.\nRSS (Really Simple Syndication): RSS is a web feed format used to publish frequently updated content, such as blog posts, news headlines, or podcasts. It allows users to subscribe to a website\u0026rsquo;s content and receive updates in a standardized format.","tags":["Dotnet","Blazor Expose a Feed as RSS"],"title":"Blazor Expose a Feed as RSS"},{"categories":["Dotnet","EF Migrations with Multiple Providers"],"contents":" Blazor Blazor Entity Framework Migrations with Multiple Providers This code demonstrates how to implement multiple database providers in a Blazor application using C#. It allows you to switch between different database providers, such as InMemory, SQLite, and SQL Server, based on the configuration settings.\nDatabase Provider: Refers to the type of database being used, such as InMemory, SQLite, or SQL Server.\nConnection String: A string that contains the necessary information to connect to a specific database.\nEntity Framework: A popular object-relational mapping (ORM) framework that simplifies database access in .NET applications.\nMigrations: A way to manage database schema changes over time, allowing you to update the database structure without losing data.\nDependency Injection: A design pattern that allows objects to be created and managed by a separate container, making it easier to manage dependencies between different components of an application.\nProgram.cs The code consists of two main sections: the Main method and the ServiceCollectionExtensions class.\nIn the Main method:\nIt creates a WebApplication builder. It retrieves the active database provider from the configuration settings. If a provider is specified, it configures the services and connection string for that provider. If the provider is InMemory, it checks and creates the database. It adds necessary services to the container. It builds the application and runs it. In the ServiceCollectionExtensions class:\nIt defines an extension method ConfigureServices for the IServiceCollection interface. It configures the ApplicationDbContext based on the specified provider and connection string. It adds services for SeedData and BlogPostService. It configures AutoMapper for mapping between different models. It creates a mapper instance and adds it as a singleton service. Here are some code examples to illustrate the usage of the code:\nConfiguring the services for SQLite provider:\nservices.ConfigureServices(\u0026#34;Sqlite\u0026#34;, \u0026#34;Data Source=mydatabase.db\u0026#34;); Checking and creating the database:\nservices.CheckAndCreateDatabase(); Using the SeedData service to create initial data:\nvar seedData = serviceProvider.GetRequiredService\u0026lt;SeedData\u0026gt;(); await seedData.CreateInitialData(); appsettings.json The configuration settings for the Blazor application, including the database provider and connection strings.\n{ \u0026#34;DatabaseProvider\u0026#34;: \u0026#34;InMemory\u0026#34;, \u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;Sqlite\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;SqlServer\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Localdb\u0026#34;: \u0026#34;\u0026#34; }, DatabaseProvider: This property specifies the default database provider to be used by the Blazor application. In this example, the value is set to \u0026ldquo;InMemory\u0026rdquo;, which means an in-memory database will be used. You can replace this value with the desired database provider, such as \u0026ldquo;Sqlite\u0026rdquo; or \u0026ldquo;SqlServer\u0026rdquo;.\nConnectionStrings: This property contains a collection of connection strings for different database providers. In this example, three connection strings are provided: \u0026ldquo;Sqlite\u0026rdquo;, \u0026ldquo;SqlServer\u0026rdquo;, and \u0026ldquo;Localdb\u0026rdquo;. Each connection string specifies the necessary details to connect to the respective database provider.\nbuildschema.bat Creating a migration: dotnet ef migrations add Initial01 -c ApplicationDbContext --startup-project ./BlazorAppEFMultipleDBProviders --project ./AppMigrations/AppMigrations.Sqlite -- --DatabaseProvider Sqlite This command adds a new migration named \u0026ldquo;Initial01\u0026rdquo; to the specified context (ApplicationDbContext). It generates the migration files in the ./Migrations/Initial01 directory. The \u0026ndash;startup-project and \u0026ndash;project flags specify the startup project and the project containing the migration files, respectively. The \u0026ndash;DatabaseProvider Sqlite flag indicates that we are using the SQLite database provider.\nGenerating a SQL script for a migration: dotnet ef migrations script -c ApplicationDbContext -o ./AppMigrations/AppMigrations.Sqlite/Migrations/Initial01.sql --startup-project ./BlazorAppEFMultipleDBProviders --project ./AppMigrations/AppMigrations.Sqlite -- --DatabaseProvider Sqlite This command generates a SQL script for the migration named \u0026ldquo;Initial01\u0026rdquo;. The script is saved in the ./AppMigrations/AppMigrations.Sqlite/Migrations/Initial01.sql file. The flags have the same meaning as in the previous command.\nRunning the application with seeding: dotnet run --project ./BlazorAppEFMultipleDBProviders/BlazorAppEFMultipleDBProviders.csproj /seed This command runs the application, specifically the BlazorAppEFMultipleDBProviders.csproj project, with the /seed argument. This argument triggers the seeding of initial data into the database.\nConclusion Configuring multiple database providers in a Blazor application is essential when you need to work with different databases or switch between databases based on the environment. By using the provided JSON configuration, you can easily specify the desired database provider and connection strings for each provider. This flexibility allows your Blazor application to seamlessly interact with different databases, providing a robust and scalable solution.\nThis example demonstrates how to implement multiple database providers in a Blazor application using C#. By configuring the services and connection string based on the specified provider, you can easily switch between different databases. The code also shows how to use migrations and seed data to manage the database schema and initial data.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppEFMultipleDBProviders\n","date":"July 31, 2023","hero":"/dotnet/2023-07-31-blazor-ef-multipledbproviders/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-31-blazor-ef-multipledbproviders/","summary":"Blazor Blazor Entity Framework Migrations with Multiple Providers This code demonstrates how to implement multiple database providers in a Blazor application using C#. It allows you to switch between different database providers, such as InMemory, SQLite, and SQL Server, based on the configuration settings.\nDatabase Provider: Refers to the type of database being used, such as InMemory, SQLite, or SQL Server.\nConnection String: A string that contains the necessary information to connect to a specific database.","tags":["Dotnet","Blazor EF Migrations with Multiple Providers"],"title":"Blazor EF Migrations with Multiple Providers"},{"categories":["Dotnet","Blazor Authentication and Authorization"],"contents":" Blazor Authentication and Authorization This example represents a Blazor application that allows users to view a list of blog posts. The application uses ASP.NET Core and Blazor authentication and authorization to control access to the blog posts.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables developers to write code that runs on the client-side in the browser using WebAssembly or on the server-side using SignalR.\nASP.NET Core: ASP.NET Core is an open-source, cross-platform framework for building modern, cloud-based web applications. It provides a unified programming model for building web APIs, web UIs, and real-time applications.\nBlazor Authentication and Authorization: Blazor provides built-in support for authentication and authorization. It allows developers to secure their applications by restricting access to certain resources based on user roles or policies.\nRazor: Razor is a syntax for combining HTML markup with C# code in a single file. It is used in Blazor to create dynamic web UIs.\nThe code is structured as a Blazor component with a Razor markup file (.razor) and a code-behind file (.cs). The Razor markup file contains the HTML and Razor syntax for rendering the UI, while the code-behind file contains the C# code for handling events and data manipulation.\nList Posts (Index.razor) The code starts with the @page directive, which specifies the URL route for this component (\u0026quot;/BlogPost\u0026quot;). The @using directives import the necessary namespaces for using classes and services in the code.\nThe @inject directives are used to inject dependencies into the component. In this case, the IMapper, NavigationManager, and BlogPostService are injected. The IMapper is used for object mapping, the NavigationManager is used for navigation, and the BlogPostService is used for retrieving blog posts.\nThe \u0026lt;PageTitle\u0026gt; component sets the page title to \u0026ldquo;Index\u0026rdquo;.\nThe \u0026lt;AuthorizeView\u0026gt; component is used to control access to the content based on the user\u0026rsquo;s authorization. The Policy attribute specifies the policy required to access the content. Inside the \u0026lt;Authorized\u0026gt; block, the UI for displaying the list of blog posts is rendered.\nThe code checks if the blogPosts variable is null. If it is null, a loading message is displayed. Otherwise, a table is rendered with the blog post data. The @foreach loop iterates over each blog post in the blogPosts collection and displays the blog post\u0026rsquo;s ID, title, and content. The AuthorizeView component is used to conditionally render the edit and delete links based on the user\u0026rsquo;s authorization.\nThe \u0026lt;NotAuthorized\u0026gt; block is rendered when the user is not authorized to access the content.\nThe @code block contains the C# code for the component. The blogPosts variable is declared as an IEnumerable\u0026lt;BlogPostViewModel\u0026gt; and is initially set to null. The OnInitializedAsync method is overridden to retrieve the blog posts from the BlogPostService and map them to the BlogPostViewModel using the IMapper.\nCreate Post (Create.razor) Let\u0026rsquo;s take a look at some code examples to better understand how the blog post creation works:\nCreating the BlogPostViewModel:\nprivate BlogPostViewModel? blogPost; protected override void OnInitialized() { blogPost = new(); } In the OnInitialized method, we initialize the blogPost variable as a new instance of the BlogPostViewModel class. This class represents the data structure for the blog post.\nHandling the Valid Submit:\nprivate async void HandleValidSubmit() { var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.AddBlogPostAsync(model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } The HandleValidSubmit method is called when the user clicks the submit button. It maps the blogPost object to the BlogPost model using AutoMapper. Then, it calls the AddBlogPostAsync method of the BlogPostService to add the blog post to the database. If the operation is successful, the user is redirected to the \u0026ldquo;/BlogPost\u0026rdquo; page.\nPost Detail (Details.razor) Here are some key code examples from the Blazor BlogPost Details page:\nRetrieving the blog post data:\nprotected override async Task OnInitializedAsync() { if (blogPost == null) { var result = await BlogPostService.GetbyId(id); if (result != null) blogPost = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(result); } } In the OnInitializedAsync method, the blog post data is retrieved from the server using the BlogPostService.GetbyId method. If the result is not null, the data is mapped to a BlogPostViewModel object using AutoMapper and assigned to the blogPost variable.\nDisplaying the blog post details:\n\u0026lt;dl class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Id) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Id \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Title) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Title \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Content) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Content \u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; The blog post details are displayed using an HTML definition list (\u0026lt;dl\u0026gt;) with rows and columns. The @nameof directive is used to get the name of the properties of the BlogPost class, and the @blogPost variable is used to display the corresponding values.\nEdit Post (Edit.razor) Here are some code examples from the provided code:\nBinding the blogPost.Title property to an input field:\n\u0026lt;InputText @bind-Value=\u0026#34;blogPost.Title\u0026#34; class=\u0026#34;form-control\u0026#34; /\u0026gt; Handling the form submission and updating the blog post:\nprivate async void HandleValidSubmit() { var model = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPost); bool result = await BlogPostService.UpdateBlogPostAsync(id, model); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } Delete Post (Delete.razor) Let\u0026rsquo;s take a closer look at some code examples to understand the implementation:\nDelete Confirmation:\n\u0026lt;h3\u0026gt;Are you sure you want to delete this?\u0026lt;/h3\u0026gt; Blog Post Details:\n\u0026lt;dl class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Id) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Id \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Title) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Title \u0026lt;/dd\u0026gt; \u0026lt;dt class=\u0026#34;col-sm-2\u0026#34;\u0026gt; @nameof(BlogPost.Content) \u0026lt;/dt\u0026gt; \u0026lt;dd class=\u0026#34;col-sm-10\u0026#34;\u0026gt; @blogPost.Content \u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; Delete Button:\n\u0026lt;button class=\u0026#34;btn btn-danger\u0026#34; @onclick=\u0026#34;DeleteButtonClick\u0026#34;\u0026gt;Delete\u0026lt;/button\u0026gt; | \u0026lt;a href=\u0026#34;/BlogPost\u0026#34;\u0026gt;Back to List\u0026lt;/a\u0026gt; Source Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppAuth\n","date":"July 30, 2023","hero":"/dotnet/2023-07-30-blazor-authentication-authorization/blazor_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-30-blazor-authentication-authorization/","summary":"Blazor Authentication and Authorization This example represents a Blazor application that allows users to view a list of blog posts. The application uses ASP.NET Core and Blazor authentication and authorization to control access to the blog posts.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables developers to write code that runs on the client-side in the browser using WebAssembly or on the server-side using SignalR.","tags":["Dotnet","Blazor Authentication and Authorization"],"title":"Blazor Authentication and Authorization"},{"categories":["Dotnet","Blazor Radzen CRUD"],"contents":" Blazor Radzen CRUD In this article, we will explore the code for a Blazor page called \u0026ldquo;BlogPost\u0026rdquo;. This page displays a list of blog posts using a RadzenDataGrid component. We will go through the key concepts, code structure, and code examples to understand how this page works.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor and RadzenDataGrid:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables the development of single-page applications (SPAs) with the power of .NET.\nRadzenDataGrid: RadzenDataGrid is a component provided by Radzen, a popular UI component library for Blazor. It is used to display tabular data with features like sorting, filtering, and paging.\nAutoMapper: AutoMapper is a library used for object-to-object mapping. It simplifies the mapping process between different object types by automatically mapping properties with matching names.\nBlogPostViewModel: BlogPostViewModel is a class that represents the data model for the blog post form. It contains properties for the title and content of the blog post.\nBlogPostService: BlogPostService is a service class responsible for handling CRUD operations related to blog posts. It provides methods for adding, updating, deleting, and retrieving blog posts from the database.\nNavigationManager: NavigationManager is a Blazor service that provides navigation functionality. It allows us to navigate to different pages within the application.\nThe code provided represents the \u0026quot;BlogPost\u0026quot; page in a Blazor application. Let\u0026rsquo;s break down the code structure and understand its different sections:\nPage Directive: The @page \u0026quot;/BlogPost\u0026quot; directive specifies the URL route for this page. It means that when the user navigates to \u0026ldquo;/BlogPost\u0026rdquo;, this page will be displayed.\nPage Directive: The @page directive specifies the URL route for this page. In this case, the page is accessible at \u0026ldquo;/BlogPost/Create\u0026rdquo;.\nRadzenDataGrid Component: The main component on this page is the RadzenDataGrid. It is configured with various properties and columns to display the blog post data.\nUsing Directives: The @using directives import the necessary namespaces for the code to work correctly. We import the AutoMapper, BlazorAppRadzenCRUD.Data, BlazorAppRadzenCRUD.Models, and BlazorAppRadzenCRUD.Services namespaces.\nDependency Injection: The @inject directives inject the required services into the page. We inject the IMapper, NavigationManager, and BlogPostService services.\nPage Content: The page content is wrapped in a \u0026lt;RadzenStack\u0026gt; component, which provides a vertical stack layout for the elements.\nLoading Indicator: If the blogPostViewModel is null, a loading message is displayed. This is useful when the page is still initializing and fetching data.\nBlog Post Form: Once the blogPostViewModel is populated, the blog post form is rendered. The form is wrapped in an \u0026lt;EditForm\u0026gt; component, which handles form validation and submission.\nForm Fields: The form contains two fields: title and content. Each field is wrapped in a \u0026lt;RadzenRow\u0026gt; component, which represents a row in the form layout. The \u0026lt;RadzenColumn\u0026gt; components define the size of the columns within the row.\nInput Fields: The \u0026lt;InputText\u0026gt; components represent the input fields for the title and content. The @bind-Value attribute binds the input field to the corresponding property in the blogPostViewModel.\nValidation: The \u0026lt;DataAnnotationsValidator\u0026gt; and \u0026lt;ValidationSummary\u0026gt; components handle form validation. They display error messages if the user enters invalid data.\nSave Button: The \u0026lt;RadzenButton\u0026gt; component represents the save button. It triggers the form submission when clicked and has a success style.\nBack Button: The \u0026lt;RadzenButton\u0026gt; component represents the back button. It navigates the user back to the blog post index page when clicked.\nCode Block: The @code block contains the C# code for the page. It defines the blogPostViewModel property, initializes it in the OnInitialized method, and handles the form submission and navigation.\nList Posts (Index.razor) Now, let\u0026rsquo;s take a closer look at some important code examples from the provided code:\nLoading Data: private async Task LoadData(LoadDataArgs args) { isLoading = true; var result = await BlogPostService.GetBlogPostsAsync(filter: args.Filter, top: args.Top, skip: args.Skip, orderby: args.OrderBy, count: true); blogPosts = Mapper.Map\u0026lt;IEnumerable\u0026lt;BlogPost\u0026gt;, IEnumerable\u0026lt;BlogPostViewModel\u0026gt;\u0026gt;(result.Result); totalCount = result.TotalCount; isLoading = false; } The LoadData method is responsible for loading the blog post data. It is called when the RadzenDataGrid needs to fetch new data, such as when the user changes the page or applies filters. It makes an asynchronous call to the BlogPostService.GetBlogPostsAsync method to retrieve the data. The result is then mapped to a collection of BlogPostViewModel objects using the Mapper class. Finally, the isLoading flag is updated to indicate the loading state.\nNavigation Methods: private void NavigatetoCreate() =\u0026gt; NavigationManager.NavigateTo(\u0026#34;/BlogPost/Create\u0026#34;); private void NavigatetoDetail(int id) =\u0026gt; NavigationManager.NavigateTo(quot;/BlogPost/Detail/{id}\u0026#34;); private void NavigatetoEdit(int id) =\u0026gt; NavigationManager.NavigateTo(quot;/BlogPost/Edit/{id}\u0026#34;); private void NavigatetoDelete(int id) =\u0026gt; NavigationManager.NavigateTo(quot;/BlogPost/Delete/{id}\u0026#34;); These methods handle the navigation to different pages related to the blog posts. For example, NavigatetoCreate navigates to the page for creating a new blog post, NavigatetoDetail navigates to the page for viewing the details of a specific blog post, and so on. The NavigationManager class is used to perform the navigation by specifying the desired URL.\nCreate Post (Create.razor) Here are some code examples to illustrate the concepts discussed above:\nMapping the BlogPostViewModel to BlogPost:\nvar blogPost = Mapper.Map\u0026lt;BlogPostViewModel, BlogPost\u0026gt;(blogPostViewModel); In this example, we use AutoMapper to map the properties of the blogPostViewModel to the corresponding properties of the BlogPost model.\nAdding a new blog post:\nbool result = await BlogPostService.AddBlogPostAsync(blogPost); Here, we call the AddBlogPostAsync method of the BlogPostService to add the new blog post to the database. The method returns a boolean value indicating the success of the operation.\nNavigating to the blog post index page:\nNavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); This code snippet uses the NavigationManager to navigate the user back to the blog post index page (\u0026quot;/BlogPost\u0026quot;) after a successful save operation.\nPost Detail (Detail.razor) Here is an example of how the code retrieves the blog post data and maps it to the view model:\nprotected override async Task OnInitializedAsync() { if (blogPostViewModel == null) { var blogPost = await BlogPostService.GetbyId(id); if (blogPost == null) return; blogPostViewModel = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(blogPost); } } In this example, the GetbyId method of the BlogPostService is called to retrieve the blog post data based on the provided ID. If the blog post is found, it is then mapped to the BlogPostViewModel using AutoMapper.\nEdit Post (Edit.razor) Here are some key code examples from the provided code:\nBinding the input fields to the blogPostViewModel properties:\n\u0026lt;InputText id=\u0026#34;title\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;Title\u0026#34; @bind-Value=\u0026#34;blogPostViewModel.Title\u0026#34; /\u0026gt; The @bind-Value directive binds the value of the input field to the Title property of the blogPostViewModel.\nHandling the form submission:\n\u0026lt;EditForm Context=\u0026#34;editFormEdit\u0026#34; Model=\u0026#34;@blogPostViewModel\u0026#34; OnValidSubmit=\u0026#34;HandleValidSubmit\u0026#34;\u0026gt; ... \u0026lt;RadzenButton Text=\u0026#34;Save\u0026#34; Icon=\u0026#34;save\u0026#34; ButtonType=\u0026#34;ButtonType.Submit\u0026#34; ButtonStyle=\u0026#34;ButtonStyle.Success\u0026#34; /\u0026gt; \u0026lt;/EditForm\u0026gt; The OnValidSubmit event handler is triggered when the form is submitted and passes the form data to the HandleValidSubmit method.\nNavigating to the blog post index page:\nprivate void NavigatetoBlogPostIndex() =\u0026gt; NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); The NavigatetoBlogPostIndex method uses the NavigationManager service to navigate to the blog post index page.\nDelete Post (Delete.razor) The code example provided includes the following key components:\nRetrieving the Blog Post Details:\nprotected override async Task OnInitializedAsync() { if (blogPostViewModel == null) { var blogPost = await BlogPostService.GetbyId(id); if (blogPost == null) return; blogPostViewModel = Mapper.Map\u0026lt;BlogPost, BlogPostViewModel\u0026gt;(blogPost); } } This method is executed when the page is initialized. It retrieves the blog post details using the BlogPostService and maps the retrieved BlogPost object to a BlogPostViewModel object using AutoMapper. The blogPostViewModel property is then set to the mapped object.\nDeleting the Blog Post:\nprivate async void RemoveButtonClick() { bool result = await BlogPostService.DeletebyIdAsync(id); if (result) NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); } This method is called when the \u0026ldquo;REMOVE\u0026rdquo; button is clicked. It calls the DeletebyIdAsync method of the BlogPostService to delete the blog post with the specified ID. If the deletion is successful, the user is redirected to the blog post index page using the NavigationManager.\nNavigating to the Blog Post Index Page:\nprivate void NavigatetoBlogPostIndex() =\u0026gt; NavigationManager.NavigateTo(\u0026#34;/BlogPost\u0026#34;); This method is called when the \u0026ldquo;Back\u0026rdquo; button is clicked. It uses the NavigationManager to navigate to the blog post index page.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenCRUD\n","date":"July 26, 2023","hero":"/dotnet/2023-07-26-blazor-radzen-crud/blazor_radzen_dotnet.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-26-blazor-radzen-crud/","summary":"Blazor Radzen CRUD In this article, we will explore the code for a Blazor page called \u0026ldquo;BlogPost\u0026rdquo;. This page displays a list of blog posts using a RadzenDataGrid component. We will go through the key concepts, code structure, and code examples to understand how this page works.\nBefore diving into the code, let\u0026rsquo;s understand some key concepts related to Blazor and RadzenDataGrid:\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript.","tags":["Dotnet","Blazor Radzen CRUD"],"title":"Blazor Radzen CRUD"},{"categories":["Dotnet","Blazor Radzen SearchComponent"],"contents":" Blazor Radzen SearchComponent 1. Blazor Radzen List Page The code provided is a Blazor component that demonstrates how to fetch data from a service and display it in a RadzenDataList component. It also includes a custom search component that allows users to search for specific blog posts.\nBlazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code in C# that runs on the client-side, eliminating the need for JavaScript. Radzen: Radzen is a set of UI components for Blazor that provides pre-built components for building responsive and interactive web applications. RadzenDataList: RadzenDataList is a component from the Radzen UI library that displays a list of items in a grid-like format. It supports features like paging, sorting, and filtering. RadzenCard: RadzenCard is a component from the Radzen UI library that displays content in a card-like format. It provides a visually appealing way to present data. ComponentSearch: ComponentSearch is a custom search component that allows users to search for specific blog posts. It triggers the search functionality when the user clicks the search button. BlogPostService: BlogPostService is a service that provides methods for fetching blog post data from a backend API. The code starts with the@pagedirective, which specifies the URL route for this component. In this case, the component is accessible at \u0026ldquo;/fetchdata\u0026rdquo;.\nThe code then includes the necessary@usingdirectives to import the required namespaces and inject theBlogPostServiceinto the component. The component\u0026rsquo;s markup is defined within the\u0026lt;PageTitle\u0026gt;tag. It starts with an\u0026lt;h1\u0026gt;heading that displays the title \u0026ldquo;Blogposts\u0026rdquo; followed by a paragraph explaining the purpose of the component.\nNext, a\u0026lt;RadzenCard\u0026gt;component is used to wrap the search component. The search component is a custom component calledComponentSearchthat is defined in a separate file. It is injected into the component using the@usingdirective and itsSearchButtonClickevent is bound to theSearchButtonClickmethod in the code section.\nAfter the search component, a\u0026lt;RadzenDataList\u0026gt;component is used to display the list of blog posts. It is configured with various properties likeWrapItems,AllowPaging,IsLoading,LoadData,Data,Count,TItem,PageSize,PagerHorizontalAlign, andShowPagingSummary. These properties control the behavior and appearance of the data list.\nInside the\u0026lt;RadzenDataList\u0026gt;, a\u0026lt;Template\u0026gt;component is used to define the layout of each item in the list. It contains a\u0026lt;RadzenCard\u0026gt;component that displays the blog post details in a card-like format. The details include the blog post ID, title, and content.\nThe code section contains the C# code that handles the data loading and search functionality. It defines various private fields and properties likeitemPageSize,totalCount,isLoading,currentArgs,blogposts,search, andsearchProperty.\nTheLoadDatamethod is responsible for fetching the blog post data from theBlogPostServicebased on the provided arguments. It sets theisLoadingflag to true, assigns the current arguments, and calls theGetBlogPostsbyPageAsyncmethod of theBlogPostService. It then assigns the result to theblogpostsfield and updates thetotalCountfield. Finally, it sets theisLoadingflag to false.\nTheSearchButtonClickmethod is triggered when the user clicks the search button in the custom search component. It updates thesearchfield with the provided search value and calls theLoadDatamethod to reload the data with the updated search value.\nHere is an example of how to use theRadzenDataListcomponent in a Blazor application:\n\u0026lt;RadzenDataList Data=\u0026#34;@blogposts\u0026#34; PageSize=\u0026#34;10\u0026#34; AllowPaging=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;Template Context=\u0026#34;blogpost\u0026#34;\u0026gt; \u0026lt;div\u0026gt;@blogpost.Title\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;@blogpost.Content\u0026lt;/div\u0026gt; \u0026lt;/Template\u0026gt; \u0026lt;/RadzenDataList\u0026gt; In this example, theRadzenDataListcomponent is bound to a collection ofblogpostsand is configured to display 10 items per page with paging enabled. The\u0026lt;Template\u0026gt;component is used to define the layout of each item in the list, displaying the title and content of each blog post.\nThe provided code demonstrates how to fetch data from a service and display it in a Blazor component using the Radzen UI library. It also includes a custom search component for filtering the data based on user input. By understanding the key concepts and code structure, you can leverage this code to build similar functionality in your own Blazor applications.\n2. Blazor Radzen Search Component Here is an example of how the search component can be used in a Blazor application:\n\u0026lt;SearchComponent SearchButtonClick=\u0026#34;HandleSearch\u0026#34; /\u0026gt; @code { private async Task HandleSearch(string searchValue) { // Perform search logic here // Example: Call an API endpoint with the search query await SearchService.Search(searchValue); } } In the above example, theSearchComponentis used with theSearchButtonClickevent callback. When the user clicks the search button, theHandleSearchmethod is invoked. Inside theHandleSearchmethod, you can implement the search logic, such as calling an API endpoint with the search query.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppRadzenSearch\n","date":"July 21, 2023","hero":"/dotnet/2023-07-21-blazor-radzen-searchcomponent/blazor_radzen_searchcomponent.jpg","permalink":"https://akifmt.github.io/dotnet/2023-07-21-blazor-radzen-searchcomponent/","summary":"Blazor Radzen SearchComponent 1. Blazor Radzen List Page The code provided is a Blazor component that demonstrates how to fetch data from a service and display it in a RadzenDataList component. It also includes a custom search component that allows users to search for specific blog posts.\nBlazor: Blazor is a web framework for building interactive client-side web applications using C# instead of JavaScript. It allows developers to write code in C# that runs on the client-side, eliminating the need for JavaScript.","tags":["Dotnet","Blazor Radzen SearchComponent"],"title":"Blazor Radzen Search Comp."},{"categories":["Dotnet","Blazor Plyr Video Player"],"contents":" Blazor Plyr Video Player This code provides a video player component in a Blazor application. It allows users to watch videos with controls and captions. The video player is customizable using the Plyr.io library.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET. Plyr.io: Plyr.io is a JavaScript library that provides a customizable video player with a modern UI. It supports various features like controls, captions, and responsive design.\nThe code is structured as a Blazor component with a Razor markup file (.razor) and a code-behind file (.razor.cs). The Razor markup file defines the UI elements and the code-behind file contains the logic for the component.\nThe code uses the @page directive to define the URL routes for the component. It injects the IJSRuntime service to interact with JavaScript code.\nThe video variable is used to store the selected video. If the video is null, a loading message is displayed. Otherwise, the video player is rendered with the Plyr.io library.\nThe code dynamically generates \u0026lt;source\u0026gt; elements for the video files and \u0026lt;track\u0026gt; elements for the captions. It also provides a fallback download link for browsers that don\u0026rsquo;t support the \u0026lt;video\u0026gt; element.\nThe OnInitializedAsync method is called when the component is initialized. It retrieves the video based on the Id parameter from the Data.VideosData.Videos collection.\nThe OnAfterRenderAsync method is called after the component has been rendered. It loads a custom video player using JavaScript interop. The LoadCustomPlayer function is invoked from a JavaScript file located in the ./js/components/video.js path.\nThe provided code demonstrates how to create a video player component in a Blazor application using the Plyr.io library. It allows users to watch videos with controls and captions. The code can be customized further to meet specific requirements and integrate additional features.\nSource Full source code is available at this repository in GitHub:\nhttps://github.com/akifmt/DotNetCoding/tree/main/src/BlazorAppVideoPlayer\n","date":"July 20, 2023","hero":"/dotnet/2023-07-20-blazor-plyr-video-player/blazor_plyr.png","permalink":"https://akifmt.github.io/dotnet/2023-07-20-blazor-plyr-video-player/","summary":"Blazor Plyr Video Player This code provides a video player component in a Blazor application. It allows users to watch videos with controls and captions. The video player is customizable using the Plyr.io library.\nBlazor: Blazor is a web framework that allows developers to build interactive web UIs using C# instead of JavaScript. It enables full-stack development with .NET. Plyr.io: Plyr.io is a JavaScript library that provides a customizable video player with a modern UI.","tags":["Dotnet","Blazor Plyr Video Player"],"title":"Blazor Plyr Video Player"},{"categories":["Programming","OOP"],"contents":" Programming A programming language is a formal computer language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs to control the behavior of a machine or to express algorithms. (Source: wikipedia)\nObject Oriented Programming(OOP) Object Oriented Programming(OOP) is a programming paradigm based on the concept of objects, which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.\nEncapsulation Abstraction Inheritance Polymorphism There are five principles when design a class.\nSRP (The Single Responsibility Principle) A class should have one, and only one, reason to change. OCP (The Open Closed Principle) Should be able to extend any classes\u0026rsquo; behaviors, without modifying the classes.. LSP (The Liskov Substitution Principle) Derived classes must be substitutable for their base classes. ISP (The Interface Segregation Principle) Make fine grained interfaces that are client specific. DIP (The Dependency Inversion Principle) Depend on abstractions, not on concretions. What is Encapsulation (or Information Hiding)? The encapsulation is the inclusion-within a program object-of all the resources needed for the object to function, basically, the methods and the data. In OOP the encapsulation is mainly achieved by creating classes, the classes expose public methods and properties. A class is kind of a container or capsule or a cell, which encapsulate a set of methods, attribute and properties to provide its indented functionalities to other classes. In that sense, encapsulation also allows a class to change its internal implementation without hurting the overall functioning of the system. That idea of encapsulation is to hide how a class does its business, while allowing other classes to make requests of it.\nIn order to modularize/ define the functionality of a one class, that class can uses functions or properties exposed by another class in many different ways. According to Object Oriented Programming there are several techniques classes can use to link with each other. Those techniques are named association, aggregation, and composition.\nAssociation A relationship where all objects have their own lifecycle and there is no owner.\nAggregation A specialised form of Association where all objects have their own lifecycle, but there is ownership and child objects can not belong to another parent object.\nComposition A specialised form of Aggregation and we can call this as a death relationship. It is a strong type of Aggregation. Child object does not have its lifecycle and if parent object is deleted, all child objects will also be deleted.\nAbstraction Abstraction is an emphasis on the idea, qualities and properties rather than the particulars (a suppression of detail). The importance of abstraction is derived from its ability to hide irrelevant details and from the use of names to reference objects. Abstraction is essential in the construction of programs. It places the emphasis on what an object is or does rather than how it is represented or how it works. Thus, it is the primary means of managing complexity in large programs.\nGeneralization Generalization is the broadening of application to encompass a larger domain of objects of the same or different type. Programming languages provide generalization through variables, parameterization, generics and polymorphism. It places the emphasis on the similarities between objects. Thus, it helps to manage complexity by collecting individuals into groups and providing a representative which can be used to specify any individual of the group.\nAbstraction and generalization are often used together. Abstracts are generalized through parameterization to provide greater utility. In parameterization, one or more parts of an entity are replaced with a name which is new to the entity. The name is used as a parameter. When the parameterized abstract is invoked, it is invoked with a binding of the parameter to an argument.\n","date":"July 1, 2023","hero":"/posts/2023-07-01-programming/blog18_Programming.jpg","permalink":"https://akifmt.github.io/posts/2023-07-01-programming/","summary":"Programming A programming language is a formal computer language designed to communicate instructions to a machine, particularly a computer. Programming languages can be used to create programs to control the behavior of a machine or to express algorithms. (Source: wikipedia)\nObject Oriented Programming(OOP) Object Oriented Programming(OOP) is a programming paradigm based on the concept of objects, which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods.","tags":["Programming","OOP"],"title":"Programming"},{"categories":["IIS","Node.js","Deployment","Release","iisnode"],"contents":"\nNode.js Deployment and Publishing on IIS - iisnode\nTested on Windows Server 2016 x64 and IIS 10.0. All the requirements for different versions are the same, only the appropriate version for iisnode should be installed.\nRequirements:\nWebPlatformInstaller: WebPlatformInstaller IIS URL Rewrite extension: IIS URL Rewrite extension Node.js: node.js iisnode v0.22.1 x64 : iisnode v0.22.1 x64 After installation, the project should have \u0026ldquo;web.config\u0026rdquo;. The following config example can also be used with Express Framework. The app will be started with server.js. Outputs in the console can be checked from the folder specified with logDirectory. The debug sections in the \u0026ldquo;config\u0026rdquo; should be updated when going to the \u0026ldquo;production\u0026rdquo; phase.\n\u0026lt;configuration\u0026gt; \u0026lt;system.webServer\u0026gt; \u0026lt;httpErrors existingResponse=\u0026#34;PassThrough\u0026#34; /\u0026gt; \u0026lt;handlers\u0026gt; \u0026lt;add name=\u0026#34;iisnode\u0026#34; path=\u0026#34;server.js\u0026#34; verb=\u0026#34;*\u0026#34; modules=\u0026#34;iisnode\u0026#34; /\u0026gt; \u0026lt;/handlers\u0026gt; \u0026lt;iisnode node_env=\u0026#34;%node_env%\u0026#34; nodeProcessCountPerApplication=\u0026#34;1\u0026#34; maxConcurrentRequestsPerProcess=\u0026#34;1024\u0026#34; maxNamedPipeConnectionRetry=\u0026#34;100\u0026#34; namedPipeConnectionRetryDelay=\u0026#34;250\u0026#34; maxNamedPipeConnectionPoolSize=\u0026#34;512\u0026#34; maxNamedPipePooledConnectionAge=\u0026#34;30000\u0026#34; asyncCompletionThreadCount=\u0026#34;0\u0026#34; initialRequestBufferSize=\u0026#34;4096\u0026#34; maxRequestBufferSize=\u0026#34;65536\u0026#34; watchedFiles=\u0026#34;*.js;iisnode.yml\u0026#34; uncFileChangesPollingInterval=\u0026#34;5000\u0026#34; gracefulShutdownTimeout=\u0026#34;60000\u0026#34; loggingEnabled=\u0026#34;true\u0026#34; logDirectory=\u0026#34;C:\\Logs\u0026#34; debuggingEnabled=\u0026#34;true\u0026#34; debugHeaderEnabled=\u0026#34;false\u0026#34; debuggerPortRange=\u0026#34;5058-6058\u0026#34; debuggerPathSegment=\u0026#34;debug\u0026#34; maxLogFileSizeInKB=\u0026#34;128\u0026#34; maxTotalLogFileSizeInKB=\u0026#34;1024\u0026#34; maxLogFiles=\u0026#34;20\u0026#34; devErrorsEnabled=\u0026#34;true\u0026#34; flushResponse=\u0026#34;false\u0026#34; enableXFF=\u0026#34;false\u0026#34; promoteServerVars=\u0026#34;\u0026#34; configOverrides=\u0026#34;iisnode.yml\u0026#34; /\u0026gt; \u0026lt;rewrite\u0026gt; \u0026lt;rules\u0026gt; \u0026lt;rule name=\u0026#34;rulename\u0026#34;\u0026gt; \u0026lt;match url=\u0026#34;/*\u0026#34; /\u0026gt; \u0026lt;action type=\u0026#34;Rewrite\u0026#34; url=\u0026#34;server.js\u0026#34; /\u0026gt; \u0026lt;/rule\u0026gt; \u0026lt;/rules\u0026gt; \u0026lt;/rewrite\u0026gt; \u0026lt;/system.webServer\u0026gt; \u0026lt;/configuration\u0026gt; ","date":"August 8, 2019","hero":"/posts/2019-08-08-iisnode.js/blog17_IISNodejs.png","permalink":"https://akifmt.github.io/posts/2019-08-08-iisnode.js/","summary":"Node.js Deployment and Publishing on IIS - iisnode\nTested on Windows Server 2016 x64 and IIS 10.0. All the requirements for different versions are the same, only the appropriate version for iisnode should be installed.\nRequirements:\nWebPlatformInstaller: WebPlatformInstaller IIS URL Rewrite extension: IIS URL Rewrite extension Node.js: node.js iisnode v0.22.1 x64 : iisnode v0.22.1 x64 After installation, the project should have \u0026ldquo;web.config\u0026rdquo;. The following config example can also be used with Express Framework.","tags":["IIS","Node.js","Deployment","Publish","iisnode"],"title":"Node.js Deployment and Publishing on IIS - iisnode"},{"categories":["NodeJS","Different","Versions","Together","Using"],"contents":"\nCombining NodeJS Versions;\n# Setup: npm install -g nvmw # nvmw install nvmw install v8.12.0 # installation of the versions to be used nvmw use v8.12.0 # Use the specific version # Use: nvmw help # help nvmw install [version] # Version install [version] nvmw uninstall [version] # Uninstall version [version] nvmw use [version] # Change version [version] nvmw ls # List of installed versions NodeJS Releases List: Versions\nNPM: NPM Link\nGithub: Github Link\n","date":"February 10, 2019","hero":"/posts/2019-02-10-nodejsfarklisurumleribiraradakullanma/blog16_NodeJSFarkliSurumleriBiraradaKullanma.png","permalink":"https://akifmt.github.io/posts/2019-02-10-nodejsfarklisurumleribiraradakullanma/","summary":"Combining NodeJS Versions;\n# Setup: npm install -g nvmw # nvmw install nvmw install v8.12.0 # installation of the versions to be used nvmw use v8.12.0 # Use the specific version # Use: nvmw help # help nvmw install [version] # Version install [version] nvmw uninstall [version] # Uninstall version [version] nvmw use [version] # Change version [version] nvmw ls # List of installed versions NodeJS Releases List: Versions","tags":["NodeJS","Different","Versions","Together","Using"],"title":"Combining NodeJS Versions"},{"categories":["Google","Cloud","Ubuntu",16.04,"VNC","Server"],"contents":"\nVNC Server on Google Cloud Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade # Setup: sudo apt install xfce4 xfce4-goodies tightvncserver vncserver vncserver -kill :1 mv ~/.vnc/xstartup ~/.vnc/xstartup.bak nano ~/.vnc/xstartup xstartup content: #!/bin/bash xrdb $HOME/.Xresources startxfce4 \u0026amp; sudo chmod +x ~/.vnc/xstartup vncserver To connect via Windows: Download link\n","date":"September 21, 2017","hero":"/posts/2017-09-21-googlecloudubuntuvnc/blog15_GoogleCloudUbuntuVNC.jpg","permalink":"https://akifmt.github.io/posts/2017-09-21-googlecloudubuntuvnc/","summary":"VNC Server on Google Cloud Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade # Setup: sudo apt install xfce4 xfce4-goodies tightvncserver vncserver vncserver -kill :1 mv ~/.vnc/xstartup ~/.vnc/xstartup.bak nano ~/.vnc/xstartup xstartup content: #!/bin/bash xrdb $HOME/.Xresources startxfce4 \u0026amp; sudo chmod +x ~/.vnc/xstartup vncserver To connect via Windows: Download link","tags":["Google","Cloud","Ubuntu",16.04,"VNC","Server"],"title":"VNC Server on Google Cloud Ubuntu"},{"categories":["Torch","OpenCV Installation and Testing"],"contents":"\nOpenCV and Torch installation on Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade shutdown -r 0 sudo apt-get install git #Torch Installation #Run in terminal in order: git clone https://github.com/torch/distro.git ~/torch --recursive cd ~/torch; bash install-deps; ./install.sh source ~/.bashrc source ~/.profile #OpenCV Installation: sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev 2015-12-21 VERSION 3.1 OpenCV for Linux/Mac cd ~ wget https://github.com/Itseez/opencv/archive/3.1.0.zip --no-check-certificate unzip 3.1.0.zip cd opencv-3.1.0 mkdir build cd build cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_V4L=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D WITH_QT=ON -D WITH_GTK=ON -D WITH_OPENGL=ON .. make sudo make install While in the openCV build folder; source ~/.profile luarocks install cv luarocks install camera luarocks install ffmpeg /// If a luarocks package installation error occurs, run the following line to fix it and install the packages again: /// sudo rm -rf ~/.cache/luarocks IDE: Download link\nKurulumu Test etmek iin: Download link , Github link\n","date":"May 27, 2017","hero":"/posts/2017-05-27-torchveopencvkurulum/blog14_torchVeopenCVKurulum.png","permalink":"https://akifmt.github.io/posts/2017-05-27-torchveopencvkurulum/","summary":"OpenCV and Torch installation on Ubuntu 16.04;\n# Updates: sudo apt-get update sudo apt-get upgrade shutdown -r 0 sudo apt-get install git #Torch Installation #Run in terminal in order: git clone https://github.com/torch/distro.git ~/torch --recursive cd ~/torch; bash install-deps; ./install.sh source ~/.bashrc source ~/.profile #OpenCV Installation: sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev 2015-12-21 VERSION 3.1 OpenCV for Linux/Mac cd ~ wget https://github.com/Itseez/opencv/archive/3.1.0.zip --no-check-certificate unzip 3.1.0.zip cd opencv-3.","tags":["Torch","OpenCV Installation and Testing"],"title":"Torch, OpenCV Installation and Test"},{"categories":["epub calibre"],"contents":"\nThe cover pages of some e-books do not appear on other devices due to incompatibility. The solution for this is caliber. It provides the opportunity to edit not only the cover page but also the content. Download link\nTo edit the cover page; It will be enough to edit the following line with the \u0026ldquo;Edit Metadata\u0026rdquo; option or add it if it does not exist.\n\u0026lt;item id=\u0026#34;cover_image\u0026#34; href=\u0026#34;cover.jpg\u0026#34; media-type=\u0026#34;image/jpeg\u0026#34;\u0026gt; ","date":"May 2, 2017","hero":"/posts/2017-05-02-epubcover/blog13_epub.png","permalink":"https://akifmt.github.io/posts/2017-05-02-epubcover/","summary":"\nThe cover pages of some e-books do not appear on other devices due to incompatibility. The solution for this is caliber. It provides the opportunity to edit not only the cover page but also the content. Download link\nTo edit the cover page; It will be enough to edit the following line with the \u0026ldquo;Edit Metadata\u0026rdquo; option or add it if it does not exist.\n\u0026lt;item id=\u0026#34;cover_image\u0026#34; href=\u0026#34;cover.jpg\u0026#34; media-type=\u0026#34;image/jpeg\u0026#34;\u0026gt; ","tags":["epub calibre"],"title":"Edit EPub Cover"},{"categories":["Game Theory","Prisoner Dilemma","Nash Equilibrium"],"contents":"\nGet two people caught. If one testifies against the other and the other remains silent, the witness will be released, and the party who chooses to remain silent will be sentenced to 20 years in prison. If both remain silent, they will be sentenced to 1 year each. If both testify against each other, they will each be sentenced to 5 years.\nThe optimal option of the two is to keep both silent. The player, who is unaware of the other party\u0026rsquo;s decision, will not remain silent and will testify against the other party, not risking the possibility of serving 20 years in prison. By testifying against the other party, he will consent to a shorter prison sentence of 5 years or be released. Here the player will aim at minimizing his loss (maximizing his win). It will be inevitable that the other party will testify by acting rationally under the same conditions.\nThe sole aim of the players is to maximize their own winnings, independently of the other player. Here, the Nash Equilibrium is formed when two individuals act by considering the other\u0026rsquo;s movement and choose the best for their own situation instead of maximum gain.\n","date":"March 16, 2017","hero":"/posts/2017-03-16-prisonersdilemmavenashdengesi/blog11_prisoners-dilemma-kural-tablosu.jpg","permalink":"https://akifmt.github.io/posts/2017-03-16-prisonersdilemmavenashdengesi/","summary":"Get two people caught. If one testifies against the other and the other remains silent, the witness will be released, and the party who chooses to remain silent will be sentenced to 20 years in prison. If both remain silent, they will be sentenced to 1 year each. If both testify against each other, they will each be sentenced to 5 years.\nThe optimal option of the two is to keep both silent.","tags":["Game Theory","Prisoner Dilemma","Nash Equilibrium"],"title":"Game Theory - Prisoner's Dilemma and Nash Equilibrium"},{"categories":["shields.io"],"contents":"\nA tool for the ReadMe files of projects to display the project status in a nicer way. shields.io supports many tools used for project tracking. Travis, Jenkins and even Github allow badges to be added up to the release status of the project on SourceForce.\n","date":"March 16, 2017","hero":"/posts/2017-03-19-shields.io/blog12_shields.io.png","permalink":"https://akifmt.github.io/posts/2017-03-19-shields.io/","summary":"A tool for the ReadMe files of projects to display the project status in a nicer way. shields.io supports many tools used for project tracking. Travis, Jenkins and even Github allow badges to be added up to the release status of the project on SourceForce.","tags":["shields.io"],"title":"shields.io"},{"categories":["bash"],"contents":"\nActive folder: pwd Appearance: ls \u0026#39;Detailed View Parameters: -l *detailed* -lrt *detailed* -d *folder* -r *read* -w *write* -x *execute*\u0026#39; Active Folder Change: cd \u0026lt;folder name\u0026gt; File Creation: touch \u0026lt;filename\u0026gt; Displayed: ctrl+k \u0026#39;delete to the right\u0026#39; echo \u0026#34;hello world\u0026#34; echo \u0026#34;hello coders\u0026#34; \u0026gt; filename \u0026#39;Send output to file\u0026#39; echo $? \u0026#39;Returns the result of the last operation (0 successful)\u0026#39; cat filename \u0026#39;prints file contents\u0026#39; more filename \u0026#39;prints file contents\u0026#39; less filename \u0026#39;prints file contents\u0026#39; nano filename \u0026#39;opens with nano text editor\u0026#39; vim filename \u0026#39;opens with vim text editor\u0026#39; head -n 5 output-1.txt \u0026#39;show first 5 lines\u0026#39; tail -n 5 output-1.txt \u0026#39;show last 5 lines\u0026#39; tail -f log-file.txt \u0026#39;prints the last lines and follows the new incoming lines\u0026#39; Creating Folder: mkdir foldername \u0026#39;Creates folder\u0026#39; Run by Sending or Receiving Content: ./prog \u0026lt; input-1.txt \u0026#39;Executes the content of input-1 by sending it to the prog.\u0026#39; ./my-prog \u0026lt; input-1.txt \u0026gt; output-1.txt \u0026#39;assigns output to output\u0026#39; ./my-prog 12 2\u0026gt; output-1.txt \u0026#39;redirects input from stderr to output\u0026#39; ./my-prog \u0026lt; input-1.txt \u0026gt; all-output.txt 2\u0026gt;\u0026amp;1 \u0026#39;stderr, redirect to stdoutput\u0026#39; echo \u0026#34;asdasd\u0026#34; \u0026gt;\u0026gt; log-file.txt \u0026#39;add to end of file\u0026#39; Compilation: gcc -o my-prog my-prog.c \u0026#39;compiles with gcc.\u0026#39; Search in Process: ps aux | grep my-prog \u0026#39;do not search among running processes\u0026#39; Process Operations: \u0026#39;All processes start with: 0:stdinput 1:stdoutput 2:stderror\u0026#39; \u0026#39;The system proc folder where processes are kept.\u0026#39; \u0026#39; ctrl+c : interrupt (sigint) (sigterm) (sighup) -\u0026gt; updates the configuration (sigkill) -\u0026gt; kills without question ctrl+l : clear terminal does the action ctrl+d : (end of stream) kills the active process running \u0026#39; kill -l\t\u0026#39;shows list of signals for kill\u0026#39; kill -INT 12334\t\u0026#39;sends sigint signal\u0026#39; kill -TERM 12334\t\u0026#39;kills with sigterm signal\u0026#39; cat cmdline \u0026#39;running location\u0026#39; cat environ \u0026#39;process in environment variables\u0026#39; cat limits \u0026#39;process limits\u0026#39; top \u0026#39;shows transactions momentarily\u0026#39; htop \u0026#39;shows by updating\u0026#39; Path Operations: echo $PATH\t\u0026#39;path content\u0026#39; export PATH=$PATH:/home/vm/deneme\t\u0026#39;add new directory to end of path\u0026#39; Device Transactions: ls /dev \u0026#39;shows all devices\u0026#39; ls -lrt /dev/null \u0026#39;sends output to null\u0026#39; Data transfer: curl http://akifmt.github.io \u0026#39;downloads\u0026#39; curl http://akifmt.github.io \u0026gt; /dev/null \u0026#39;downloads results to null\u0026#39; curl -s http://akifmt.github.io \u0026gt; /dev/null\t\u0026#39;downloads in silent mode, sends results to null\u0026#39; curl http://akifmt.github.io \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\t\u0026#39;forward also incoming from stderr\u0026#39; curl -s https://demo.consul.io/v1/catalog/services \u0026#39;download in silent mode\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty \u0026#39;downloads in silent mode\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | grep Address \u0026#39;downloads in silent mode, finds Address lines\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | jq \u0026#39;.[0].Address\u0026#39; \u0026#39;Retrieves the first of the address part\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | jq -r \u0026#39;.[].Address\u0026#39; \u0026#39;Retrieves all Address parts\u0026#39; curl -s https://demo.consul.io/v1/catalog/service/web?pretty | jq -r \u0026#39;.[].Address\u0026#39; | while read serverAddr; do curl -s $serverAddr \u0026gt; $serverAddr.txt; done \u0026#39;Finds all Address lines, sends them to the right, creates a file based on the Address names\u0026#39; File Operations: echo \u0026#34;asd,qwe,qwwww\u0026#34; | cut -d, -f2 \u0026#39;takes the 2nd word after\u0026#39; echo \u0026#34;asd;qwe;qwwww\u0026#34; | cut -d\\; -f2 \u0026#39;; takes the 2nd word after\u0026#39; echo \u0026#34;asd,qwe,qwwww\u0026#34; | awk -F, \u0026#39;{print $2}\u0026#39; \u0026#39;takes the 2nd word after\u0026#39; ls -lrt | awk \u0026#39;{print $9}\u0026#39; \u0026#39;9. print columns\u0026#39; ls -lrt | cat \u0026#39;pipe outputs to the right one\u0026#39; wc -l \u0026#39;line counts\u0026#39; ls -lrt | wc -l \u0026#39;sends results from ls to the right and counts lines\u0026#39; find . -name my-prog \u0026#39;finds names starting with my-prog\u0026#39; find . -type f \u0026#39;finds files\u0026#39; find . -name \u0026#34;*.txt\u0026#34; \u0026#39;finds txt extension\u0026#39; find -name \u0026#34;*.txt\u0026#34; | while read filename; do echo $filename; done \u0026#39;finds txt, sends it to the server, prints it as filename\u0026#39; find -name \u0026#34;*.txt\u0026#34; | while read filename; do rm $filename; done \u0026#39;delete files found\u0026#39; dd if=/dev/zero of=zero-file.txt bs=512 count=2 \u0026#39;Creates 2x512KB empty file. \u0026#39; hexdump zero-file.txt \u0026#39;Displays in hex and abbreviated repetitive parts.\u0026#39; hexdump -v zero-file.txt \u0026#39;shows all without abbreviations\u0026#39; dd if=/dev/urandom of=random-file.txt bs=512 count=4 \u0026#39;creates 4x512KB file with random value\u0026#39; Operations on CPU: dd if=/dev/zero of=null \u0026#39;generates zero to send null to device (uncontrolled cpu load)\u0026#39; stress-ng -c 1 -l 40 \u0026#39;40% load on 1 CPU\u0026#39; stress-ng -c 0 -l 40 \u0026#39;loads 40% on all CPUs\u0026#39; Network Transactions: ifconfig \u0026#39;shows network devices and connections\u0026#39; route -n \u0026#39;shows all access\u0026#39; sudo wondershaper ens33 512 512 \u0026#39;Limits downloading and sending 512Kpbs\u0026#39; sudo wondershaper ens33 clear \u0026#39;removes limits\u0026#39; Satr Sonlar (lineending): OS Desc Code Linux LF (line feed) (\\n) Unix CR (carriage return) (\\r) Windows CRLF (carriage return line feed) \\r\\n ","date":"February 24, 2017","hero":"/posts/2017-02-24-linuxbashkomutlari/blog10_bash.png","permalink":"https://akifmt.github.io/posts/2017-02-24-linuxbashkomutlari/","summary":"Active folder: pwd Appearance: ls \u0026#39;Detailed View Parameters: -l *detailed* -lrt *detailed* -d *folder* -r *read* -w *write* -x *execute*\u0026#39; Active Folder Change: cd \u0026lt;folder name\u0026gt; File Creation: touch \u0026lt;filename\u0026gt; Displayed: ctrl+k \u0026#39;delete to the right\u0026#39; echo \u0026#34;hello world\u0026#34; echo \u0026#34;hello coders\u0026#34; \u0026gt; filename \u0026#39;Send output to file\u0026#39; echo $? \u0026#39;Returns the result of the last operation (0 successful)\u0026#39; cat filename \u0026#39;prints file contents\u0026#39; more filename \u0026#39;prints file contents\u0026#39; less filename \u0026#39;prints file contents\u0026#39; nano filename \u0026#39;opens with nano text editor\u0026#39; vim filename \u0026#39;opens with vim text editor\u0026#39; head -n 5 output-1.","tags":["bash"],"title":"Linux Bash Commands"},{"categories":["vmware hyper v"],"contents":"\nTo turn off Hyper-V; As administrator on cmd: bcdedit /set hypervisorlaunchtype off vmware available after reboot.\nTo turn Hyper-V back on As administrator on cmd: bcdedit /set hypervisorlaunchtype auto Hyper-V is available upon reboot.\n","date":"February 22, 2017","hero":"/posts/2017-02-22-hypervmwarebirlikte/blog9_vmwarehyperv.png","permalink":"https://akifmt.github.io/posts/2017-02-22-hypervmwarebirlikte/","summary":"To turn off Hyper-V; As administrator on cmd: bcdedit /set hypervisorlaunchtype off vmware available after reboot.\nTo turn Hyper-V back on As administrator on cmd: bcdedit /set hypervisorlaunchtype auto Hyper-V is available upon reboot.","tags":["vmware hyper v"],"title":"VMware and Hyper-V Combine"},{"categories":["Agile"],"contents":"\nAgile Methodology is a practice-based method for modeling and documenting software systems effectively and efficiently.\nSoftware projects are faced with the danger of failure due to improper use of resources, wrong prioritization and inaccurate understanding of customer demands throughout their lifecycle. According to The Standish Group\u0026rsquo;s 2009 Chaos Report, software projects fail at a rate of 68% worldwide. This has led large companies in Europe and America to try various methods to produce projects with higher productivity, and most companies have adopted Agile software development approaches, which they find most successful in management and practice.\nIncreasing when Agile approaches are applied;\nproject productivity, the ability of the project to adapt quickly to changes, project quality and speed to market of the project In line with this, the success rates of the projects have been increased to 80% and project profitability has been increased with the significant competitive advantage obtained.\nSource: www.acm-software.com/agile\n","date":"February 20, 2017","hero":"/posts/2017-02-20-agile/blog8_agile.jpg","permalink":"https://akifmt.github.io/posts/2017-02-20-agile/","summary":"Agile Methodology is a practice-based method for modeling and documenting software systems effectively and efficiently.\nSoftware projects are faced with the danger of failure due to improper use of resources, wrong prioritization and inaccurate understanding of customer demands throughout their lifecycle. According to The Standish Group\u0026rsquo;s 2009 Chaos Report, software projects fail at a rate of 68% worldwide. This has led large companies in Europe and America to try various methods to produce projects with higher productivity, and most companies have adopted Agile software development approaches, which they find most successful in management and practice.","tags":["Agile"],"title":"Agile"},{"categories":["Docker"],"contents":"What is Docker Docker is an open source project that deploy application. It works like a virtual machine, but better. Using a linux instance, it isolates itself from OS and works more secure. Docker defines itself like that on official website;\nDocker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries  anything that can be installed on a server. This guarantees that the software will always run the same, regardless of its environment.\nFor more information, www.docker.com\n","date":"November 24, 2016","hero":"/posts/2016-11-24-docker/blog7_docker.png","permalink":"https://akifmt.github.io/posts/2016-11-24-docker/","summary":"What is Docker Docker is an open source project that deploy application. It works like a virtual machine, but better. Using a linux instance, it isolates itself from OS and works more secure. Docker defines itself like that on official website;\nDocker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries  anything that can be installed on a server.","tags":["Docker"],"title":"What is Docker?"},{"categories":["Android 7 Nougat"],"contents":"\nNew features\nMulti-window / running two apps on the same screen (The most important feature) New notification center Revamped settings menu Notifications settings have been enriched. We will now be able to prevent every notification from appearing. Added the ability to go to the relevant menu of the settings by long pressing the icons in the notification Refreshing battery graph ","date":"November 2, 2016","hero":"/posts/2016-11-02-android7nougat/blog6_android7n_teaser.png","permalink":"https://akifmt.github.io/posts/2016-11-02-android7nougat/","summary":"\nNew features\nMulti-window / running two apps on the same screen (The most important feature) New notification center Revamped settings menu Notifications settings have been enriched. We will now be able to prevent every notification from appearing. Added the ability to go to the relevant menu of the settings by long pressing the icons in the notification Refreshing battery graph ","tags":["Android 7 Nougat"],"title":"Android 7 Nougat"},{"categories":["monte carlo metodu"],"contents":"\nNedir: Rastgele saylar kullanlarak sistemlerin modellenmesinde kullanlabilir. Sistemin kesin sonucunun olduu baz durumlarda, veya olmad tm durumlarda uygulanabilir. rnek says doru sonular elde etmede byk nem tamaktadr. Pi says hesaplama, yaz tura ve zar hesaplamas rnek gsterilebilir.\nrnek: C ile Yaz-Tura double rastgele(){ double r = (double) rand()/RAND_MAX; return r; } int main() { int i, tura, yazi, n; double r, p; printf(\u0026#34;deney sayisini girin: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); srand( time(NULL) ); for(tura=0, i=1; i\u0026lt;=n; i++){ r = rastgele(); if(r\u0026lt;0.5) tura++; } p = (double) tura/n; yazi = n-tura; printf(\u0026#34;tura sayisi: %d\\n\u0026#34;,tura); printf(\u0026#34;yazi sayisi: %d\\n\u0026#34;,yazi); printf(\u0026#34;Olasiliklar: %lf %lf\\n\u0026#34;,p, 1.0-p); return 0; } ","date":"October 9, 2016","hero":"/posts/2016-10-09-montecarlometodu/blog5_montecarlometodu.png","permalink":"https://akifmt.github.io/posts/2016-10-09-montecarlometodu/","summary":"Nedir: Rastgele saylar kullanlarak sistemlerin modellenmesinde kullanlabilir. Sistemin kesin sonucunun olduu baz durumlarda, veya olmad tm durumlarda uygulanabilir. rnek says doru sonular elde etmede byk nem tamaktadr. Pi says hesaplama, yaz tura ve zar hesaplamas rnek gsterilebilir.\nrnek: C ile Yaz-Tura double rastgele(){ double r = (double) rand()/RAND_MAX; return r; } int main() { int i, tura, yazi, n; double r, p; printf(\u0026#34;deney sayisini girin: \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); srand( time(NULL) ); for(tura=0, i=1; i\u0026lt;=n; i++){ r = rastgele(); if(r\u0026lt;0.","tags":["monte carlo metodu"],"title":"Monte Carlo Method"},{"categories":["Raspberry Pi","Remote Desktop Connection"],"contents":"\nProblem: Raspbery Pi Remote Connection TR Keyboard Not Recognizing Solution: missing km-041f.ini file\nCopy the km-041f.ini file to the /etc/xrdp/ directory on the Raspberry Pi. When xrdp is restarted, TR characters are no longer a problem.\nThe thing to note is that you must access the directory as root.\nThe step I followed; sudo pcmanfm on RasPi Copy the km-041f.ini file to /etc/xrdp/.\nsudo service xrdp restart\nNote: For those who have problems finding the file on the net, I downloaded it from this repo: Link ","date":"September 18, 2016","hero":"/posts/2016-09-18-raspberrypiilerdcbaglantisi/blog4_rasPiRDC.png","permalink":"https://akifmt.github.io/posts/2016-09-18-raspberrypiilerdcbaglantisi/","summary":"\nProblem: Raspbery Pi Remote Connection TR Keyboard Not Recognizing Solution: missing km-041f.ini file\nCopy the km-041f.ini file to the /etc/xrdp/ directory on the Raspberry Pi. When xrdp is restarted, TR characters are no longer a problem.\nThe thing to note is that you must access the directory as root.\nThe step I followed; sudo pcmanfm on RasPi Copy the km-041f.ini file to /etc/xrdp/.\nsudo service xrdp restart\nNote: For those who have problems finding the file on the net, I downloaded it from this repo: Link ","tags":["Raspberry Pi","Remote Desktop Connection"],"title":"Raspberry Pi Remote Desktop Turkish Keyboard Problem"},{"categories":["remote desktop","amazon aws","microsoft azure"],"contents":"\nSince VPS devices on AWS or Azure do not have a real sound card, it is not possible to receive sound on these devices. The solution for this is VA, that is, virtual audio. Our convenient application solution is solved with VAC installation. The application creates a virtual sound driver and directs the sound to our device.\nProblem: Voice over VPS Solution: Virtual Audio Cable 4.15 installation and Setup\nInstall \u0026ldquo;Virtual Audio Cable 4.15\u0026rdquo; that I tested on VPS.\nRDP-Tcp -\u0026gt; client services -\u0026gt; audio in \u0026ldquo;tsconfig.msc\u0026rdquo; on VPS remove the option. Reset VPS.\nAfter this step, the sound is ready.\nDownload link:\nGoogle -\u0026gt; Virtual Audio Cable 4.15 ","date":"August 22, 2016","hero":"/posts/2016-08-22-rdcileawsveazurevpsuzerindevacileses/blog3_vac_teaser.png","permalink":"https://akifmt.github.io/posts/2016-08-22-rdcileawsveazurevpsuzerindevacileses/","summary":"Since VPS devices on AWS or Azure do not have a real sound card, it is not possible to receive sound on these devices. The solution for this is VA, that is, virtual audio. Our convenient application solution is solved with VAC installation. The application creates a virtual sound driver and directs the sound to our device.\nProblem: Voice over VPS Solution: Virtual Audio Cable 4.15 installation and Setup","tags":["remote desktop","amazon aws","microsoft azure"],"title":"Application Sounds on Amazon AWS and Azure with Remote Desktop"},{"categories":["INVICTUS"],"contents":"\nThe company works on cyber security and security training. I also contacted my friend\u0026rsquo;s reference. The sincerity I saw from day one surprised me. I saw a full family relationship in the company, from management to employees. With the experienced team, they included them at every point by providing training on cyber security at a high-level security level, starting from scratch. The company is experienced in cyber security and even works towards becoming a world brand. The training activities of the company in cyber security are also successful enough to be called the first in their field. Thank you to everyone from the company\u0026rsquo;s management to its employees. I would suggest those interested in cyber security to follow the link. Company information is below.\nwww.invictuseurope.com Contact: www.invictuseurope.com/iletisim Education: egitim.invictuseurope.com\n","date":"August 3, 2016","hero":"/posts/2016-08-03-invictusbilisimguvenlikstajyapmak/blog2_invictus_teaser.png","permalink":"https://akifmt.github.io/posts/2016-08-03-invictusbilisimguvenlikstajyapmak/","summary":"The company works on cyber security and security training. I also contacted my friend\u0026rsquo;s reference. The sincerity I saw from day one surprised me. I saw a full family relationship in the company, from management to employees. With the experienced team, they included them at every point by providing training on cyber security at a high-level security level, starting from scratch. The company is experienced in cyber security and even works towards becoming a world brand.","tags":["INVICTUS"],"title":"INVICTUS, Internship in IT Security"},{"categories":["pokemon go","what is it"],"contents":"A game that can be played on mobile platforms. The biggest innovation and feature is virtualized reality technology. Using real location information, it provides a better player experience, catching 722 Pokemon characters, trades and battles. The official introduction is as follows:\n","date":"July 10, 2016","hero":"/posts/2016-07-10-pokemongooynamak/blog1_pokemon_go_logo.png","permalink":"https://akifmt.github.io/posts/2016-07-10-pokemongooynamak/","summary":"A game that can be played on mobile platforms. The biggest innovation and feature is virtualized reality technology. Using real location information, it provides a better player experience, catching 722 Pokemon characters, trades and battles. The official introduction is as follows:","tags":["pokemon go","what is it"],"title":"Playing Pokemon GO!"},{"categories":null,"contents":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/projects/project1/","summary":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","tags":null,"title":"project1en"},{"categories":null,"contents":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","date":"January 1, 0001","hero":"/images/default-hero.jpg","permalink":"https://akifmt.github.io/projects/project2/","summary":"Table of contents Table of contents Text Code Python C/C++ Bash Tables Text Some example text\nCode Python def foo(): print (\u0026#34;This is a python function\u0026#34;) C/C++ void foo(){ prinf(\u0026#34;%s\\n\u0026#34;, \u0026#34;This is a C function\u0026#34;) } Bash # This is a bash command cd dir \u0026amp;\u0026amp; echo $PWD; # Return exit 0; Tables Pages Elements 1 Text 2 Code 3 Tables ","tags":null,"title":"project2en"}]